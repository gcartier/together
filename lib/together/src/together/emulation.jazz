;;;===============
;;;  WorldScheme
;;;===============
;;;
;;;; UDP Emulation
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module together.emulation jazz


(import (jazz.math)
        (jazz.stream)
        (world)
        (world.audio)
        (world.client.tier)
        (world.context)
        (world.event)
        (world.evolution)
        (world.client.udp)
        (world.server.udp)
        (world.settings)
        (world.simulation)
        (world.udp)
        (world.video))


(definition show-visualize?
  (world-setting 'world.show-visualize? #f))

(definition debug-visualize?
  (world-setting 'world.debug-visualize? #f))


(definition protected video-position
  {Point 176 39})

(definition protected (set-video-position position)
  (set! video-position position))


(definition protected video-size
  {Dimension 178 100})

(definition protected (set-video-size size)
  (set! video-size size))


;;;
;;;; Ring
;;;


(class Ring-Emulator extends Object
  
  
  (slot call                      getter generate)
  (slot origin                    getter generate)
  (slot evolution                 getter generate)
  (slot audio-channel             getter generate)
  (slot video-channel             getter generate)
  (slot audio-ring                getter generate)
  (slot video-ring                getter generate)
  (slot audio-datas               getter generate)
  (slot video-datas               getter generate)
  (slot audio-adds                getter generate)
  (slot video-adds                getter generate)
  (slot audio-removes             getter generate)
  (slot video-removes             getter generate)
  (slot last-time   initialize #f accessors generate)
  (slot last-event  initialize #f accessors generate)
  
  
  (method override (initialize self call origin evolution audio-datas video-datas)
    (nextmethod self)
    (set! self.call call)
    (set! self.origin origin)
    (set! self.evolution evolution)
    (set! self.audio-datas audio-datas)
    (set! self.video-datas video-datas)
    (set! self.audio-adds (make-table test: eqv?))
    (set! self.video-adds (make-table test: eqv?))
    (set! self.audio-removes (make-table test: eqv?))
    (set! self.video-removes (make-table test: eqv?)))
  
  
  (method protected (emulate self to-time playing?)
    (emulate-from self #f to-time playing?))
  
  
  (method protected (emulate-from-last self to-time playing?)
    (emulate-from self (and last-event (+ last-event 1)) to-time playing?))
  
  
  (method protected (emulate-from self from-event to-time playing?)
    (declare (proper-tail-calls))
    (let ((first (first-position evolution))
          (last (last-position evolution)))
      (let (loop (n (or from-event first)))
        (when (<= n last)
          (let ((time (evolutionary-udp-time evolution n)))
            (when (<= time to-time)
              (emulate-event self n playing?)
              (set! last-time time)
              (set! last-event n)
              (loop (+ n 1))))))))
  
  
  (method protected virtual (emulate-event self n playing?)
    ))


;;;
;;;; Retain
;;;


(class Retain-Emulator extends Ring-Emulator
  
  
  (method override (emulate-event self n playing?)
    (when (= (evolutionary-udp-origin evolution n) origin)
      (let ((id (evolutionary-udp-id evolution n))
            (kind (flonum->fixnum (evolutionary-udp-kind evolution n))))
        (let ((ring (if (= kind udp-audio) audio-ring video-ring))
              (datas (if (= kind udp-audio) audio-datas video-datas))
              (adds (if (= kind udp-audio) audio-adds video-adds))
              (removes (if (= kind udp-audio) audio-removes video-removes)))
          (define (find-data sequence)
            (table-ref datas sequence #f))
          
          (ecase id
            ;; retain
            ((udp-id-retain-packet)
             (let ((time (evolutionary-udp-time evolution n))
                   (sequence (evolutionary-udp-sequence evolution n)))
               (let ((time-base (let ((time-base (evolutionary-udp-data5 evolution n)))
                                  ;; quick hack for timeless
                                  (if (= time-base -1.)
                                      (- time (evolutionary-udp-data4 evolution n))
                                    time-base)))
                     (time-latency (evolutionary-udp-data3 evolution n)))
                 (let ((data (find-data sequence)))
                   (when data
                     (when show-visualize?
                       (terminal 'retain sequence))
                     (visualizer-update-time ring time-base time-latency)
                     (let ((from (and (/= (get-count ring) 0) (get-highest ring))))
                       (insert ring data)
                       (table-set! adds sequence time)
                       (when from
                         (let ((to (get-highest ring)))
                           (loop (for seq from (+ from 1) below to)
                                 (table-set! adds seq time))))))))))
            ;; got
            ((udp-id-got-packet)
             (let ((sequence (evolutionary-udp-sequence evolution n)))
               (let ((data (find-data sequence)))
                 (when data
                   (when show-visualize?
                     (terminal 'got sequence))
                   (visualizer-replace-got ring sequence data)))))
            ;; release
            ((udp-id-release-packet)
             (let ((sequence (evolutionary-udp-sequence evolution n)))
               (when show-visualize?
                 (terminal 'release sequence))
               (let ((packet (earliest-packet ring)))
                 (let ((consistent? (and packet (eqv? (get-sequence packet) sequence))))
                   (when (if debug-visualize? (assert consistent? #t) consistent?)
                     (table-set! removes (get-sequence packet) (list packet (evolutionary-udp-time evolution n) #f))
                     (remove-packet ring))))))))))))


;;;
;;;; Sender
;;;


(class Sender-Emulator extends Retain-Emulator
  
  
  (method override (initialize self call tier origin evolution audio-datas video-datas channel-name)
    (nextmethod self call origin evolution audio-datas video-datas)
    (let ((sender (require-tier call tier)))
      (set! audio-channel (require-send-channel sender channel-name udp-audio))
      (set! video-channel (require-send-channel sender channel-name udp-video)))
    (set! self.audio-ring (get-retain-ring audio-channel))
    (set! self.video-ring (get-retain-ring video-channel))))


;;;
;;;; Server
;;;


(class Server-Emulator extends Retain-Emulator
  
  
  (method override (initialize self call tier origin evolution audio-datas video-datas channel-name)
    (nextmethod self call origin evolution audio-datas video-datas)
    (let ((server (require-tier call tier)))
      (set! audio-channel (require-server-channel server channel-name origin udp-audio))
      (set! video-channel (require-server-channel server channel-name origin udp-video)))
    (set! self.audio-ring (get-retain-ring audio-channel))
    (set! self.video-ring (get-retain-ring video-channel))))


;;;
;;;; Receiver
;;;


(class Receiver-Emulator extends Ring-Emulator
  
  
  (slot origin-audio                     getter generate)
  (slot origin-audio-header              getter generate)
  (slot origin-video                     getter generate)
  (slot origin-evolution                 getter generate)
  (slot audio-header-played?             getter generate)
  (slot video-header-played?             getter generate)
  (slot audio-output       initialize #f getter generate)
  (slot video-output       initialize #f getter generate)
  
  
  (method override (initialize self call tier origin origin-audio origin-audio-header origin-video origin-evolution evolution audio-datas video-datas channel-name)
    (nextmethod self call origin evolution audio-datas video-datas)
    (let ((receiver (require-tier call tier)))
      (set! audio-channel (require-receive-channel receiver channel-name origin udp-audio))
      (set! video-channel (require-receive-channel receiver channel-name origin udp-video)))
    (set! self.audio-ring (get-process-ring audio-channel))
    (set! self.video-ring (get-process-ring video-channel))
    (set! self.origin-audio origin-audio)
    (set! self.origin-audio-header origin-audio-header)
    (set! self.origin-video origin-video)
    (set! self.origin-evolution origin-evolution)
    (when audio-output
      (release audio-output))
    (set! self.audio-output (and origin-audio (visualizer-output (current-audio))))
    (when video-output
      (release video-output))
    (set! self.video-output (and origin-video (visualizer-output (current-video) video-position video-size)))
    (set! self.audio-header-played? #f)
    (set! self.video-header-played? #f))
  
  
  (method override (emulate-event self n playing?)
    (when (= (evolutionary-udp-origin evolution n) origin)
      (let ((id (evolutionary-udp-id evolution n))
            (kind (flonum->fixnum (evolutionary-udp-kind evolution n))))
        (let ((ring (if (= kind udp-audio) audio-ring video-ring))
              (datas (if (= kind udp-audio) audio-datas video-datas))
              (adds (if (= kind udp-audio) audio-adds video-adds))
              (removes (if (= kind udp-audio) audio-removes video-removes)))
          (define (find-data sequence)
            (table-ref datas sequence #f))
          
          (ecase id
            ;; self / src / sink / draw
            ((udp-id-src-self udp-id-src-media udp-id-sink-media udp-id-draw-video))
            ;; create / info
            ((udp-id-create-packet udp-id-create-info))
            ;; retain / release
            ((udp-id-retain-packet udp-id-release-packet))
            ;; resend / absent
            ((udp-id-resend-packet udp-id-absent-packet))
            ;; time
            ((udp-id-update-time))
            ;; insert
            ((udp-id-insert-packet)
             (let ((time (evolutionary-udp-time evolution n))
                   (sequence (evolutionary-udp-sequence evolution n)))
               (let ((time-base (let ((time-base (evolutionary-udp-data5 evolution n)))
                                  ;; quick hack for timeless
                                  (if (= time-base -1.)
                                      (- time (evolutionary-udp-data4 evolution n))
                                    time-base)))
                     (time-latency (evolutionary-udp-data3 evolution n)))
                 (let ((data (find-data sequence)))
                   (when data
                     (when show-visualize?
                       (terminal 'insert sequence))
                     (visualizer-update-time ring time-base time-latency)
                     (let ((from (and (/= (get-count ring) 0) (get-highest ring))))
                       (insert ring data)
                       (table-set! adds sequence time)
                       (when from
                         (let ((to (get-highest ring)))
                           (loop (for seq from (+ from 1) below to)
                                 (table-set! adds seq time))))))))))
            ;; nack
            ((udp-id-nack-packet))
            ;; gap
            ((udp-id-packet-gap))
            ;; got
            ((udp-id-got-packet)
             (let ((sequence (evolutionary-udp-sequence evolution n)))
               (let ((data (find-data sequence)))
                 (when data
                   (when show-visualize?
                     (terminal 'got sequence))
                   (visualizer-replace-got ring sequence data)))))
            ;; duplicate
            ((udp-id-duplicate-packet))
            ;; reject
            ((udp-id-reject-packet))
            ;; play / freeze
            ((udp-id-play-frame udp-id-freeze-frame)
             (let ((frame (evolutionary-udp-frame evolution n)))
               (when show-visualize?
                 (terminal 'play frame))
               (let ((packet (earliest-packet ring)))
                 (let ((consistent? (and packet (eqv? (get-frame packet) frame))))
                   (when (if debug-visualize? (assert consistent? #t) consistent?)
                     ;; we cannot rely on having the headers in the evolution
                     ;; on the other hand playing implies state ok or late...
                     (if (= id udp-id-play-frame)
                         (state-ok ring)
                       (state-late ring))
                     (let ((complete? (frame-complete? ring 0)))
                       (visualizer-iterate-frame ring
                         (lambda (packet)
                           (table-set! removes (get-sequence packet) (list packet (evolutionary-udp-time evolution n) complete?))))
                       (when complete?
                         (let ((origin-media (if (= kind udp-audio) origin-audio origin-video)))
                           (when origin-media
                             (let ((first (packet-ref ring 0)))
                               (let ((sequence (get-sequence first))
                                     (total (get-total first))
                                     (header? (get-header? first)))
                                 (let ((packets (loop (for n from 0 below total)
                                                      (collect (locate-packet origin-media (+ sequence n))))))
                                   (when (loop (for packet in packets)
                                               (every (and packet (get-data packet))))
                                     (let ((buffer (if (= total 1)
                                                       (read-udp-media-payload (get-data (car packets)))
                                                     (let ((chunks (map read-udp-media-payload (map get-data packets))))
                                                       (apply u8vector-append chunks))))
                                           (timestamp (flonum->timestamp (get-timestamp packet)))
                                           (duration (get-duration packet)))
                                       (ecase kind
                                         ((udp-audio)
                                          (let ()
                                            (define (play-header buffer)
                                              ;; quick backward compatibility hack
                                              (when (u8vector? buffer)
                                                (let ((headers (u8vector->object buffer)))
                                                  (for-each (lambda (header)
                                                              (bind (buffer timestamp duration) header
                                                                (receive-visualizer-audio (current-audio) audio-output buffer timestamp duration)))
                                                            headers)
                                                  (set! audio-header-played? #t))))
                                            
                                            (when (or playing? header?)
                                              (if (and header? (eq? audio-codec 'vorbis))
                                                  (play-header origin-audio-header @mega-quick-hack-for-simulation buffer)
                                                (when (and origin-audio-header
                                                           (not audio-header-played?))
                                                  (play-header origin-audio-header))
                                                (receive-visualizer-audio (current-audio) audio-output buffer timestamp duration)))))
                                         ((udp-video)
                                          (if header?
                                              (begin
                                                (set! video-header-played? #t)
                                                (receive-visualizer-video (current-video) video-output buffer timestamp duration))
                                            (when video-header-played?
                                              (receive-visualizer-video (current-video) video-output buffer timestamp duration))))))))))))))
                     (visualizer-remove-frame ring))))))
            ;; missing
            ((udp-id-missing-packet)
             (let ((sequence (evolutionary-udp-sequence evolution n)))
               (when show-visualize?
                 (terminal 'missing sequence))
               (let ((packet (earliest-packet ring)))
                 (let ((consistent? (and packet (eqv? (get-sequence packet) sequence))))
                   (when (if debug-visualize? (assert consistent? #t) consistent?)
                     (assert (not (get-data packet))
                       (table-set! removes (get-sequence packet) (list packet (evolutionary-udp-time evolution n) #f))
                       (remove-packet ring)))))))
            ;; discard
            ((udp-id-discard-packet)
             (let ((sequence (evolutionary-udp-sequence evolution n)))
               (when show-visualize?
                 (terminal 'discard sequence))
               (let ((packet (earliest-packet ring)))
                 (let ((consistent? (and packet (eqv? (get-sequence packet) sequence))))
                   (when (if debug-visualize? (assert consistent? #t) consistent?)
                     (assert (get-data packet)
                       (table-set! removes (get-sequence packet) (list packet (evolutionary-udp-time evolution n) (frame-complete? ring 0)))
                       (remove-packet ring)))))))
            ;; ok
            ((udp-id-state-ok)
             (when show-visualize?
               (terminal 'ok))
             (state-ok ring))
            ;; late
            ((udp-id-state-late)
             (when show-visualize?
               (terminal 'late))
             (state-late ring))
            ;; waiting
            ((udp-id-state-waiting)
             (when show-visualize?
               (terminal 'waiting))
             (state-waiting ring))
            ;; ack / traffic
            ((udp-id-receive-ack udp-id-traffic-rate))
            ;; reset
            ((udp-id-reset-media))
            ;; throttle throttle-on throttle-off
            ((udp-id-throttle-frame udp-id-throttle-on udp-id-throttle-off))
            ;; system
            ((udp-id-paint-event udp-id-reshape-event udp-id-close-event udp-id-key-event udp-id-char-event udp-id-button-event udp-id-moved-event udp-id-wheel-event udp-id-file-event udp-id-drop-event udp-id-enter-event udp-id-leave-event udp-id-activate-event udp-id-deactivate-event udp-id-quit-event udp-id-user-event udp-id-other-event))
            ;; other
            (else
             (terminal 'unemulated (evolution-id->abbrev id)))))))))


;;;
;;;; Utility
;;;


(definition (require-send-channel tier name kind)
  (continuation-capture
    (lambda (return)
      (iterate-table (get-send-channels tier)
        (lambda (no channel)
          (when (and (equal? (get-name channel) name)
                     (= (get-media-kind channel) kind))
            (continuation-return return channel))))
      (error "Unable to find channel"))))


(definition (require-server-channel tier name origin kind)
  (continuation-capture
    (lambda (return)
      (iterate-table (get-server-channels tier)
        (lambda (no channel)
          (when (and (equal? (get-name channel) name)
                     (= (get-origin channel) origin)
                     (= (get-media-kind channel) kind))
            (continuation-return return channel))))
      (error "Unable to find channel"))))


(definition (require-receive-channel tier name origin kind)
  (continuation-capture
    (lambda (return)
      (iterate-table (get-receive-channels tier)
        (lambda (no channel)
          (when (and (equal? (get-name channel) name)
                     (= (get-origin channel) origin)
                     (= (get-media-kind channel) kind))
            (continuation-return return channel))))
      (error "Unable to find channel")))))
