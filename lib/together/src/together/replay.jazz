;;;============
;;;  Together
;;;============
;;;
;;;; Replay Stage
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module together.replay jazz


(import (jazz.application)
        (jazz.component)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.handler)
        (jazz.markup)
        (jazz.outline)
        (jazz.resource)
        (jazz.tree)
        (jazz.ui)
        (jazz.view)
        (jazz.window)
        (world)
        (world.chronology)
        (world.context)
        (world.evolution)
        (world.interface.evolution)
        (world.interface.timeline)
        (world.manager)
        (world.settings)
        (world.udp)
        (together))


(definition protected evolutions-range
  .025)


(definition package (timeline-view/now-update zone from to now)
  (let ((root (get-root zone))
        (replay (get-replay zone)))
    (let ((panel (child root 'evolution)))
      (let ((names (get-names replay))
            (evolutions (get-evolutions replay))
            (base-time (get-base-time replay)))
        (set-from replay from)
        (set-to replay to)
        (set-now replay now)
        (set-highlighted-cells replay '())
        (when now
          (view-evolutions-at panel (- now evolutions-range) (+ now evolutions-range) now))
        (highlight-replay-value zone)
        (set-setting options-settings 'world.last-replay (list (get-name (get-directory replay)) from to now))
        (save-content options-settings)))))


(definition package (highlight-replay-value zone)
  (let ((root (get-root zone))
        (replay (get-replay zone)))
    (let ((value (get-highlighted-value replay))
          (col (get-highlighted-column replay)))
      (when value
        (let ((panel (child root 'evolution)))
          (let ((origin (get-highlighted-origin replay))
                (kind (get-highlighted-kind replay))
                (tree (locate panel 'entries)))
            (highlight-value zone tree origin kind value col)
            (invalidate-view tree)))))))


(definition package (evolution-selection-update zone selection)
  (let ((root (get-root zone))
        (replay (get-replay zone)))
    (when (not-null? selection)
      (let ((panel (child root 'evolution)))
        (let ((tree (locate panel 'entries)))
          ;; unhighlight
          (for-each (lambda (cell)
                      (let ((data (get-cell-data tree cell)))
                        (set-frame-color data #f)))
                    (get-highlighted-cells replay))
          (set-highlighted-value replay #f)
          (set-highlighted-cells replay '())
          ;; highlight
          (let ((cell (car selection)))
            (let ((line (get-line cell))
                  (col (get-col cell)))
              (let ((row (get-row tree line)))
                (let ((user-data (get-user-data row))
                      (sequence? (= col 5)))
                  (let ((origin (and sequence? (vector-ref user-data (- col 2))))
                        (kind (and sequence? (vector-ref user-data (- col 1))))
                        (value (vector-ref user-data col)))
                    (highlight-value zone tree origin kind value col))))))
          ;; invalidate
          (invalidate-view tree))))
    ;; timeline highlighted
    (let ((timeline (child root 'timeline))
          (panel (child root 'evolution)))
      (let ((tree (locate panel 'entries)))
        (let ((selection (get-selection tree)))
          (if (null? selection)
              (set-highlighted-value timeline #f)
            (let ((cell (car selection)))
              (let ((line (get-line cell))
                    (col (get-col cell)))
                (cond ;; time
                      ((= col 0)
                       (let ((row (get-row tree line)))
                         (let ((user-data (get-user-data row)))
                           (let ((value (vector-ref user-data col)))
                             (set-highlighted-value timeline value)
                             (set-highlighted-column timeline 1)))))
                      ;; tier
                      ((= col 1)
                       (let ((row (get-row tree line)))
                         (let ((user-data (get-user-data row)))
                           (let ((value (vector-ref user-data col)))
                             (if (neq? value (get-tier replay))
                                 (set-highlighted-value timeline #f)
                               (set-highlighted-value timeline value)
                               (set-highlighted-column timeline 0))))))
                      ;; sequence
                      ((= col 5)
                       (let ((row (get-row tree line)))
                         (let ((user-data (get-user-data row)))
                           (let ((origin (vector-ref user-data (- col 2)))
                                 (kind (vector-ref user-data (- col 1)))
                                 (value (vector-ref user-data col)))
                             (set-highlighted-origin timeline origin)
                             (set-highlighted-kind timeline kind)
                             (set-highlighted-value timeline value)
                             (set-highlighted-column timeline col)))))
                      ;; value
                      (else
                       (let ((row (get-row tree line)))
                         (let ((user-data (get-user-data row)))
                           (let ((value (vector-ref user-data col)))
                             (set-highlighted-value timeline value)
                             (set-highlighted-column timeline col)))))))))
          (invalidate-view timeline))))))


(definition package (highlight-value zone tree origin kind value col)
  (let ((replay (get-replay zone)))
    (set-highlighted-origin replay origin)
    (set-highlighted-kind replay kind)
    (set-highlighted-value replay value)
    (set-highlighted-column replay col)
    (for-each-visible-row tree
      (lambda (row line)
        (let ((user-data (get-user-data row))
              (sequence? (= col 5)))
          (let ((data-origin (and sequence? (vector-ref user-data (- col 2))))
                (data-kind (and sequence? (vector-ref user-data (- col 1))))
                (data-value (vector-ref user-data col)))
            (when (and (eqv? data-value value)
                       (or (not origin) (eqv? data-origin origin))
                       (or (not kind) (eqv? data-kind kind)))
              (let ((data (get-child row col)))
                (set-frame-color data {Color Red})
                (set-highlighted-cells replay (cons (new Cell line col) (get-highlighted-cells replay)))))))))))


;;;
;;;; Replay
;;;


(class Replay extends Object
  
  
  (slot directory    getter generate)
  (slot tier         getter generate)
  (slot names        getter generate)
  (slot metadatas    getter generate)
  (slot chronologies getter generate)
  (slot evolutions   getter generate)
  (slot base-time    getter generate)
  (slot head         getter generate)
  (slot tail         getter generate)
  
  (slot from               initialize #f  accessors generate)
  (slot to                 initialize #f  accessors generate)
  (slot now                initialize #f  accessors generate)
  (slot highlighted-origin initialize #f  accessors generate)
  (slot highlighted-kind   initialize #f  accessors generate)
  (slot highlighted-value  initialize #f  accessors generate)
  (slot highlighted-column initialize #f  accessors generate)
  (slot highlighted-cells  initialize '() accessors generate)
  
  
  (method override (initialize self directory tier names metadatas chronologies evolutions base-time)
    (define (determine-head)
      (apply min (map (lambda (evolution)
                        (evolutionary-time evolution (first-position evolution)))
                      (table-values evolutions))))
    
    (define (determine-tail)
      (apply max (map (lambda (evolution)
                        (evolutionary-time evolution (last-position evolution)))
                      (table-values evolutions))))
    
    (nextmethod self)
    (set! self.directory directory)
    (set! self.tier tier)
    (set! self.names names)
    (set! self.metadatas metadatas)
    (set! self.chronologies chronologies)
    (set! self.evolutions evolutions)
    (set! self.base-time base-time)
    (set! self.head (determine-head))
    (set! self.tail (determine-tail))))


;;;
;;;; Timeline
;;;


(class Together-Timeline-Panel extends Timeline-Panel
  
  
  (slot evolutions          initialize '() accessors generate)
  (slot highlighted-title   initialize #f  accessors generate)
  (slot highlighted-markers initialize #f  accessors generate)
  (slot highlighted-origin  initialize #f  accessors generate)
  (slot highlighted-kind    initialize #f  accessors generate)
  (slot highlighted-value   initialize #f  accessors generate)
  (slot highlighted-column  initialize #f  accessors generate)
  
  
  (method override (mouse-up self evt)
    (if (in-rect? (get-position evt) {Rect 0 0 100 18})
        (let ((world (current-world))
              (zone (current-zone)))
          (let ((range (if (= evolutions-range .025) 1. .025)))
            (set! evolutions-range range)
            (timeline-view/now-update zone from to now)
            (display-message world (format "Range {a}" range))))
      (nextmethod self evt)))
  
  
  (method override (border-color self)
    {Color Dark-Gray})
  
  
  (method override (plot-evolutions self surface from to)
    (let ((width (cast <fl> (get-width self)))
          (now-h (and now (when->h self from to span now))))
      (cond (highlighted-markers
             (let ((first (first-position chronology))
                   (last (last-position chronology)))
               (define (find-head)
                 (loop (for n from first to last)
                       (when (>= (chronological-time chronology n) from)
                         (return n))
                       (finally first)))
               
               (define (find-tail head)
                 (loop (for n from head to last)
                       (when (> (chronological-time chronology n) to)
                         (return (- n 1)))
                       (finally last)))
               
               (let ((head (find-head)))
                 (let ((tail (find-tail head)))
                   (draw-text surface 5 3 (->string highlighted-title) timeline-text-color)
                   (for-each (lambda (n)
                               (when (and (>= n head)
                                          (<= n tail))
                                 (let ((time (chronological-time chronology n))
                                       (marker (chronological-marker chronology n)))
                                   (let ((h (fxround (* (/ (- time from) span) width))))
                                     (let ((color (if (even? marker) {Color Purple} {Color Red}))
                                           (v 120))
                                       (fill-rect surface (new Rect (- h 0) (- v 4) (+ h 1) (+ v 5)) color))))))
                             highlighted-markers)))))
            (highlighted-value
             (draw-text surface 150 3 (->string highlighted-value) timeline-text-color)
             (iterate-table evolutions
               (lambda (id evolution)
                 (let ((first (first-position evolution))
                       (last (last-position evolution)))
                   (define (find-head)
                     (loop (for n from first to last)
                           (when (>= (evolutionary-time evolution n) from)
                             (return n))
                           (finally first)))
                   
                   (define (find-tail head)
                     (loop (for n from head to last)
                           (when (> (evolutionary-time evolution n) to)
                             (return (- n 1)))
                           (finally last)))
                   
                   (let ((head (find-head)))
                     (let ((tail (find-tail head)))
                       (define (highlighted-rect time id kind)
                         (let ((h (fxround (* (/ (- time from) span) width))))
                           (let ((color (ecase id
                                          ((udp-id-create-packet) {Color Yellow})
                                          ((udp-id-add-retain) {Color Yellow})
                                          ((udp-id-add-nack) {Color Blue})
                                          ((udp-id-add-process) {Color Blue})
                                          ((udp-id-remove-process) {Color Green})
                                          ((udp-id-discard-packet udp-id-duplicate-packet) {Color Orange})
                                          ((udp-id-remove-retain) {Color Dark-Gray})
                                          (else {Color Red})))
                                 (left (- h 2))
                                 (right (+ h 3))
                                 (v (if (= kind udp-audio) 117 124)))
                             (let ((rect (new Rect left (- v 2) right (+ v 3))))
                               (fill-rect surface rect color)
                               (when (and now (between? now-h left right))
                                 (unless (memv? id highlighted)
                                   (set! highlighted (cons id highlighted))))))))
                       
                       (loop (for n from head to tail)
                             (case highlighted-column
                               ((0)
                                (let ((time (evolutionary-time evolution n))
                                      (id (evolutionary-id evolution n))
                                      (kind (evolutionary-data2 evolution n)))
                                  (highlighted-rect time id kind)))
                               ((5)
                                (let ((time (evolutionary-time evolution n))
                                      (origin (evolutionary-data1 evolution n))
                                      (kind (evolutionary-data2 evolution n))
                                      (value (evolutionary-data3 evolution n)))
                                  (when (and (eqv? origin highlighted-origin)
                                             (eqv? kind highlighted-kind)
                                             (eqv? value highlighted-value))
                                    (let ((id (evolutionary-id evolution n))
                                          (kind (evolutionary-data2 evolution n)))
                                      (highlighted-rect time id kind)))))
                               (else
                                (let ((time (evolutionary-time evolution n))
                                      (value (evolutionary-ref evolution n (- highlighted-column 1))))
                                  (when (eqv? value highlighted-value)
                                    (let ((id (evolutionary-id evolution n))
                                          (kind (evolutionary-data2 evolution n)))
                                      (highlighted-rect time id kind))))))))))))))))
  
  
  (method override (right-mouse-up self evt)
    (zoom-reset self))
  
  
  (method override (view-update self)
    (let ((zone (current-zone)))
      (timeline-view/now-update zone from to #f)))
  
  
  (method override (now-update self)
    (let ((zone (current-zone)))
      (timeline-view/now-update zone from to now))))


;;;
;;;; Evolution
;;;


(class Together-Evolution-Panel extends Evolution-Panel
  
  
  (form
    (<install>
      (<border~>  border-type: solid border-color: {Color Dark-Gray})
      (<entries~> selection-handler: {Event-Handler :form on-selection-change})))
  
  
  (method override (form-model self form)
    (case (get-name form)
      ((header) Together-Evolution-Header)
      ((entries) Together-Evolution-Tree)
      (else (nextmethod self form))))
  
  
  (method protected (collect-entries self column)
    (if (memv? column '(@todo 1 2 3 4))
        (let ((entries (make-table test: eqv?)))
          (define (process value present)
            (unless (table-ref entries value #f)
              (let ((entry (present self value)))
                (table-set! entries value entry))))
          
          (iterate-table evolutions
            (lambda (id evolution)
              (loop (for n from (first-position evolution) to (last-position evolution))
                    (case column
                      ((1) (process (evolutionary-id evolution n) present-event))
                      ((2) (process (evolutionary-id evolution n) present-event))
                      ((3) (process (evolutionary-data1 evolution n) present-origin))
                      ((4) (process (evolutionary-data2 evolution n) present-kind))))))
          (sort ci<? (table-values entries)))
      '()))
  
  
  (method (on-selection-change self evt)
    (let ((zone (current-zone)))
      (let ((selection (get-selection evt)))
        (evolution-selection-update zone selection)))))


(class Together-Evolution-Header extends Tree-Header
  
  
  (method override (close-popups self (event: event #f) (all?: all? #f) (exclude: exclude #f) (initiator: initiator #f))
    (unless (memq? event '(mouse-down double-click))
      (nextmethod self event: event all?: all? exclude: exclude initiator: initiator))))


(class Together-Evolution-Tree extends Evolution-Tree
  
  
  (method override (header-click self column)
    (let ((view (find-popup Filter-View)))
      (close-popups (get-window-manager) (current-window))
      (unless (and view (eq? (get-column view) column))
        (let ((panel (find-ascendant self Together-Evolution-Panel))
              (header (find-ascendant self Tree-Header)))
          (let ((entries (collect-entries panel (get-rank column))))
            (let ((view (make-filter-view self column entries))
                  (rect (header-rect header column)))
              (popup header
                     view
                     (new Point (get-left rect) (+ (get-top rect) 17)))
              (acquire-focus view))))))))


(definition (make-filter-view tree column entries)
  (let ((view (new Filter-View
                size: {Dimension 186 300}
                background: {Color red: .000 green: .000 blue: .000 alpha: .85}
                tree: tree
                column: column)))
    (case (column-sorting tree column)
      ((ascending) (set-checked? (child view 'ascending) #t))
      ((descending) (set-checked? (child view 'descending) #t))
      (else (set-checked? (child view 'unsorted) #t)))
    (let ((scroller (new Scroller-View parent: view name: 'scroller position: {Point 5 120} size: {Dimension 176 144} vscroll?: #t style: 'tool)))
      (let ((content (get-content scroller))
            (v 0)
            (values (column-filtering tree column)))
        (let ((client (new View parent: content)))
          (for-each (lambda (entry)
                      (let ((checked? (or (not values) (member? entry values))))
                        (new Filter-Label parent: client title: entry position: (new Point 5 v) size: {Dimension 163 22} style: 'text background: #f color: {Color White} checked?: checked?))
                      (increase! v 20))
                    entries)
          (set-size client (new Dimension 163 (+ v 2)))
          (set-client scroller client))))
    view))


(class Filter-View extends Layout-View
  
  
  (property tree   initialize #f accessors generate)
  (property column initialize #f accessors generate)
  
  
  (form
    (<install>
      (<Label-View>                    title: "Sort" font: {Font font-name: tahoma point-size: 14 shadow: thin} position: {Point 5 3} color: {Color World-Ochre})
      (<Filter-Label> name: ascending  title: "Ascending" style: text background: #f position: {Point 10 23} color: {Color White} action-handler: {Event-Handler :form on-sort-ascending})
      (<Filter-Label> name: descending title: "Descending" style: text background: #f position: {Point 10 43} color: {Color White} action-handler: {Event-Handler :form on-sort-descending})
      (<Filter-Label> name: unsorted   title: "Unsorted" style: text background: #f position: {Point 10 63} color: {Color White} action-handler: {Event-Handler :form on-unsorted})
      (<Label-View>                    title: "Filter" font: {Font font-name: tahoma point-size: 14 shadow: thin} position: {Point 5 100} color: {Color World-Ochre})
      (<Push-Button>                   title: "All" style: text background: #f position: {Point 115 100} color: {Color red: .861 green: .081 blue: .093} action-handler: {Event-Handler :form on-filter-all})
      (<Push-Button>                   title: "None" style: text background: #f position: {Point 140 100} color: {Color red: .861 green: .081 blue: .093} action-handler: {Event-Handler :form on-filter-none})
      (<Push-Button>                   title: "OK" position: {Point 8 268} size: {Dimension 80 24} default?: #t action-handler: {Event-Handler :form on-ok})
      (<Push-Button>                   title: "Cancel" position: {Point 98 268} size: {Dimension 80 24} action-handler: {Event-Handler :form on-cancel})))
  
  
  (method override (escape-press self evt)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method override (return-press self evt)
    (apply-filter self)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method (sort-column self new-direction)
    (let ((current-direction (column-sorting tree column)))
      (unless (eq? current-direction new-direction)
        (set-sorted-column tree column new-direction)
        (sort-rows tree column new-direction)))
    (ensure-displayed tree))
  
  
  (method (on-sort-ascending self evt)
    (sort-column self 'ascending)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method (on-sort-descending self evt)
    (sort-column self 'descending)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method (on-unsorted self evt)
    (let ((zone (current-zone)))
      (let ((panel (find-ascendant tree Together-Evolution-Panel)))
        (redisplay-evolutions panel)
        (highlight-replay-value zone))
      (close-popups (get-window-manager) (current-window))))
  
  
  (method (on-filter-all self evt)
    (let ((client (get-client (child self 'scroller))))
      (for-each (lambda (label)
                  (set-checked? label #t))
                (get-children client))))
  
  
  (method (on-filter-none self evt)
    (let ((client (get-client (child self 'scroller))))
      (for-each (lambda (label)
                  (set-checked? label #f))
                (get-children client))))
  
  
  (method (apply-filter self)
    (let ((zone (current-zone)))
      (set-highlighted-cells (get-replay zone) '())
      (let ((client (get-client (child self 'scroller))))
        (let ((all (get-children client)))
          (let ((checked (collect-if get-checked? all)))
            (if (= (length checked) (length all))
                (unfilter-column tree column)
              (let ((values (map get-title checked)))
                (filter-column tree column values))))))
      (highlight-replay-value zone)))
  
  
  (method (on-ok self evt)
    (apply-filter self)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method (on-cancel self evt)
    (close-popups (get-window-manager) (current-window))))


(class Filter-Label extends Push-Button
  
  
  (property checked? initialize #f accessors explicit)


  (method public (get-checked? self)
    checked?)
  

  (method public (set-checked? self flag)
    (set! checked? flag)
    (invalidate-view self))
  
  
  (method override (process-action self sender . rest)
    (if action-handler
        (apply nextmethod self sender rest)
      (set-checked? self (not checked?))))
  
  
  (method override (draw self surface context)
    (nextmethod self surface context)
    (when checked?
      (let ((appl (current-application))
            (left 3)
            (top 4))
        (draw-image (get-images-portfolio appl) surface context {Image-Resource "CheckMarkWhite"} left top))))
  
  
  (method override (draw-text-at self surface h v title color enabled?)
    (draw-text surface (+ h 20) v title color enabled?: enabled?))))
