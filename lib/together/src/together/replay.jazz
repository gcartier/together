;;;============
;;;  Together
;;;============
;;;
;;;; Replay Stage
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module together.replay jazz


(import (jazz.application)
        (jazz.clipboard)
        (jazz.component)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.handler)
        (jazz.markup)
        (jazz.outline)
        (jazz.resource)
        (jazz.text)
        (jazz.tree)
        (jazz.ui)
        (jazz.view)
        (jazz.window)
        (world)
        (world.chronology)
        (world.context)
        (world.evolution)
        (world.interface.evolution)
        (world.interface.text)
        (world.interface.timeline)
        (world.manager)
        (world.settings)
        (world.udp)
        (together))


(definition protected evolutions-range
  .25)

(definition protected (set-evolutions-range range)
  (set! evolutions-range range))


(definition package (timeline-view/now-update zone from to now)
  (let ((root (get-root zone))
        (replay (get-replay zone)))
    (let ((evolution-from (and now (- now evolutions-range)))
          (evolution-to (and now (+ now evolutions-range))))
      (let ((panel (child root 'evolution)))
        (let ((names (get-names replay))
              (evolutions (get-evolutions replay))
              (base-time (get-base-time replay)))
          (set-from replay from)
          (set-to replay to)
          (set-now replay now)
          (set-highlighted-cells replay '())
          (when now
            (receive (displayed total) (view-evolutions-at panel evolution-from evolution-to now)
              (let ((panel (child root 'timeline)))
                (set-evolution-range panel (format "{a} of {a}" displayed total))
                (set-evolution-from panel evolution-from)
                (set-evolution-to panel evolution-to)
                (invalidate-view panel))))
          (highlight-replay-value zone)
          (set-setting options-settings 'world.last-replay (list (get-name (get-directory replay)) from to now))
          (save-content options-settings))))))


(definition package (highlight-replay-value zone)
  (let ((root (get-root zone))
        (replay (get-replay zone)))
    (let ((value (get-highlighted-value replay))
          (col (get-highlighted-column replay)))
      (when value
        (let ((panel (child root 'evolution)))
          (let ((origin (get-highlighted-origin replay))
                (kind (get-highlighted-kind replay))
                (tree (locate panel 'entries)))
            (highlight-value zone tree origin kind value col)
            (invalidate-view tree)))))))


(definition package (evolution-selection-update zone selection)
  (let ((root (get-root zone))
        (replay (get-replay zone)))
    (when (not-null? selection)
      (let ((panel (child root 'evolution)))
        (let ((tree (locate panel 'entries)))
          ;; unhighlight
          (for-each (lambda (cell)
                      (let ((data (get-cell-data tree cell)))
                        (set-frame-color data #f)))
                    (get-highlighted-cells replay))
          (set-highlighted-value replay #f)
          (set-highlighted-cells replay '())
          ;; highlight
          (let ((cell (car selection)))
            (let ((line (get-line cell))
                  (col (get-col cell)))
              (let ((row (get-row tree line)))
                (let ((user-data (get-user-data row))
                      (sequence? (= col 5)))
                  (let ((origin (and sequence? (vector-ref user-data (- col 2))))
                        (kind (and sequence? (vector-ref user-data (- col 1))))
                        (value (vector-ref user-data col)))
                    (highlight-value zone tree origin kind value col))))))
          ;; invalidate
          (invalidate-view tree))))
    ;; timeline highlighted
    (let ((timeline (child root 'timeline))
          (panel (child root 'evolution)))
      (let ((tree (locate panel 'entries)))
        (let ((selection (get-selection tree)))
          (if (null? selection)
              (set-highlighted-value timeline #f)
            (let ((cell (car selection)))
              (let ((line (get-line cell))
                    (col (get-col cell)))
                (cond ;; time
                      ((= col 0)
                       (let ((row (get-row tree line)))
                         (let ((user-data (get-user-data row)))
                           (let ((value (vector-ref user-data col)))
                             (set-highlighted-value timeline value)
                             (set-highlighted-column timeline 1)))))
                      ;; tier
                      ((= col 1)
                       (let ((row (get-row tree line)))
                         (let ((user-data (get-user-data row)))
                           (let ((value (vector-ref user-data col)))
                             ;; the -1 is a quick hack for server's #f
                             (set-highlighted-value timeline (or value -1))
                             (set-highlighted-column timeline 0)))))
                      ;; sequence
                      ((= col 5)
                       (let ((row (get-row tree line)))
                         (let ((user-data (get-user-data row)))
                           (let ((origin (vector-ref user-data (- col 2)))
                                 (kind (vector-ref user-data (- col 1)))
                                 (value (vector-ref user-data col)))
                             (set-highlighted-origin timeline origin)
                             (set-highlighted-kind timeline kind)
                             (set-highlighted-value timeline value)
                             (set-highlighted-column timeline col)))))
                      ;; value
                      (else
                       (let ((row (get-row tree line)))
                         (let ((user-data (get-user-data row)))
                           (let ((value (vector-ref user-data col)))
                             (set-highlighted-value timeline value)
                             (set-highlighted-column timeline col)))))))))
          (invalidate-view timeline))))))


(definition package (highlight-value zone tree origin kind value col)
  (let ((replay (get-replay zone)))
    (set-highlighted-origin replay origin)
    (set-highlighted-kind replay kind)
    (set-highlighted-value replay value)
    (set-highlighted-column replay col)
    (for-each-visible-row tree
      (lambda (row line)
        (let ((user-data (get-user-data row))
              (sequence? (= col 5)))
          (let ((data-origin (and sequence? (vector-ref user-data (- col 2))))
                (data-kind (and sequence? (vector-ref user-data (- col 1))))
                (data-value (vector-ref user-data col)))
            (when (and (eqv? data-value value)
                       (or (not origin) (eqv? data-origin origin))
                       (or (not kind) (eqv? data-kind kind)))
              (let ((data (get-child row col)))
                (set-frame-color data {Color Red})
                (set-highlighted-cells replay (cons (new Cell line col) (get-highlighted-cells replay)))))))))))


;;;
;;;; Replay
;;;


(class Replay extends Object
  
  
  (slot directory    getter generate)
  (slot tier         getter generate)
  (slot names        getter generate)
  (slot metadatas    getter generate)
  (slot chronologies getter generate)
  (slot evolutions   getter generate)
  (slot base-time    getter generate)
  (slot head         getter generate)
  (slot tail         getter generate)
  
  (slot from               initialize #f  accessors generate)
  (slot to                 initialize #f  accessors generate)
  (slot now                initialize #f  accessors generate)
  (slot highlighted-origin initialize #f  accessors generate)
  (slot highlighted-kind   initialize #f  accessors generate)
  (slot highlighted-value  initialize #f  accessors generate)
  (slot highlighted-column initialize #f  accessors generate)
  (slot highlighted-cells  initialize '() accessors generate)
  
  
  (method override (initialize self directory tier names metadatas chronologies evolutions base-time)
    (define (determine-head)
      (apply min (map (lambda (evolution)
                        (evolutionary-udp-time evolution (first-position evolution)))
                      (table-values evolutions))))
    
    (define (determine-tail)
      (apply max (map (lambda (evolution)
                        (evolutionary-udp-time evolution (last-position evolution)))
                      (table-values evolutions))))
    
    (nextmethod self)
    (set! self.directory directory)
    (set! self.tier tier)
    (set! self.names names)
    (set! self.metadatas metadatas)
    (set! self.chronologies chronologies)
    (set! self.evolutions evolutions)
    (set! self.base-time base-time)
    (set! self.head (determine-head))
    (set! self.tail (determine-tail))))


;;;
;;;; Timeline
;;;


(class Together-Timeline-Panel extends Timeline-Panel
  
  
  (slot evolutions          initialize '() accessors generate)
  (slot highlighted-title   initialize #f  accessors generate)
  (slot highlighted-markers initialize #f  accessors generate)
  (slot highlighted-origin  initialize #f  accessors generate)
  (slot highlighted-kind    initialize #f  accessors generate)
  (slot highlighted-value   initialize #f  accessors generate)
  (slot highlighted-column  initialize #f  accessors generate)
  
  
  (method override (mouse-up self evt)
    (let ((h (get-h evt))
          (v (get-v evt)))
      (define (in-tier?)
        (and (< v 25)
             (between? h 0 75)))
      
      (define (in-range?)
        (and (< v 25)
             (between? h 160 310)))
      
      (cond ((in-tier?)
             ;; really quick code that needs cleanup
             (let ((replay (get-replay (current-zone))))
               (let ((names (map (lambda (name) (or name "<server>")) (table-values (get-names replay)))))
                 (let ((tiers (sort nu<? names)))
                   (let ((new-tier (if (get-shift? evt)
                                       (previous-element tiers tier)
                                     (next-element tiers tier))))
                     (set! tier new-tier)
                     (let ((tier (if (equal? tier "<server>") #f tier)))
                       (let ((id (table-find (get-names replay) tier)))
                         (let (;; quick preserve for copy/paste below
                               (now now)
                               (from from)
                               (to to)
                               (chronology (table-ref (get-chronologies replay) id))
                               (evolution (table-ref (get-evolutions replay) id)))
                           (set! cpu% (chronology-cpu% chronology))
                           (set-chronology self chronology)
                           (set-evolution self evolution)
                           (setup-replay self base-time)
                           ;; quick copy/paste from view-replay
                           (when (and from to)
                             (set-bounds self from to)
                             (update-span self))
                           (when now
                             (set-now self now))
                           (set-from replay from)
                           (set-to replay to)
                           (set-now replay now))))
                     (invalidate-view self))))))
            ((in-range?)
             (let ((world (current-world))
                   (zone (current-zone)))
               (let ((values '(.25 1. 3.)))
                 (let ((range (if (get-shift? evt)
                                  (previous-element values evolutions-range)
                                (next-element values evolutions-range))))
                   (set-evolutions-range range)
                   (let ((max (cond ((= evolutions-range .25) 30)
                                    ((= evolutions-range 1.) 100)
                                    (else 300))))
                     (set-evolutions-max max)
                     (timeline-view/now-update zone from to now))))))
            (else
             (nextmethod self evt)))))
  
  
  (method override (border-color self)
    {Color Dark-Gray})
  
  
  (method override (plot-evolutions self surface <Surface> from <fl> to <fl>)
    (let ((width (cast <fl> (get-width self)))
          (now-h (and now (when->h self from to span now))))
      (cond (highlighted-markers
             (let ((first (first-position chronology))
                   (last (last-position chronology)))
               (define (find-head)
                 (loop (for n from first to last)
                       (when (>= (chronological-time chronology n) from)
                         (return n))
                       (finally first)))
               
               (define (find-tail head)
                 (loop (for n from head to last)
                       (when (> (chronological-time chronology n) to)
                         (return (- n 1)))
                       (finally last)))
               
               (let ((head (find-head)))
                 (let ((tail (find-tail head)))
                   (draw-text surface 320 3 (->string highlighted-title) timeline-text-color)
                   (for-each (lambda (n)
                               (when (and (>= n head)
                                          (<= n tail))
                                 (let ((time (chronological-time chronology n))
                                       (marker (chronological-marker chronology n)))
                                   (let ((h (fxround (* (/ (- time from) span) width))))
                                     (let ((color (if (even? marker) {Color Purple} {Color Red}))
                                           (v 120))
                                       (fill-rect surface (new Rect (- h 0) (- v 4) (+ h 1) (+ v 5)) color))))))
                             highlighted-markers)))))
            (highlighted-value
             (draw-text surface 320 3 (format "Highlight: {a}" highlighted-value) timeline-text-color)
             (iterate-table evolutions
               (lambda (evolution-id evolution)
                 (let ((first (first-position evolution))
                       (last (last-position evolution)))
                   (define (find-head)
                     (loop (for n from first to last)
                           (when (>= (evolutionary-udp-time evolution n) from)
                             (return n))
                           (finally first)))
                   
                   (define (find-tail head)
                     (loop (for n from head to last)
                           (when (> (evolutionary-udp-time evolution n) to)
                             (return (- n 1)))
                           (finally last)))
                   
                   (let ((head (find-head)))
                     (let ((tail (find-tail head)))
                       (define (highlighted-rect time id kind)
                         (let ((h (fxround (* (/ (- time from) span) width))))
                           (let ((color (ecase id
                                          ((udp-id-create-packet) {Color Yellow})
                                          ((udp-id-nack-packet) {Color Blue})
                                          ((udp-id-add-process) {Color Blue})
                                          ((udp-id-remove-process) {Color Green})
                                          ((udp-id-late-packet udp-id-duplicate-packet) {Color Orange})
                                          ((udp-id-retain-packet) {Color Dark-Gray})
                                          ((udp-id-release-packet) {Color Dark-Gray})
                                          (else {Color Red})))
                                 (left (- h 2))
                                 (right (+ h 3))
                                 (v (if (= kind udp-audio) 117 124)))
                             (let ((rect (new Rect left (- v 2) right (+ v 3))))
                               (fill-rect surface rect color)
                               (when (and now (between? now-h left right))
                                 (unless (memv? id highlighted)
                                   (set! highlighted (cons id highlighted))))))))
                       
                       (loop (for n from head to tail)
                             (case highlighted-column
                               ;; tier
                               ((0)
                                (let ((time (evolutionary-udp-time evolution n))
                                      (id (evolutionary-udp-id evolution n))
                                      (kind (evolutionary-udp-kind evolution n)))
                                  ;; the -1 is a quick hack for server's #f
                                  (when (= (or evolution-id -1) highlighted-value)
                                    (highlighted-rect time id kind))))
                               ;; sequence
                               ((5)
                                (let ((time (evolutionary-udp-time evolution n))
                                      (origin (evolutionary-udp-origin evolution n))
                                      (kind (evolutionary-udp-kind evolution n))
                                      (value (evolutionary-udp-data1 evolution n)))
                                  (when (and (eqv? origin highlighted-origin)
                                             (eqv? kind highlighted-kind)
                                             (eqv? value highlighted-value))
                                    (let ((id (evolutionary-udp-id evolution n))
                                          (kind (evolutionary-udp-kind evolution n)))
                                      (highlighted-rect time id kind)))))
                               ;; value
                               (else
                                (let ((time (evolutionary-udp-time evolution n))
                                      (value (evolutionary-ref evolution n (- highlighted-column 1))))
                                  (when (eqv? value highlighted-value)
                                    (let ((id (evolutionary-udp-id evolution n))
                                          (kind (evolutionary-udp-kind evolution n)))
                                      (highlighted-rect time id kind))))))))))))))))
  
  
  (method override (right-mouse-up self evt)
    (zoom-reset self))
  
  
  (method override (view-update self)
    (let ((zone (current-zone)))
      (timeline-view/now-update zone from to #f)))
  
  
  (method override (now-update self)
    (let ((zone (current-zone)))
      (timeline-view/now-update zone from to now))))


;;;
;;;; Evolution
;;;


(class Together-Evolution-Panel extends Evolution-Panel
  
  
  (form
    (<install>
      (<border~>  border-type: solid border-color: {Color Dark-Gray})
      (<entries~> selection-handler: {Event-Handler :form on-selection-change})))
  
  
  (method override (form-model self form)
    (case (get-name form)
      ((header) Together-Evolution-Header)
      ((entries) Together-Evolution-Tree)
      (else (nextmethod self form))))
  
  
  (method protected (collect-entries self column)
    (if (= column 1)
        (let ((values (table-values names)))
          (if (memv? #f values)
              (append (sort ci<? (remove-false values)) (list "<server>"))
            values))
      (let ((entries (make-table test: eqv?)))
        (define (process value present)
          (unless (table-ref entries value #f)
            (let ((entry (present self value)))
              (table-set! entries value entry))))
        
        (iterate-table evolutions
          (lambda (id evolution)
            (loop (for n from (first-position evolution) to (last-position evolution))
                  (case column
                    ((2) (process (evolutionary-udp-id evolution n) present-event))
                    ((3) (process (evolutionary-udp-origin evolution n) present-origin))
                    ((4) (process (evolutionary-udp-kind evolution n) present-kind))))))
        (sort ci<? (remove-empty (table-values entries))))))
  
  
  (method (on-selection-change self evt)
    (let ((zone (current-zone)))
      (let ((selection (get-selection evt)))
        (evolution-selection-update zone selection)))))


(class Together-Evolution-Header extends Tree-Header
  
  
  (method override (close-popups self (event: event #f) (all?: all? #f) (exclude: exclude #f) (initiator: initiator #f))
    (unless (memq? event '(mouse-down double-click))
      (nextmethod self event: event all?: all? exclude: exclude initiator: initiator))))


(class Together-Evolution-Tree extends Evolution-Tree
  
  
  (method override (can-copy? self)
    #t)
  
  
  (method override (copy-selection self)
    (let ((selection (get-selection self)))
      (if (null? selection)
          (bell)
        (set-clipboard-text (get-cell-title self (car selection)))
        (add-clipboard (current-application)))))
  
  
  (method override (header-click self column)
    (let ((view (find-popup Filter-View))
          (rank (get-rank column)))
      (close-popups (get-window-manager) (current-window))
      (unless (and view (eq? (get-column view) column))
        (let ((panel (find-ascendant self Together-Evolution-Panel))
              (header (find-ascendant self Tree-Header))
              (enumerated? (between? rank 1 4)))
          (let ((entries (and enumerated? (collect-entries panel (get-rank column)))))
            (let ((view (make-filter-view self column enumerated? entries))
                  (rect (header-rect header column)))
              (popup header
                     view
                     (new Point
                       (if enumerated?
                           (get-left rect)
                         (- (get-right rect) 15))
                       (+ (get-top rect) 17)))
              (if enumerated?
                  (acquire-focus view)
                (let ((client (get-client (child view '(border scroller)))))
                  (select-all client)
                  (acquire-focus client))))))))))


(definition (make-filter-view tree column enumerated? entries)
  (let ((view (new Filter-View
                size: {Dimension 186 300}
                background: {Color red: .000 green: .000 blue: .000 alpha: .85}
                tree: tree
                column: column
                enumerated?: enumerated?)))
    (case (column-sorting tree column)
      ((ascending) (set-checked? (child view 'ascending) #t))
      ((descending) (set-checked? (child view 'descending) #t))
      (else (set-checked? (child view 'unsorted) #t)))
    (if enumerated?
        (let ((scroller (new Scroller-View parent: view name: 'scroller position: {Point 5 120} size: {Dimension 176 144} vscroll?: #t style: 'tool)))
          (let ((content (get-content scroller)))
            (let ((v 0)
                  (values (column-filtering tree column)))
              (let ((client (new View parent: content)))
                (for-each (lambda (entry)
                            (let ((checked? (or (not values) (member? entry values))))
                              (new Filter-Label parent: client title: entry position: (new Point 5 v) size: {Dimension 163 22} style: 'text background: #f color: {Color White} checked?: checked?))
                            (increase! v 20))
                          entries)
                (set-size client (new Dimension 163 (+ v 2)))
                (set-client scroller client)))))
      (let ((border (new Border-View parent: view name: 'border position: {Point 5 120} size: {Dimension 176 144} border-type: 'solid border-color: {Color Dark-Gray})))
        (let ((scroller (new Scroller-View parent: border name: 'scroller vscroll?: #t style: 'tool)))
          (let ((content (get-content scroller)))
            (let ((client (new Filter-Text parent: content background: 'none))
                  (values (column-filtering tree column)))
              (if (not values)
                  (set-string-content client "*\n")
                (unless (null? values)
                  (set-string-content client (substitute-alist '((#\( . "[") (#\) . "]")) (string-append (join (map ->string values) "\n") "\n")))))
              (set-client scroller client))))))
    view))


(class Filter-View extends Layout-View
  
  
  (property tree        initialize #f accessors generate)
  (property column      initialize #f accessors generate)
  (property enumerated? initialize #f accessors generate)
  
  
  (form
    (<install>
      (<Label-View>                    title: "Sort" font: {Font font-name: tahoma point-size: 14 shadow: thin} position: {Point 5 3} color: {Color World-Ochre})
      (<Filter-Label> name: ascending  title: "Ascending" style: text background: #f position: {Point 10 23} color: {Color White} action-handler: {Event-Handler :form on-sort-ascending})
      (<Filter-Label> name: descending title: "Descending" style: text background: #f position: {Point 10 43} color: {Color White} action-handler: {Event-Handler :form on-sort-descending})
      (<Filter-Label> name: unsorted   title: "Unsorted" style: text background: #f position: {Point 10 63} color: {Color White} action-handler: {Event-Handler :form on-unsorted})
      (<Label-View>                    title: "Filter" font: {Font font-name: tahoma point-size: 14 shadow: thin} position: {Point 5 100} color: {Color World-Ochre})
      (<Push-Button>                   title: "All" style: text background: #f position: {Point 115 100} color: {Color red: .861 green: .081 blue: .093} action-handler: {Event-Handler :form on-filter-all})
      (<Push-Button>                   title: "None" style: text background: #f position: {Point 140 100} color: {Color red: .861 green: .081 blue: .093} action-handler: {Event-Handler :form on-filter-none})
      (<Push-Button>                   title: "OK" position: {Point 8 268} size: {Dimension 80 24} default?: #t action-handler: {Event-Handler :form on-ok})
      (<Push-Button>                   title: "Cancel" position: {Point 98 268} size: {Dimension 80 24} action-handler: {Event-Handler :form on-cancel})))
  
  
  (method override (escape-press self evt)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method override (return-press self evt)
    (apply-filter self)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method (sort-column self new-direction)
    (let ((current-direction (column-sorting tree column)))
      (unless (eq? current-direction new-direction)
        (set-sorted-column tree column new-direction)
        (sort-rows tree column new-direction)))
    (ensure-displayed tree))
  
  
  (method (on-sort-ascending self evt)
    (sort-column self 'ascending)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method (on-sort-descending self evt)
    (sort-column self 'descending)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method (on-unsorted self evt)
    (let ((zone (current-zone)))
      (let ((panel (find-ascendant tree Together-Evolution-Panel)))
        (redisplay-evolutions panel)
        (highlight-replay-value zone))
      (close-popups (get-window-manager) (current-window))))
  
  
  (method (on-filter-all self evt)
    (if enumerated?
        (let ((client (get-client (child self 'scroller))))
          (for-each (lambda (label)
                      (set-checked? label #t))
                    (get-children client)))
      (let ((client (get-client (child self '(border scroller)))))
        (set-string-content client "*\n")
        (select-all client))))
  
  
  (method (on-filter-none self evt)
    (if enumerated?
        (let ((client (get-client (child self 'scroller))))
          (for-each (lambda (label)
                      (set-checked? label #f))
                    (get-children client)))
      (let ((client (get-client (child self '(border scroller)))))
        (set-string-content client "")
        (select-all client))))
  
  
  (method protected (apply-filter self)
    (let ((zone (current-zone)))
      (set-highlighted-cells (get-replay zone) '())
      (if enumerated?
          (let ((client (get-client (child self 'scroller))))
            (let ((all (get-children client)))
              (let ((checked (collect-if get-checked? all)))
                (if (= (length checked) (length all))
                    (unfilter-column tree column)
                  (let ((values (map get-title checked)))
                    (filter-column tree column values type: 'text))))))
        (let ((client (get-client (child self '(border scroller)))))
          (let ((content (get-string-content client)))
            (if (equal? (trim-whitespace content) "*")
                (unfilter-column tree column)
              (let ((values (read-string-content content)))
                (filter-column tree column values type: 'number))))))
      (highlight-replay-value zone)))
  
  
  (method (on-ok self evt)
    (apply-filter self)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method (on-cancel self evt)
    (close-popups (get-window-manager) (current-window))))


(class Filter-Label extends Push-Button
  
  
  (property checked? initialize #f accessors explicit)


  (method public (get-checked? self)
    checked?)
  

  (method public (set-checked? self flag)
    (set! checked? flag)
    (invalidate-view self))
  
  
  (method override (process-action self sender . rest)
    (if action-handler
        (apply nextmethod self sender rest)
      (set-checked? self (not checked?))))
  
  
  (method override (draw self surface context)
    (nextmethod self surface context)
    (when checked?
      (let ((appl (current-application))
            (left 3)
            (top 4))
        (draw-image (get-images-portfolio appl) surface context {Image-Resource "CheckMarkWhite"} left top))))
  
  
  (method override (draw-text-at self surface h v title color enabled?)
    (draw-text surface (+ h 20) v title color enabled?: enabled?)))


(class Filter-Text extends World-Text-View
  
  
  (method override (new-model self)
    (new Text-Model base-style: {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin}} left-padding: 2))
  
  
  (method override (escape-press self evt)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method override (return-press self evt)
    (let ((end (get-end self)))
      (if (and (cell=? end (text-ending self))
               (= (get-col end) 0))
          (begin
            (apply-filter (find-ascendant self Filter-View))
            (close-popups (get-window-manager) (current-window)))
        (nextmethod self evt))))))
