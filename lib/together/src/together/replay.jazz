;;;============
;;;  Together
;;;============
;;;
;;;; Replay Stage
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module together.replay jazz


(import (jazz.application)
        (jazz.clipboard)
        (jazz.component)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.handler)
        (jazz.markup)
        (jazz.outline)
        (jazz.platform)
        (jazz.resource)
        (jazz.stream)
        (jazz.text)
        (jazz.tree)
        (jazz.ui)
        (jazz.view)
        (jazz.window)
        (gaea.geometry)
        (gaea.math)
        (world)
        (world.chronology)
        (world.circle)
        (world.client.udp)
        (world.context)
        (world.event)
        (world.evolution)
        (world.interface.evolution)
        (world.interface.panel)
        (world.interface.replay)
        (world.interface.text)
        (world.interface.timeline)
        (world.manager)
        (world.settings)
        (world.task)
        (world.time)
        (world.timeline)
        (world.udp)
        (world.video)
        (together)
        (together.emulation)
        (together.visualizer))


(definition package (timeline-view/now-update root from to now (update-evolution? #t) (playing? #f))
  (let ((replay (get-replay root)))
    (let ((panel (child root 'evolution)))
      (let ((names (get-names replay))
            (evolutions (get-evolutions replay))
            (base-time (get-base-time replay)))
        (set-from replay from)
        (set-to replay to)
        (when now
          (set-now replay now))
        (set-highlighted-cells replay '())
        (when now
          (let ((visualizer (child root 'visualizer)))
            (visualize-time visualizer now playing?))
          ;; quicky invalidate draw-audio section
          (let ((width (get-width root))
                (height (get-height root)))
            (let ((h (- width 270)))
              (invalidate-rect root (new Rect h 0 width (- height 40))))))
        (when update-evolution?
          (when now
            (display-evolutions root now))
          (highlight-replay-value root)
          (let ((dir (get-directory replay)))
            (when dir
              (set-setting options-settings 'world.last-replay (list (get-name dir) from to (or now (get-now replay))))
              (save-content options-settings))))))))


(definition package (display-evolutions root (now #f))
  (let ((replay (get-replay root)))
    (let ((evolution-panel (child root 'evolution))
          (timeline-panel (child root 'timeline))
          (now (or now (get-now replay))))
      (if (not now)
          (begin
            (clear-evolutions evolution-panel)
            (set-evolution-range timeline-panel #f)
            (set-evolution-left timeline-panel #f)
            (set-evolution-right timeline-panel #f))
        (receive (displayed total left right) (view-evolutions-at evolution-panel now)
          (set-evolution-range timeline-panel (format "{a} of {a}" displayed total))
          (set-evolution-left timeline-panel left)
          (set-evolution-right timeline-panel right)))
      (invalidate-view timeline-panel))))


(definition package (highlight-replay-value root)
  (let ((replay (get-replay root)))
    (let ((value (get-highlighted-value replay))
          (col (get-highlighted-column replay)))
      (when value
        (let ((panel (child root 'evolution)))
          (let ((origin (get-highlighted-origin replay))
                (kind (get-highlighted-kind replay))
                (tree (locate panel 'entries)))
            (highlight-value root tree origin kind value col)
            (invalidate-view tree)))))))


(definition package (evolution-selection-update root selection)
  (let ((replay (get-replay root)))
    (when (not-null? selection)
      (let ((panel (child root 'evolution)))
        (let ((tree (locate panel 'entries)))
          ;; elapses
          (let ((timeline (child root 'timeline)))
            (set-elapses timeline
              (and (> (length selection) 1)
                   (uniform selection key: get-col)
                   (let ((values (map (lambda (cell)
                                        (string->number (get-cell-title tree cell)))
                                      (sort nu<? selection))))
                     (and (not (memv? #f values))
                          (loop (for before in values remainder after)
                                (unless (null? after)
                                  (collect
                                    (let ((elapse (- (car after) before)))
                                      (format "{r precision: 6}" elapse))))))))))
          ;; unhighlight
          (for-each (lambda (cell)
                      (let ((data (get-cell-data tree cell)))
                        (set-frame-color data #f)))
                    (get-highlighted-cells replay))
          (set-highlighted-value replay #f)
          (set-highlighted-cells replay '())
          ;; highlight
          (let ((cell (car selection)))
            (let ((line (get-line cell))
                  (col (get-col cell)))
              (let ((row (get-row tree line)))
                (let ((user-data (get-user-data row))
                      (sequence? (= col 5)))
                  (let ((origin (and sequence? (vector-ref user-data (- col 2))))
                        (kind (and sequence? (vector-ref user-data (- col 1))))
                        (value (vector-ref user-data col)))
                    (highlight-value root tree origin kind value col))))))
          ;; invalidate
          (invalidate-view tree))))))


(definition package (evolution-double-click root selection)
  (let ((timeline (child root 'timeline))
        (panel (child root 'evolution)))
    (let ((tree (locate panel 'entries)))
      (let ((selection (get-selection tree)))
        (if (null? selection)
            (set-highlighted-values timeline '())
          (let ((highlighted
                  (let ((cell (car selection)))
                    (let ((line (get-line cell))
                          (col (get-col cell)))
                      (cond ;; time
                            ((= col 0)
                             (let ((row (get-row tree line)))
                               (let ((user-data (get-user-data row)))
                                 (let ((value (vector-ref user-data col)))
                                   (list 0 value)))))
                            ;; tier
                            ((= col 1)
                             (let ((row (get-row tree line)))
                               (let ((user-data (get-user-data row)))
                                 (let ((value (vector-ref user-data col)))
                                   ;; the -1 is a quick hack for server's #f
                                   (list 1 (or value -1))))))
                            ;; sequence
                            ((= col 5)
                             (let ((row (get-row tree line)))
                               (let ((user-data (get-user-data row)))
                                 (let ((origin (vector-ref user-data (- col 2)))
                                       (kind (vector-ref user-data (- col 1)))
                                       (value (vector-ref user-data col)))
                                   (list col value origin kind)))))
                            ;; value
                            (else
                             (let ((row (get-row tree line)))
                               (let ((user-data (get-user-data row)))
                                 (let ((value (vector-ref user-data col)))
                                   (list col value))))))))))
            (let ((highlighted-values (get-highlighted-values timeline)))
              (if (member? highlighted highlighted-values)
                  (set-highlighted-values timeline (remove highlighted highlighted-values test: equal?))
                (set-highlighted-values timeline (cons highlighted highlighted-values))))))
        (redraw timeline)
        (invalidate-view panel)))))


(definition package (highlight-value root tree origin kind value col)
  (let ((replay (get-replay root)))
    (set-highlighted-origin replay origin)
    (set-highlighted-kind replay kind)
    (set-highlighted-value replay value)
    (set-highlighted-column replay col)
    (for-each-visible-row tree
      (lambda (row line)
        (let ((user-data (get-user-data row))
              (sequence? (= col 5)))
          (let ((data-origin (and sequence? (vector-ref user-data (- col 2))))
                (data-kind (and sequence? (vector-ref user-data (- col 1))))
                (data-value (vector-ref user-data col)))
            (when (and (eqv? data-value value)
                       (or (not origin) (eqv? data-origin origin))
                       (or (not kind) (eqv? data-kind kind)))
              (let ((data (get-child row col)))
                (set-frame-color data {Color Red})
                (set-highlighted-cells replay (cons (new Cell line col) (get-highlighted-cells replay)))))))))))


;;;
;;;; Replay
;;;


(class Replay extends Timeline
  
  
  (slot from               initialize #f  accessors generate)
  (slot to                 initialize #f  accessors generate)
  (slot now                initialize #f  accessors generate)
  (slot highlighted-origin initialize #f  accessors generate)
  (slot highlighted-kind   initialize #f  accessors generate)
  (slot highlighted-value  initialize #f  accessors generate)
  (slot highlighted-column initialize #f  accessors generate)
  (slot highlighted-cells  initialize '() accessors generate))


(definition public (open-replay dir)
  (let ((client (current-client)))
    (receive (names metadatas chronologies evolutions channels audios videos moments) (collect-replays dir)
      (define (determine-tier character-name)
        (or (table-find names character-name test: equal?)
            (car (table-keys names))))
      
      (define (determine-base-time)
        (metadata-base-time (table-ref metadatas server-no)))
      
      (let ((character-name (get-character-name client)))
        (let ((tier (determine-tier character-name)))
          (let ((base-time (determine-base-time))
                (title (get-name dir)))
            (new Replay title dir tier names metadatas chronologies evolutions channels audios videos moments base-time)))))))


;;;
;;;; Replay
;;;


(class Together-Replay-Panel extends Replay-Panel implements Circleable
  
  
  (property replay     initialize #f accessors generate)
  (property output     initialize #f accessors generate)
  (property in-circle? initialize #f accessors generate)
  
  
  (method override (update self out)
    (set! output out)
    (set-output (get-player self) out))
  
  
  (method override (size-change self size)
    (nextmethod self size)
    (update-visualizer self))
  
  
  (method protected (update-visualizer self)
    (let ((visualizer (find-component self 'visualizer)))
      (when visualizer
        (let ((video-visualizer (locate-component visualizer 'video)))
          (when video-visualizer
            (update-video-output video-visualizer))))))
  
  
  (method override (draw self surface context)
    (define (fill-border left top right)
      (fill-rect surface (new Rect left top right 700) {Color Dark-Blue alpha: .5}))
    
    (when in-circle?
      (fill-border 0 20 64)
      (fill-border 1216 84 1280)
      (fill-gradient surface (new Rect 1216 84 1280 20)
       (new Gradient 'vertical
            {Color Dark-Red alpha: .5}
            {Color Dark-Blue alpha: .5}))))
  
  
  (method override (draw-children self surface nodes context)
    (nextmethod self surface nodes context)
    (when checkerboard-interface?
      (draw-checkerboard-interface surface)))
  
  
  (method (in-close? self evt)
    (let ((pos (get-position evt)))
      (in-rect? pos {Rect 1216 0 1280 64})))
  
  
  (method override (mouse-down self evt)
    (unless (in-close? self evt)
      (when (memq? video-layout '(circle focus))
        (circle-switch-focus output #t))))
  
  
  (method override (mouse-up self evt)
    (let ((udp (current-udp)))
      (when (in-close? self evt)
        (let ((stream (get-stream (get-channel output))))
          (close-send-stream udp stream)))))
  
  
  (method override (double-click self evt)
    (when (memq? video-layout '(circle focus))
      (circle-switch-focus output #f)
      (change-focused-output (current-video) output))))


;;;
;;;; Timeline
;;;


(definition protected events-lexicon-time
  #f)

(definition protected (set-events-lexicon-time time)
  (set! events-lexicon-time time))


(class Evolution-Timeline-Panel extends Timeline-Panel
  
  
  (method override (live-information self)
    (set! history #f)
    (set! chronology (current-chronology))
    (set! evolution (current-evolution)))
  
  
  (method override (copy-information self)
    (set! history #f)
    (set! chronology (copy-chronology (current-chronology)))
    (set! evolution (copy-evolution (current-evolution))))
  
  
  (method override (timeline-start self)
    (if (and live? events-lexicon-time)
        (- events-lexicon-time .305)
      (nextmethod self)))
  
  
  (method override (timeline-end self) <fl>
    (if (and live? events-lexicon-time)
        (+ events-lexicon-time .01)
      (nextmethod self)))
  
  
  (method override (plot-evolution self surface <Surface> from <fl> to <fl>)
    (if events-lexicon-time
        (plot-lexicon self surface)
      (nextmethod self surface from to)))
  
  
  (method override (plot-events self surface from to)
    (let ((foot 220)
          (all? (eq? events-mode 'all)))
      (define (plot evolution offset scale)
        (let ((start (timeline-start self))
              (end (timeline-end self)))
          (define (find-first) <fx+>
            (loop (for n from (first-position evolution) to (last-position evolution))
                  (when (>= (evolutionary-udp-time evolution n) start)
                    (return n))
                  (finally #f)))
          
          (define (find-last first <fx>) <fx>
            (loop (for n from first to (last-position evolution))
                  (when (> (evolutionary-udp-time evolution n) end)
                    (return (- n 1)))
                  (finally (last-position evolution))))
          
          (let ((width (cast <fl> (get-width self)))
                (height (cast <fl> (get-height self)))
                (span (min (- to from) span))
                (now-h (and now (when->h self from to span now)))
                (first (find-first)))
            (when first
              (let ((last (find-last first)))
                (define (find-head) <fx>
                  (loop (for n from first to last)
                        (when (>= (evolutionary-udp-time evolution n) from)
                          (return n))
                        (finally first)))
                
                (define (find-tail head <fx>) <fx>
                  (loop (for n from head to last)
                        (when (> (evolutionary-udp-time evolution n) to)
                          (return (- n 1)))
                        (finally last)))
                
                (let ((head (find-head)))
                  (let ((tail (find-tail head)))
                    (loop (for layer from 3 downto 0)
                          (loop (for n from head to tail)
                                (let ((time (evolutionary-udp-time evolution n))
                                      (id (evolutionary-udp-id evolution n)))
                                  (let ((look (id->event-look (flonum->fixnum id))))
                                    (when look
                                      (let ((rank (get-rank look))
                                            (color (get-color look)))
                                        (when (= rank layer)
                                          (let ((h (fxround (* (/ (- time from) span) width)))
                                                (top (- (- foot (fxround (* scale (cast <fl> (+ rank 1))))) offset))
                                                (bottom (- foot offset)))
                                            (let ((rect (new Rect h top (+ h 1) bottom)))
                                              (fill-rect surface rect color)
                                              (let ((tolerance (/ span 400.)))
                                                (when (and now (between? now (- time tolerance) (+ time tolerance)))
                                                  (set! boxes (cons rect boxes))
                                                  (let ((name (evolution-id->abbrev id)))
                                                    (let ((text (format "{a}" name)))
                                                      (let ((label (if all?
                                                                       (list (if (odd? rank) 'right 'left) (- top 5) text)
                                                                     (list 'right (+ top 3) text))))
                                                        (set! labels (cons label labels)))))))))))))))))))))))
      
      (unless live?
        (set-font surface {Font Label})
        (let ((title (capitalize (->string events-mode))))
          (draw-text surface 5 117 title timeline-text-color)))
      (if live?
          (plot evolution 0 24.)
        (let ((visualizer (brother self 'visualizer)))
          (let ((origin (get-origin-evolution visualizer))
                (server (get-server-evolution visualizer))
                (receiver (get-receiver-evolution visualizer))
                (server? (equal? tier "_server")))
            (case events-mode
              ((origin) (when origin (plot origin 0 24.)))
              ((server) (when server (plot server 0 24.)))
              ((receiver) (when receiver (plot receiver 0 24.)))
              ((all) (let ((width (cast <fl> (get-width self))))
                       (when origin
                         (set-color surface {Color Gray alpha: .4})
                         (set-line-width surface 1)
                         (move-to surface 0 (- foot 66))
                         (line-to surface width (- foot 66))
                         (plot origin 66 8.))
                       (when server
                         (set-color surface {Color Gray alpha: .4})
                         (set-line-width surface 1)
                         (move-to surface 0 (- foot 33))
                         (line-to surface width (- foot 33))
                         (plot server 33 8.))
                       ;; quick hack around what seems to be a visualizer bug
                       ;; where the server and receiver evolutions are the same
                       (when (and receiver (not server?))
                         (plot receiver 0 8.))))))))))
  
  
  (method (plot-lexicon self surface)
    (define (plot-round-trip h dropped?)
      (let ((v 100)
            (color (if (not dropped?)
                       {Color Green}
                     {Color Red})))
        (set-line-width surface .8)
        (set-color surface color)
        (move-to surface h v)
        (line-to surface (+ h 50) v)))
    
    (define (plot-latency h)
      (let ((v 85))
        (set-line-width surface 1.)
        (set-color surface {Color Blue})
        (move-to surface h v)
        (line-to surface (+ h 100) v)))
    
    (define (plot-traffic h direction)
      (let ((v (- 80 (case direction ((send) 10) ((receive) 20))))
            (color (case direction ((send) {Color Purple}) ((receive) {Color Dark-Purple}))))
        (set-line-width surface 1.)
        (set-color surface color)
        (move-to surface h v)
        (line-to surface (+ h 100) v)))
    
    (plot-round-trip                    20 #f)
    (plot-round-trip                    70 #t)
    (plot-latency                       20)
    (plot-traffic                       20 'send)
    (plot-traffic                       20 'receive)
    (plot-garbage-collect self surface 100)
    (plot-purge-ring      self surface 250 udp-purge-gap udp-audio)
    (plot-purge-ring      self surface 265 udp-purge-seek udp-audio)
    (plot-purge-ring      self surface 250 udp-purge-gap udp-video)
    (plot-purge-ring      self surface 265 udp-purge-seek udp-video)
    (plot-discard/lost    self surface 280 udp-id-discard-packet udp-audio)
    (plot-discard/lost    self surface 290 udp-id-lost-packet udp-audio)
    (plot-discard/lost    self surface 280 udp-id-discard-packet udp-video)
    (plot-discard/lost    self surface 290 udp-id-lost-packet udp-video)
    (plot-throttle-rate   self surface 500 udp-throttle-gap)
    (plot-throttle-rate   self surface 520 udp-throttle-noack)
    (plot-throttle-rate   self surface 570 udp-throttle-restore)
    (plot-moment          self surface 350 1)     ; FATAL_ERROR
    (plot-moment          self surface 360 2)     ; FATAL_CRITICAL
    (plot-moment          self surface 370 3)     ; FATAL_WARNING
    (plot-moment          self surface 380 4)     ; ERROR
    (plot-moment          self surface 390 5)     ; WARNING
    (plot-moment          self surface 390 6)     ; DEBUG
    (plot-moment          self surface 390 7)))   ; LOG


(definition protected (record-events-lexicon)
  (let ((queue (new-queue)))
    (iterate-table event-looks
      (lambda (id look)
        (let ((id (fixnum->flonum id)))
          (enqueue queue id))))
    (let ((ids (queue-list queue))
          (category #f))
      (for-each (lambda (id)
                  (let ((cat (quotient (flonum->fixnum id) 10)))
                    (if (not (eqv? cat category))
                        (begin
                          (when category
                            (sleep .01))
                          (set! category cat)))
                    (record-event id -1. -1. -1. -1. -1. -1. -1.)
                    (sleep .01)))
                (sort < ids))))
  (set-events-lexicon-time (current-seconds)))


;;;
;;;; Timeline
;;;


(class Together-Timeline-Panel extends Evolution-Timeline-Panel
  
  
  (slot evolutions          initialize #f  accessors generate)
  (slot highlighted-title   initialize #f  accessors generate)
  (slot highlighted-markers initialize #f  accessors generate)
  (slot highlighted-values  initialize '() accessors generate)
  
  
  (slot time-base initialize #f getter generate)
  
  
  (method override (prepare self rest)
    (nextmethod self rest)
    (set! live? #f)
    (set! events-mode 'all)
    (set! border-color {Color Dark-Gray}))
  
  
  ;; quicky until the timeline panel uses the timeline class
  (method override (timeline-start self) <fl>
    (if (or live? (not evolutions))
        (nextmethod self)
      (or start
          (let ((start (apply min (map evolution-start (client-evolutions self)))))
            (set! self.start start)
            start))))
  
  
  ;; quicky until the timeline panel uses the timeline class
  (method override (timeline-end self) <fl>
    (if (or live? (not evolutions))
        (nextmethod self)
      (or end
          (let ((end (apply max (map evolution-end (client-evolutions self)))))
            (set! self.end end)
            end))))
  
  
  (method (client-evolutions self)
    (let ((queue (new-queue)))
      (iterate-table evolutions
        (lambda (no evolution)
          (when (and (/= no server-no)
                     (not (empty? evolution)))
            (enqueue queue evolution))))
      (queue-list queue)))
  
  
  (method override (start-playing self)
    (set! time-base (new Time-Base))
    (nextmethod self))
  
  
  (method override (play-loop self)
    (declare (proper-tail-calls))
    (let ((visualizer (brother self 'visualizer)))
      (let (loop)
        (with-task-mutex
          (lambda ()
            (let ((local (current-seconds))
                  (remote (+ now visualizer-quantum)))
              (update-start time-base local remote)
              (let ((playtime (remote->local time-base remote)))
                (step-forward self visualizer-quantum
                  (lambda ()
                    (reset time-base)))
                (sleep (- playtime local))))))
        (loop))))
  
  
  (method override (mouse-up self evt)
    (when evolutions
      (let ((h (get-h evt))
            (v (get-v evt))
            (root parent))
        (define (in-tier?)
          (and (< v 25)
               (between? h 0 75)))
        
        (define (in-range?)
          (and (< v 25)
               (if cpu%
                   (between? h 160 310)
                 (between? h 75 225))))
        
        (define (in-graph?)
          (and (< v 25)
               title
               graph-button
               (between? h (- graph-button 10) (+ graph-button 45))))
        
        (define (in-events?)
          (and (between? v 119 133)
               (between? h 0 70)))
        
        (cond ((in-tier?)
               ;; really quick code that needs cleanup
               (let ((replay (get-replay root)))
                 (let ((names (table-values (get-names replay))))
                   (let ((tiers (sort nu<? names)))
                     (let ((new-tier (if (get-shift? evt)
                                         (previous-element tiers tier)
                                       (next-element tiers tier))))
                       (set! tier new-tier)
                       (let ((id (table-find (get-names replay) tier)))
                         (let ((visualizer (brother self 'visualizer)))
                           (set-tier visualizer id)
                           (setup-visualizer visualizer)
                           (invalidate-view visualizer))
                         (let (;; quick preserve for copy/paste below
                               (now now)
                               (from from)
                               (to to)
                               (sites (metadata-sites (table-ref (get-metadatas replay) id)))
                               (chronology (table-ref (get-chronologies replay) id))
                               (evolution (table-ref (get-evolutions replay) id)))
                           (set! cpu% (chronology-cpu% chronology sites-count))
                           (setup-sites self sites)
                           (set-chronology self chronology)
                           (set-evolution self evolution)
                           (setup-replay self base-time)
                           ;; quick copy/paste from view-replay
                           (when (and from to)
                             (set-bounds self from to)
                             (update-span self))
                           (when now
                             (set-now self now))
                           (set-tier replay id)
                           (set-now replay now)
                           (set-highlighted-cells replay '())))
                       (invalidate-image self)
                       (invalidate-view self))))))
              ((in-range?)
               (let ((values '(20 100 250 500)))
                 (let ((max (if (get-shift? evt)
                                (previous-element values evolutions-max)
                              (next-element values evolutions-max))))
                   (set-evolutions-max max)
                   (invalidate-image self)
                   (timeline-view/now-update root from to now))))
              ((in-graph?)
               (set-graph-latency? (not graph-latency?))
               (invalidate-image self)
               (invalidate-view self))
              ((in-events?)
               (let ((new-events-mode (cycle-element '(#f all receiver server origin) events-mode reversed?: (get-shift? evt))))
                 (set! events-mode new-events-mode)
                 (redraw self)))
              (else
               (nextmethod self evt))))))
  
  
  @no-need-for-microphone-latency-at-the-moment
  (method override (plot-evolution self surface <Surface> from <fl> to <fl>)
    (nextmethod self surface from to)
    (let ((visualizer (brother self 'visualizer)))
      (let ((evolution (get-origin-evolution visualizer)))
        (when evolution
          (let ((width (cast <fl> (get-width self)))
                (latency-scale (* 100. graph-scale))
                (previous-latency-h #f)
                (previous-latency-v #f)
                (previous-timestamp-latency-h #f)
                (previous-timestamp-latency-v #f)
                (first (first-position evolution))
                (last (last-position evolution)))
            (define (find-previous head <fx> id <fl>) <fx+>
              (loop (for n from (- head 1) downto first)
                    (when (and (= (evolutionary-udp-id evolution n) id)
                               (eqv? (flonum->fixnum (evolutionary-udp-origin evolution n)) origin)
                               (eqv? (flonum->fixnum (evolutionary-udp-kind evolution n)) udp-audio))
                      (return n))
                    (finally #f)))
            
            (define (timestamp-time evolution n)
              (let ((base (evolutionary-udp-insert-packet-base evolution n))
                    (dts (evolutionary-udp-insert-packet-dts evolution n)))
                (+ base dts)))
            
            (loop (for n from first to last)
                  (let ((time (evolutionary-udp-time evolution n))
                        (id (evolutionary-udp-id evolution n)))
                      (ecase id
                        ((udp-id-retain-packet)
                         (when (and graph-latency?
                                    (eqv? (flonum->fixnum (evolutionary-udp-origin evolution n)) origin)
                                    (eqv? (flonum->fixnum (evolutionary-udp-kind evolution n)) udp-audio))
                           (let ((h (when->h self from to span time)))
                             (set-color surface {Color red: .005 green: .642 blue: .995})
                             (let ((latency (evolutionary-udp-insert-packet-raw-latency evolution n)))
                               (let ((v (fxround (- 55. (* latency latency-scale)))))
                                 (when (not previous-latency-h)
                                   (let ((n (find-previous n id)))
                                     (when n
                                       (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                             (v (fxround (- 55. (* (evolutionary-udp-insert-packet-raw-latency evolution n) latency-scale)))))
                                         (set! previous-latency-h h)
                                         (set! previous-latency-v v)))))
                                 (when previous-latency-h
                                   (move-to surface previous-latency-h previous-latency-v)
                                   (line-to surface h v))
                                 (set! previous-latency-h h)
                                 (set! previous-latency-v v))))
                           @timestamp-based-experiment
                           (let ((time (timestamp-time evolution n)))
                             (let ((h (when->h self from to span time)))
                               (set-color surface {Color Orange})
                               (let ((latency (evolutionary-udp-insert-packet-raw-latency evolution n)))
                                 (let ((v (fxround (- 55. (* latency latency-scale)))))
                                   (when (not previous-timestamp-latency-h)
                                     (let ((n (find-previous n id)))
                                       (when n
                                         (let ((time (timestamp-time evolution n)))
                                           (when time
                                             (let ((h (when->h self from to span time))
                                                   (v (fxround (- 55. (* (evolutionary-udp-insert-packet-raw-latency evolution n) latency-scale)))))
                                               (set! previous-timestamp-latency-h h)
                                               (set! previous-timestamp-latency-v v)))))))
                                   (when previous-timestamp-latency-h
                                     (move-to surface previous-timestamp-latency-h previous-timestamp-latency-v)
                                     (line-to surface h v))
                                   (set! previous-timestamp-latency-h h)
                                   (set! previous-timestamp-latency-v v)))))))))))))))
  
  
  (method override (plot-highlight self surface <Surface> from <fl> to <fl>)
    (nextmethod self surface from to)
    (let ((root parent)
          (width (cast <fl> (get-width self)))
          (now-h (and now (when->h self from to span now))))
      (cond (highlighted-markers
             (let ((first (first-position chronology))
                   (last (last-position chronology)))
               (define (find-head)
                 (loop (for n from first to last)
                       (when (>= (chronological-time chronology n) from)
                         (return n))
                       (finally first)))
               
               (define (find-tail head)
                 (loop (for n from head to last)
                       (when (> (chronological-time chronology n) to)
                         (return (- n 1)))
                       (finally last)))
               
               (let ((head (find-head)))
                 (let ((tail (find-tail head)))
                   (draw-text surface 320 3 (->string highlighted-title) timeline-text-color)
                   (for-each (lambda (n)
                               (when (and (>= n head)
                                          (<= n tail))
                                 (let ((time (chronological-time chronology n))
                                       (marker (chronological-marker chronology n)))
                                   (let ((h (fxround (* (/ (- time from) span) width))))
                                     (let ((color (if (even? marker) {Color Purple} {Color Red}))
                                           (v 120))
                                       (fill-rect surface (new Rect (- h 0) (- v 4) (+ h 1) (+ v 5)) color))))))
                             highlighted-markers)))))
            ((not-null? highlighted-values)
             (let ((v 110)
                   (the-evolution evolution))
               (iterate-table evolutions
                 (lambda (id evolution)
                   (let ((tier (get-tier (get-replay root)))
                         (first (first-position evolution))
                         (last (last-position evolution))
                         (the-evolution? (eq? evolution the-evolution)))
                     (define (find-head)
                       (loop (for n from first to last)
                             (when (>= (evolutionary-udp-time evolution n) from)
                               (return n))
                             (finally first)))
                     
                     (define (find-tail head)
                       (loop (for n from head to last)
                             (when (> (evolutionary-udp-time evolution n) to)
                               (return (- n 1)))
                             (finally last)))
                     
                     (let ((head (find-head)))
                       (let ((tail (find-tail head)))
                         (define (highlighted-rect time id kind)
                           (let ((h (fxround (* (/ (- time from) span) width))))
                             (let ((color (ecase id
                                            ((udp-id-create-packet) {Color Yellow})
                                            ((udp-id-missing-packet) {Color Blue})
                                            ((udp-id-insert-packet) {Color Blue})
                                            ((udp-id-duplicate-packet) {Color Orange})
                                            ((udp-id-retain-packet) {Color Dark-Gray})
                                            ((udp-id-release-packet) {Color Dark-Gray})
                                            ((udp-id-state-ok) {Color Green})
                                            ((udp-id-state-play) {Color Orange})
                                            ((udp-id-state-freeze) {Color Orange})
                                            ((udp-id-state-wait) {Color Red})
                                            ((udp-id-reset-media) {Color Blue})
                                            (else {Color Red})))
                                   (left (- h 2))
                                   (right (+ h 3))
                                   @old!?
                                   (v (if (= kind udp-audio) 117 124)))
                               (let ((rect (new Rect left (- v 2) right (+ v 3))))
                                 (fill-rect surface rect color)
                                 (when (and now (between? now-h left right))
                                   (unless (memv? id highlighted)
                                     (set! highlighted (cons id highlighted))))))))
                         
                         (loop (for n from head to tail)
                               (for-each (lambda (highlighted)
                                           (bind (highlighted-column highlighted-value . others) highlighted
                                             (case highlighted-column
                                               ;; tier
                                               ((1)
                                                (let ((time (evolutionary-udp-time evolution n))
                                                      (id (evolutionary-udp-id evolution n))
                                                      (kind (evolutionary-udp-kind evolution n)))
                                                  ;; the -1 is a quick hack for server's #f
                                                  (when (= (or tier -1) highlighted-value)
                                                    (highlighted-rect time id kind))))
                                               ;; sequence
                                               ((5)
                                                (let ((highlighted-origin (and (not-null? others) (car others)))
                                                      (highlighted-kind (and (not-null? others) (cadr others))))
                                                  (let ((time (evolutionary-udp-time evolution n))
                                                        (origin (evolutionary-udp-origin evolution n))
                                                        (kind (evolutionary-udp-kind evolution n))
                                                        (value (evolutionary-udp-data1 evolution n)))
                                                    (when (and (= value highlighted-value)
                                                               (or (not highlighted-origin) (eqv? origin highlighted-origin))
                                                               (or (not highlighted-kind) (eqv? kind highlighted-kind)))
                                                      (let ((id (evolutionary-udp-id evolution n))
                                                            (kind (evolutionary-udp-kind evolution n)))
                                                        (highlighted-rect time id kind))))))
                                               ;; value
                                               (else
                                                (let ((time (evolutionary-udp-time evolution n)))
                                                  (let ((value (if (= highlighted-column 0)
                                                                   time
                                                                 (evolutionary-ref evolution n (- highlighted-column 1)))))
                                                    (when (= value highlighted-value)
                                                      (let ((id (evolutionary-udp-id evolution n))
                                                            (kind (evolutionary-udp-kind evolution n)))
                                                        (highlighted-rect time id kind)))))))))
                                         highlighted-values)))))
                   (increase! v 7))))))))
  
  
  @no-need-for-microphone-latency-at-the-moment
  (method override (plot-nowinfo self surface <Surface> from <fl> to <fl>)
    (nextmethod self surface from to)
    (when (and now (not live?))
      (let ((h (when->h self from to span now))
            (text-color {Color Light-Gray}))
        (let ((labels '()))
          (define (add-label side vert str)
            (set! labels (cons (list side vert str) labels)))
          
          ;; latency
          (unless (or full-mode? visualize? (not graph-latency?) (not evolution))
            (let ((visualizer (brother self 'visualizer)))
              (let ((evolution (get-origin-evolution visualizer)))
                (when evolution
                  (let ((latency-scale (* 100. graph-scale)))
                    (define (find-before time id)
                      (loop (for n from (last-position evolution) downto (first-position evolution))
                            (when (and (= (evolutionary-udp-id evolution n) id)
                                       (< (evolutionary-udp-time evolution n) time)
                                       (eqv? (flonum->fixnum (evolutionary-udp-origin evolution n)) origin)
                                       (eqv? (flonum->fixnum (evolutionary-udp-kind evolution n)) udp-audio))
                              (return n))
                            (finally #f)))
                    
                    (define (find-after time id)
                      (loop (for n from (first-position evolution) to (last-position evolution))
                            (when (and (= (evolutionary-udp-id evolution n) id)
                                       (> (evolutionary-udp-time evolution n) time)
                                       (eqv? (flonum->fixnum (evolutionary-udp-origin evolution n)) origin)
                                       (eqv? (flonum->fixnum (evolutionary-udp-kind evolution n)) udp-audio))
                              (return n))
                            (finally #f)))
                    
                    (let ((before (find-before now udp-id-retain-packet)))
                      (when before
                        (let ((actual-after (find-after now udp-id-retain-packet)))
                          (let ((after (or actual-after before)))
                            (let ((b (evolutionary-udp-insert-packet-raw-latency evolution before))
                                  (a (evolutionary-udp-insert-packet-raw-latency evolution after)))
                              (let ((bv (fxround (- 55. (* b latency-scale))))
                                    (av (fxround (- 55. (* a latency-scale)))))
                                (let ((vert (if actual-after
                                                (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) bv av)
                                              bv))
                                      (latency (if actual-after
                                                   (interpolate now (evolutionary-udp-time evolution before) (evolutionary-udp-time evolution after) b a)
                                                 b)))
                                  (let ((str (present-seconds latency)))
                                    (add-label 'right vert str))))))))))))))
          ;; labels
          (plot-labels self surface h text-color labels)))))
  
  
  (method override (right-mouse-up self evt)
    (zoom-reset self))
  
  
  (method override (view-update self)
    (let ((root parent))
      (timeline-view/now-update root from to #f)))
  
  
  (method override (now-update self)
    (let ((root parent))
      (let ((update-evolution? (and (not visualize?) (not full-mode?))))
        (timeline-view/now-update root from to now update-evolution? playing?)))))


;;;
;;;; Evolution
;;;


(class Together-Evolution-Panel extends Evolution-Panel
  
  
  (form
    (<install>
      (<border~>  border-type: solid border-color: {Color Dark-Gray})
      (<entries~> selection-handler: {Event-Handler :form on-selection-change} double-click-handler: {Event-Handler :form on-double-click})))
  
  
  (method override (form-model self form)
    (case (get-name form)
      ((header) Together-Evolution-Header)
      ((entries) Together-Evolution-Tree)
      (else (nextmethod self form))))
  
  
  (method protected (collect-entries self column)
    (if (= column 1)
        (sort ci<? (table->list names) key: cdr)
      (let ((entries (make-table test: eqv?)))
        (define (process value present)
          (unless (table-ref entries value #f)
            (let ((title (present self value)))
              (unless (empty-string? title)
                (table-set! entries value title)))))
        
        (iterate-table evolutions
          (lambda (id evolution)
            (loop (for n from (first-position evolution) to (last-position evolution))
                  (case column
                    ((2) (process (evolutionary-udp-id evolution n) present-event))
                    ((3) (process (evolutionary-udp-origin evolution n) present-origin))
                    ((4) (process (evolutionary-udp-channel evolution n) present-channel))
                    ((5) (process (evolutionary-udp-kind evolution n) present-kind))))))
        (sort ci<? (table->list entries) key: cdr))))
  
  
  (method (on-selection-change self evt)
    (let ((root parent))
      (let ((selection (get-selection evt)))
        (evolution-selection-update root selection))))
  
  
  (method (on-double-click self evt)
    (let ((root parent))
      (let ((selection (get-selection (get-sender evt))))
        (evolution-double-click root selection)))))


(class Together-Evolution-Header extends Tree-Header
  
  
  (method override (draw-button self surface width h v title column)
    (let ((root (find-ascendant self Together-Replay-Panel)))
      (let ((timeline (child root 'timeline))
            (rank (get-rank column)))
        (when (some? (lambda (highlight)
                       (= (first highlight) rank))
                     (get-highlighted-values timeline))
          (draw-highlighted surface 0 h v title #t {Color World-Red})))))
  
  
  (method override (close-popups self (event: event #f) (all?: all? #f) (exclude: exclude #f) (initiator: initiator #f))
    (unless (memq? event '(mouse-down double-click))
      (nextmethod self event: event all?: all? exclude: exclude initiator: initiator))))


(class Together-Evolution-Tree extends Evolution-Tree
  
  
  (method override (can-copy? self)
    #t)
  
  
  (method override (copy-selection self)
    (let ((selection (get-selection self)))
      (if (null? selection)
          (bell)
        (let ((sorted-selection (sort nu<? selection)))
          (set-clipboard-text (join (map (lambda (cell) (get-cell-title self cell)) sorted-selection) " "))
          (add-clipboard (current-application))))))
  
  
  (method override (header-click self column)
    (let ((panel (find-ascendant self Together-Evolution-Panel)))
      (when (get-names panel)
        (if (alt-down?)
            (highlight-click self column)
          (filter-click self column)))))
  
  
  (method (filter-click self column)
    (let ((view (find-popup Filter-View))
          (rank (get-rank column)))
      (close-popups (get-window-manager) (current-window))
      (unless (and view (eq? (get-column view) column))
        (let ((panel (find-ascendant self Together-Evolution-Panel))
              (header (find-ascendant self Tree-Header))
              (enumerated? (between? rank 1 5)))
          (let ((entries (and enumerated? (collect-entries panel (get-rank column)))))
            (let ((view (make-filter-view self column enumerated? entries))
                  (rect (header-rect header column)))
              (popup header
                     view
                     (new Point
                       (- (get-right rect) 15)
                       (+ (get-top rect) 17)))
              (if enumerated?
                  (acquire-focus view)
                (let ((client (get-client (child view '(border scroller)))))
                  (select-all client)
                  (acquire-focus client)))))))))
  
  
  (method (highlight-click self column)
    (let ((view (find-popup Highlight-View))
          (rank (get-rank column)))
      (close-popups (get-window-manager) (current-window))
      (unless (and view (eq? (get-column view) column))
        (let ((panel (find-ascendant self Together-Evolution-Panel))
              (header (find-ascendant self Tree-Header))
              (enumerated? (between? rank 1 5)))
          (let ((entries (and enumerated? (collect-entries panel (get-rank column)))))
            (let ((view (make-highlight-view self column enumerated? entries))
                  (rect (header-rect header column)))
              (popup header
                     view
                     (new Point
                       (- (get-right rect) 15)
                       (+ (get-top rect) 17)))
              (if enumerated?
                  (acquire-focus view)
                (let ((client (get-client (child view '(border scroller)))))
                  (select-all client)
                  (acquire-focus client))))))))))


(definition (make-filter-view tree column enumerated? entries)
  (let ((view (new Filter-View
                size: {Dimension 186 300}
                background: {Color red: .000 green: .000 blue: .000 alpha: .85}
                tree: tree
                column: column
                enumerated?: enumerated?)))
    (case (column-sorting tree column)
      ((ascending) (set-checked? (child view 'ascending) #t))
      ((descending) (set-checked? (child view 'descending) #t))
      (else (set-checked? (child view 'unsorted) #t)))
    (if enumerated?
        (let ((scroller (new Scroller-View parent: view name: 'scroller position: {Point 5 120} size: {Dimension 176 144} vscroll?: #t style: 'tool)))
          (let ((content (get-content scroller)))
            (let ((v 0)
                  (values (column-filtering tree column)))
              (let ((client (new View parent: content)))
                (for-each (lambda (entry)
                            (bind (value . title) entry
                              (let ((checked? (or (not values) (member? value values))))
                                (new Filter-Label parent: client title: title position: (new Point 5 v) size: {Dimension 163 22} style: 'text background: #f color: {Color White} checked?: checked? value: value)))
                            (increase! v 20))
                          entries)
                (set-size client (new Dimension 163 (+ v 2)))
                (set-client scroller client)))))
      (let ((border (new Border-View parent: view name: 'border position: {Point 5 120} size: {Dimension 176 144} border-type: 'solid border-color: {Color Dark-Gray})))
        (let ((scroller (new Scroller-View parent: border name: 'scroller vscroll?: #t style: 'tool)))
          (let ((content (get-content scroller)))
            (let ((client (new Filter-Text parent: content background: 'none))
                  (values (column-filtering tree column)))
              (if (not values)
                  (set-string-content client "*\n")
                (unless (null? values)
                  (set-string-content client (substitute-alist '((#\( . "[") (#\) . "]")) (string-append (join (map ->string values) "\n") "\n")))))
              (set-client scroller client))))))
    view))


(class Filter-View extends Layout-View
  
  
  (property tree        initialize #f accessors generate)
  (property column      initialize #f accessors generate)
  (property enumerated? initialize #f accessors generate)
  
  
  (form
    (<install>
      (<Label-View>                   title: "Sort" font: {Font font-name: tahoma point-size: 14 shadow: thin} position: {Point 5 3} size: {Dimension 80 18} color: {Color World-Ochre})
      (<Check-Label> name: ascending  title: "Ascending" style: text background: #f position: {Point 10 23} color: {Color White} action-handler: {Event-Handler :form on-sort-ascending})
      (<Check-Label> name: descending title: "Descending" style: text background: #f position: {Point 10 43} color: {Color White} action-handler: {Event-Handler :form on-sort-descending})
      (<Check-Label> name: unsorted   title: "Unsorted" style: text background: #f position: {Point 10 63} color: {Color White} action-handler: {Event-Handler :form on-unsorted})
      (<Label-View>                   title: "Filter" font: {Font font-name: tahoma point-size: 14 shadow: thin} position: {Point 5 100} size: {Dimension 80 18} color: {Color World-Ochre})
      (<Push-Button>                  title: "All" style: text background: #f position: {Point 120 100} color: {Color red: .861 green: .081 blue: .093} action-handler: {Event-Handler :form on-filter-all})
      (<Push-Button>                  title: "None" style: text background: #f position: {Point 145 100} color: {Color red: .861 green: .081 blue: .093} action-handler: {Event-Handler :form on-filter-none})
      (<Push-Button>                  title: "OK" position: {Point 8 268} size: {Dimension 80 24} default?: #t action-handler: {Event-Handler :form on-ok})
      (<Push-Button>                  title: "Cancel" position: {Point 98 268} size: {Dimension 80 24} action-handler: {Event-Handler :form on-cancel})))
  
  
  (method override (escape-press self evt)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method override (return-press self evt)
    (apply-filter self)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method (sort-column self new-direction)
    (let ((root (find-ascendant tree Together-Replay-Panel)))
      (let ((current-direction (column-sorting tree column)))
        (unless (eq? current-direction new-direction)
          (sort-column tree column new-direction sort-rows?: #f)
          (display-evolutions root)
          (highlight-replay-value root)))))
  
  
  (method (unsort-column self)
    (let ((root (find-ascendant tree Together-Replay-Panel)))
      (unsort-columns tree sort-rows?: #f)
      (display-evolutions root)
      (highlight-replay-value root)))
  
  
  (method (on-sort-ascending self evt)
    (sort-column self 'ascending)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method (on-sort-descending self evt)
    (sort-column self 'descending)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method (on-unsorted self evt)
    (unsort-column self)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method (on-filter-all self evt)
    (if enumerated?
        (let ((client (get-client (child self 'scroller))))
          (for-each (lambda (label)
                      (set-checked? label #t))
                    (get-children client)))
      (let ((client (get-client (child self '(border scroller)))))
        (set-string-content client "*\n")
        (select-all client))))
  
  
  (method (on-filter-none self evt)
    (if enumerated?
        (let ((client (get-client (child self 'scroller))))
          (for-each (lambda (label)
                      (set-checked? label #f))
                    (get-children client)))
      (let ((client (get-client (child self '(border scroller)))))
        (set-string-content client "")
        (select-all client))))
  
  
  (method protected (apply-filter self)
    (let ((root (find-ascendant tree Together-Replay-Panel)))
      (set-highlighted-cells (get-replay root) '())
      (if enumerated?
          (let ((client (get-client (child self 'scroller))))
            (let ((all (get-children client)))
              (let ((checked (collect-if get-checked? all)))
                (if (= (length checked) (length all))
                    (unfilter-column tree column filter-rows?: #f)
                  (let ((values (map get-value checked)))
                    (filter-column tree column values type: 'number filter-rows?: #f))))))
        (let ((client (get-client (child self '(border scroller)))))
          (let ((content (get-string-content client)))
            (if (equal? (trim-whitespace content) "*")
                (unfilter-column tree column filter-rows?: #f)
              (let ((values (read-string-content content)))
                (filter-column tree column values type: 'number filter-rows?: #f))))))
      (display-evolutions root)
      (highlight-replay-value root)))
  
  
  (method (on-ok self evt)
    (apply-filter self)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method (on-cancel self evt)
    (close-popups (get-window-manager) (current-window))))


(definition (make-highlight-view tree column enumerated? entries)
  (let ((root (find-ascendant tree Together-Replay-Panel)))
    (let ((timeline (child root 'timeline))
          (view (new Highlight-View
                  size: {Dimension 186 300}
                  background: {Color red: .000 green: .000 blue: .000 alpha: .85}
                  tree: tree
                  column: column
                  enumerated?: enumerated?)))
      (let ((rank (get-rank column)))
        (let ((highlighted (collect-if (lambda (highlight) (= (first highlight) rank)) (get-highlighted-values timeline))))
          (if enumerated?
              (let ((scroller (new Scroller-View parent: view name: 'scroller position: {Point 5 23} size: {Dimension 176 241} vscroll?: #t style: 'tool)))
                (let ((content (get-content scroller)))
                  (let ((v 0)
                        (values (map second highlighted)))
                    (let ((client (new View parent: content)))
                      (for-each (lambda (entry)
                                  (bind (value . title) entry
                                    (let ((checked? (or (not values) (member? value values))))
                                      (new Highlight-Label parent: client title: title position: (new Point 5 v) size: {Dimension 163 22} style: 'text background: #f color: {Color White} checked?: checked? value: value)))
                                  (increase! v 20))
                                entries)
                      (set-size client (new Dimension 163 (+ v 2)))
                      (set-client scroller client)))))
            (set-visible? (child view 'all) #f)
            (let ((border (new Border-View parent: view name: 'border position: {Point 5 23} size: {Dimension 176 241} border-type: 'solid border-color: {Color Dark-Gray})))
              (let ((scroller (new Scroller-View parent: border name: 'scroller vscroll?: #t style: 'tool)))
                (let ((content (get-content scroller)))
                  (let ((client (new Highlight-Text parent: content background: 'none))
                        (values (map second highlighted)))
                    (unless (null? values)
                      (set-string-content client (substitute-alist '((#\( . "[") (#\) . "]")) (string-append (join (map ->string values) "\n") "\n"))))
                    (set-client scroller client))))))
          view)))))


(class Highlight-View extends Layout-View
  
  
  (property tree        initialize #f accessors generate)
  (property column      initialize #f accessors generate)
  (property enumerated? initialize #f accessors generate)
  
  
  (form
    (<install>
      (<Label-View>             title: "Highlight" font: {Font font-name: tahoma point-size: 14 shadow: thin} position: {Point 5 3} size: {Dimension 80 18} color: {Color World-Ochre})
      (<Push-Button> name: all  title: "All" style: text background: #f position: {Point 120 3} color: {Color red: .861 green: .081 blue: .093} action-handler: {Event-Handler :form on-highlight-all})
      (<Push-Button> name: none title: "None" style: text background: #f position: {Point 145 3} color: {Color red: .861 green: .081 blue: .093} action-handler: {Event-Handler :form on-highlight-none})
      (<Push-Button>            title: "OK" position: {Point 8 268} size: {Dimension 80 24} default?: #t action-handler: {Event-Handler :form on-ok})
      (<Push-Button>            title: "Cancel" position: {Point 98 268} size: {Dimension 80 24} action-handler: {Event-Handler :form on-cancel})))
  
  
  (method override (escape-press self evt)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method override (return-press self evt)
    (apply-highlight self)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method (sort-column self new-direction)
    (let ((current-direction (column-sorting tree column)))
      (unless (eq? current-direction new-direction)
        (sort-column tree column new-direction)))
    (ensure-displayed tree))
  
  
  (method (on-sort-ascending self evt)
    (sort-column self 'ascending)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method (on-sort-descending self evt)
    (sort-column self 'descending)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method (on-unsorted self evt)
    (let ((root (find-ascendant tree Together-Replay-Panel)))
      (unsort-columns tree)
      (display-evolutions root)
      (highlight-replay-value root)
      (close-popups (get-window-manager) (current-window))))
  
  
  (method (on-highlight-all self evt)
    (when enumerated?
      (let ((client (get-client (child self 'scroller))))
        (for-each (lambda (label)
                    (set-checked? label #t))
                  (get-children client)))))
  
  
  (method (on-highlight-none self evt)
    (if enumerated?
        (let ((client (get-client (child self 'scroller))))
          (for-each (lambda (label)
                      (set-checked? label #f))
                    (get-children client)))
      (let ((client (get-client (child self '(border scroller)))))
        (set-string-content client "")
        (select-all client))))
  
  
  (method protected (apply-highlight self)
    (let ((root (find-ascendant tree Together-Replay-Panel)))
      (let ((timeline (child root 'timeline)))
        (set-highlighted-cells (get-replay root) '())
        (let ((rank (get-rank column))
              (values
                (if enumerated?
                    (let ((client (get-client (child self 'scroller))))
                      (let ((all (get-children client)))
                        (let ((checked (collect-if get-checked? all)))
                          (map get-value checked))))
                  (let ((client (get-client (child self '(border scroller)))))
                    (let ((content (get-string-content client)))
                      (read-string-content content))))))
          (set-highlighted-values timeline (append (collect-if (lambda (highlight)
                                                                 (/= (first highlight) rank))
                                                               (get-highlighted-values timeline))
                                                   (map (lambda (value)
                                                          (list rank value))
                                                        values)))
          (redraw timeline)))))
  
  
  (method (on-ok self evt)
    (apply-highlight self)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method (on-cancel self evt)
    (close-popups (get-window-manager) (current-window))))


(class Check-Label extends Push-Button
  
  
  (property checked? initialize #f accessors explicit)


  (method public (get-checked? self)
    checked?)
  

  (method public (set-checked? self flag)
    (set! checked? flag)
    (invalidate-view self))
  
  
  (method override (process-action self sender . rest)
    (if action-handler
        (apply nextmethod self sender rest)
      (set-checked? self (not checked?))))
  
  
  (method override (draw self surface context)
    (nextmethod self surface context)
    (when checked?
      (let ((appl (current-application))
            (left 3)
            (top 4))
        (draw-image (get-images-portfolio appl) surface context {Image-Resource "CheckMarkWhite"} left top))))
  
  
  (method override (draw-text-at self surface h v title color enabled?)
    (draw-text surface (+ h 20) v title color enabled?: enabled?)))


(class Filter-Label extends Check-Label
  
  
  (property value initialize #f accessors generate))


(class Filter-Text extends World-Text-View
  
  
  (method override (new-model self)
    (new Text-Model base-style: {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin}} left-padding: 2))
  
  
  (method override (escape-press self evt)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method override (return-press self evt)
    (let ((end (get-end self)))
      (if (and (cell=? end (text-ending self))
               (= (get-col end) 0))
          (begin
            (apply-filter (find-ascendant self Filter-View))
            (close-popups (get-window-manager) (current-window)))
        (nextmethod self evt)))))


(class Highlight-Label extends Check-Label
  
  
  (property value initialize #f accessors generate))


(class Highlight-Text extends World-Text-View
  
  
  (method override (new-model self)
    (new Text-Model base-style: {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin}} left-padding: 2))
  
  
  (method override (escape-press self evt)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method override (return-press self evt)
    (let ((end (get-end self)))
      (if (and (cell=? end (text-ending self))
               (= (get-col end) 0))
          (begin
            (apply-highlight (find-ascendant self Highlight-View))
            (close-popups (get-window-manager) (current-window)))
        (nextmethod self evt))))))
