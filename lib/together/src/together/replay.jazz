;;;============
;;;  Together
;;;============
;;;
;;;; Replay Stage
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module together.replay jazz


(import (jazz.application)
        (jazz.clipboard)
        (jazz.component)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.handler)
        (jazz.markup)
        (jazz.outline)
        (jazz.platform)
        (jazz.resource)
        (jazz.text)
        (jazz.tree)
        (jazz.ui)
        (jazz.view)
        (jazz.window)
        (world)
        (world.chronology)
        (world.context)
        (world.event)
        (world.evolution)
        (world.geometry)
        (world.interface.evolution)
        (world.interface.panel)
        (world.interface.text)
        (world.interface.timeline)
        (world.manager)
        (world.settings)
        (world.task)
        (world.time)
        (world.timeline)
        (world.udp)
        (together)
        (together.visualizer))


(definition package (timeline-view/now-update zone from to now (update-evolution? #t) (playing? #f))
  (let ((root (get-root zone))
        (replay (get-replay zone)))
    (let ((panel (child root 'evolution)))
      (let ((names (get-names replay))
            (evolutions (get-evolutions replay))
            (base-time (get-base-time replay)))
        (set-from replay from)
        (set-to replay to)
        (when now
          (set-now replay now))
        (set-highlighted-cells replay '())
        (when now
          (let ((visualizer (child root 'visualizer)))
            (visualize-time visualizer now playing?)))
        (when update-evolution?
          (when now
            (display-evolutions zone now))
          (highlight-replay-value zone)
          (let ((dir (get-directory replay)))
            (when dir
              (set-setting options-settings 'world.last-replay (list (get-name dir) from to (or now (get-now replay))))
              (save-content options-settings))))))))


(definition package (display-evolutions zone (now #f))
  (let ((root (get-root zone))
        (replay (get-replay zone)))
    (let ((evolution-panel (child root 'evolution))
          (timeline-panel (child root 'timeline))
          (now (or now (get-now replay))))
      (if (not now)
          (begin
            (clear-evolutions evolution-panel)
            (set-evolution-range timeline-panel #f)
            (set-evolution-left timeline-panel #f)
            (set-evolution-right timeline-panel #f))
        (receive (displayed total left right) (view-evolutions-at evolution-panel now)
          (set-evolution-range timeline-panel (format "{a} of {a}" displayed total))
          (set-evolution-left timeline-panel left)
          (set-evolution-right timeline-panel right)))
      (invalidate-view timeline-panel))))


(definition package (highlight-replay-value zone)
  (let ((root (get-root zone))
        (replay (get-replay zone)))
    (let ((value (get-highlighted-value replay))
          (col (get-highlighted-column replay)))
      (when value
        (let ((panel (child root 'evolution)))
          (let ((origin (get-highlighted-origin replay))
                (kind (get-highlighted-kind replay))
                (tree (locate panel 'entries)))
            (highlight-value zone tree origin kind value col)
            (invalidate-view tree)))))))


(definition package (evolution-selection-update zone selection)
  (let ((root (get-root zone))
        (replay (get-replay zone)))
    (when (not-null? selection)
      (let ((panel (child root 'evolution)))
        (let ((tree (locate panel 'entries)))
          ;; elapses
          (let ((timeline (child root 'timeline)))
            (set-elapses timeline
              (and (> (length selection) 1)
                   (uniform selection key: get-col)
                   (let ((values (map (lambda (cell)
                                        (string->number (get-cell-title tree cell)))
                                      (sort nu<? selection))))
                     (and (not (memv? #f values))
                          (loop (for before in values remainder after)
                                (unless (null? after)
                                  (collect
                                    (let ((elapse (- (car after) before)))
                                      (format "{r precision: 6}" elapse))))))))))
          ;; unhighlight
          (for-each (lambda (cell)
                      (let ((data (get-cell-data tree cell)))
                        (set-frame-color data #f)))
                    (get-highlighted-cells replay))
          (set-highlighted-value replay #f)
          (set-highlighted-cells replay '())
          ;; highlight
          (let ((cell (car selection)))
            (let ((line (get-line cell))
                  (col (get-col cell)))
              (let ((row (get-row tree line)))
                (let ((user-data (get-user-data row))
                      (sequence? (= col 5)))
                  (let ((origin (and sequence? (vector-ref user-data (- col 2))))
                        (kind (and sequence? (vector-ref user-data (- col 1))))
                        (value (vector-ref user-data col)))
                    (highlight-value zone tree origin kind value col))))))
          ;; invalidate
          (invalidate-view tree))))))


(definition package (evolution-double-click zone selection)
  (let ((root (get-root zone)))
    (let ((timeline (child root 'timeline))
          (panel (child root 'evolution)))
      (let ((tree (locate panel 'entries)))
        (let ((selection (get-selection tree)))
          (if (null? selection)
              (set-highlighted-values timeline '())
            (let ((highlighted
                    (let ((cell (car selection)))
                      (let ((line (get-line cell))
                            (col (get-col cell)))
                        (cond ;; time
                              ((= col 0)
                               (let ((row (get-row tree line)))
                                 (let ((user-data (get-user-data row)))
                                   (let ((value (vector-ref user-data col)))
                                     (list 0 value)))))
                              ;; tier
                              ((= col 1)
                               (let ((row (get-row tree line)))
                                 (let ((user-data (get-user-data row)))
                                   (let ((value (vector-ref user-data col)))
                                     ;; the -1 is a quick hack for server's #f
                                     (list 1 (or value -1))))))
                              ;; sequence
                              ((= col 5)
                               (let ((row (get-row tree line)))
                                 (let ((user-data (get-user-data row)))
                                   (let ((origin (vector-ref user-data (- col 2)))
                                         (kind (vector-ref user-data (- col 1)))
                                         (value (vector-ref user-data col)))
                                     (list col value origin kind)))))
                              ;; value
                              (else
                               (let ((row (get-row tree line)))
                                 (let ((user-data (get-user-data row)))
                                   (let ((value (vector-ref user-data col)))
                                     (list col value))))))))))
              (let ((highlighted-values (get-highlighted-values timeline)))
                (if (member? highlighted highlighted-values)
                    (set-highlighted-values timeline (remove highlighted highlighted-values test: equal?))
                  (set-highlighted-values timeline (cons highlighted highlighted-values))))))
          (invalidate-view timeline)
          (invalidate-view panel))))))


(definition package (highlight-value zone tree origin kind value col)
  (let ((replay (get-replay zone)))
    (set-highlighted-origin replay origin)
    (set-highlighted-kind replay kind)
    (set-highlighted-value replay value)
    (set-highlighted-column replay col)
    (for-each-visible-row tree
      (lambda (row line)
        (let ((user-data (get-user-data row))
              (sequence? (= col 5)))
          (let ((data-origin (and sequence? (vector-ref user-data (- col 2))))
                (data-kind (and sequence? (vector-ref user-data (- col 1))))
                (data-value (vector-ref user-data col)))
            (when (and (eqv? data-value value)
                       (or (not origin) (eqv? data-origin origin))
                       (or (not kind) (eqv? data-kind kind)))
              (let ((data (get-child row col)))
                (set-frame-color data {Color Red})
                (set-highlighted-cells replay (cons (new Cell line col) (get-highlighted-cells replay)))))))))))


;;;
;;;; Replay
;;;


(class Replay extends Timeline
  
  
  (slot from               initialize #f  accessors generate)
  (slot to                 initialize #f  accessors generate)
  (slot now                initialize #f  accessors generate)
  (slot highlighted-origin initialize #f  accessors generate)
  (slot highlighted-kind   initialize #f  accessors generate)
  (slot highlighted-value  initialize #f  accessors generate)
  (slot highlighted-column initialize #f  accessors generate)
  (slot highlighted-cells  initialize '() accessors generate))


;;;
;;;; Timeline
;;;


(class Together-Timeline-Panel extends Timeline-Panel
  
  
  (slot evolutions          initialize #f  accessors generate)
  (slot highlighted-title   initialize #f  accessors generate)
  (slot highlighted-markers initialize #f  accessors generate)
  (slot highlighted-values  initialize '() accessors generate)
  
  
  (slot time-base initialize #f getter generate)
  
  
  (method override (prepare self rest)
    (nextmethod self rest)
    (set! live? #f))
  
  
  ;; quicky
  (method override (together-timeline? self)
    #t)
  
  
  ;; quicky until the timeline panel uses the timeline class
  (method override (timeline-start self) <fl>
    (if (or live? (not evolutions))
        (nextmethod self)
      (or start
          (let ((start (apply min (map evolution-start (client-evolutions self)))))
            (set! self.start start)
            start))))
  
  
  ;; quicky until the timeline panel uses the timeline class
  (method override (timeline-end self) <fl>
    (if (or live? (not evolutions))
        (nextmethod self)
      (or end
          (let ((end (apply max (map evolution-end (client-evolutions self)))))
            (set! self.end end)
            end))))
  
  
  (method (client-evolutions self)
    (let ((queue (new-queue)))
      (iterate-table evolutions
        (lambda (no evolution)
          (when (and (/= no server-no)
                     (not (empty? evolution)))
            (enqueue queue evolution))))
      (queue-list queue)))
  
  
  (method override (start-playing self)
    (set! time-base (new Time-Base))
    (nextmethod self))
  
  
  (method override (play-loop self)
    (declare (proper-tail-calls))
    (let ((visualizer (child (get-root (current-zone)) 'visualizer)))
      (let (loop)
        (with-task-mutex
          (lambda ()
            (let ((local (current-seconds))
                  (remote (+ now .01)))
              (update-start time-base local remote)
              (let ((playtime (remote->local time-base remote)))
                (step-forward self .01)
                (sleep (- playtime local))))))
        (loop))))
  
  
  (method override (mouse-up self evt)
    (when evolutions
      (let ((h (get-h evt))
            (v (get-v evt)))
        (define (in-tier?)
          (and (< v 25)
               (between? h 0 75)))
        
        (define (in-range?)
          (and (< v 25)
               (if cpu%
                   (between? h 160 310)
                 (between? h 75 225))))
        
        (define (in-graph?)
          (and (< v 25)
               title
               graph-button
               (between? h (- graph-button 10) (+ graph-button 45))))
        
        (cond ((in-tier?)
               ;; really quick code that needs cleanup
               (let ((replay (get-replay (current-zone))))
                 (let ((names (table-values (get-names replay))))
                   (let ((tiers (sort nu<? names)))
                     (let ((new-tier (if (get-shift? evt)
                                         (previous-element tiers tier)
                                       (next-element tiers tier))))
                       (set! tier new-tier)
                       (let ((id (table-find (get-names replay) tier)))
                         (let ((visualizer (brother self 'visualizer)))
                           (set-tier visualizer id)
                           (setup-visualizer visualizer)
                           (invalidate-view visualizer))
                         (let (;; quick preserve for copy/paste below
                               (now now)
                               (from from)
                               (to to)
                               (chronology (table-ref (get-chronologies replay) id))
                               (evolution (table-ref (get-evolutions replay) id)))
                           (set! cpu% (chronology-cpu% chronology))
                           (set-chronology self chronology)
                           (set-evolution self evolution)
                           (setup-replay self base-time)
                           ;; quick copy/paste from view-replay
                           (when (and from to)
                             (set-bounds self from to)
                             (update-span self))
                           (when now
                             (set-now self now))
                           (set-tier replay id)
                           (set-now replay now)
                           (set-highlighted-cells replay '())))
                       (invalidate-view self))))))
              ((in-range?)
               (let ((world (current-world))
                     (zone (current-zone)))
                 (let ((values '(26 100 250 500)))
                   (let ((max (if (get-shift? evt)
                                  (previous-element values evolutions-max)
                                (next-element values evolutions-max))))
                     (set-evolutions-max max)
                     (timeline-view/now-update zone from to now)))))
              ((in-graph?)
               (set-graph-latency? (not graph-latency?))
               (invalidate-view self))
              (else
               (nextmethod self evt))))))
  
  
  (method override (border-color self)
    {Color Dark-Gray})
  
  
  (method override (plot-evolution self surface <Surface> from <fl> to <fl>)
    (nextmethod self surface from to)
    (let ((visualizer (brother self 'visualizer)))
      (let ((evolution (get-origin-evolution visualizer)))
        (when evolution
          (let ((width (cast <fl> (get-width self)))
                (latency-scale 15.)
                (previous-latency-h #f)
                (previous-latency-v #f)
                (first (first-position evolution))
                (last (last-position evolution)))
            (define (find-previous head <fx> id <fl>) <fx+>
              (loop (for n from (- head 1) downto first)
                    (when (= (evolutionary-udp-id evolution n) id)
                      (return n))
                    (finally #f)))
            
            (loop (for n from first to last)
                  (let ((time (evolutionary-udp-time evolution n))
                        (id (evolutionary-udp-id evolution n)))
                      (ecase id
                        ((udp-id-retain-packet)
                         (when (and graph-latency?
                                    (eqv? (flonum->fixnum (evolutionary-udp-origin evolution n)) origin)
                                    (eqv? (flonum->fixnum (evolutionary-udp-kind evolution n)) media-kind))
                           (let ((h (fxround (* (/ (- time from) span) width)))
                                 (v 21))
                             (set-color surface {Color red: .005 green: .642 blue: .995})
                             (let ((latency (evolutionary-udp-data6 evolution n)))
                               (let ((v (fxround (- 55. (* latency latency-scale)))))
                                 (when (not previous-latency-h)
                                   (let ((n (find-previous n id)))
                                     (when n
                                       (let ((h (when->h self from to span (evolutionary-udp-time evolution n)))
                                             (v (fxround (- 55. (* (evolutionary-udp-data6 evolution n) latency-scale)))))
                                         (set! previous-latency-h h)
                                         (set! previous-latency-v v)))))
                                 (when previous-latency-h
                                   (move-to surface previous-latency-h previous-latency-v)
                                   (line-to surface h v))
                                 (set! previous-latency-h h)
                                 (set! previous-latency-v v))))))))))))))
  
  
  (method override (plot-highlight self surface <Surface> from <fl> to <fl>)
    (nextmethod self surface from to)
    (let ((width (cast <fl> (get-width self)))
          (now-h (and now (when->h self from to span now))))
      (cond (highlighted-markers
             (let ((first (first-position chronology))
                   (last (last-position chronology)))
               (define (find-head)
                 (loop (for n from first to last)
                       (when (>= (chronological-time chronology n) from)
                         (return n))
                       (finally first)))
               
               (define (find-tail head)
                 (loop (for n from head to last)
                       (when (> (chronological-time chronology n) to)
                         (return (- n 1)))
                       (finally last)))
               
               (let ((head (find-head)))
                 (let ((tail (find-tail head)))
                   (draw-text surface 320 3 (->string highlighted-title) timeline-text-color)
                   (for-each (lambda (n)
                               (when (and (>= n head)
                                          (<= n tail))
                                 (let ((time (chronological-time chronology n))
                                       (marker (chronological-marker chronology n)))
                                   (let ((h (fxround (* (/ (- time from) span) width))))
                                     (let ((color (if (even? marker) {Color Purple} {Color Red}))
                                           (v 120))
                                       (fill-rect surface (new Rect (- h 0) (- v 4) (+ h 1) (+ v 5)) color))))))
                             highlighted-markers)))))
            ((not-null? highlighted-values)
             (let ((v 110)
                   (the-evolution evolution))
               (iterate-table evolutions
                 (lambda (id evolution)
                   (let ((tier (get-tier (get-replay (current-zone))))
                         (first (first-position evolution))
                         (last (last-position evolution))
                         (the-evolution? (eq? evolution the-evolution)))
                     (define (find-head)
                       (loop (for n from first to last)
                             (when (>= (evolutionary-udp-time evolution n) from)
                               (return n))
                             (finally first)))
                     
                     (define (find-tail head)
                       (loop (for n from head to last)
                             (when (> (evolutionary-udp-time evolution n) to)
                               (return (- n 1)))
                             (finally last)))
                     
                     (let ((head (find-head)))
                       (let ((tail (find-tail head)))
                         (define (highlighted-rect time id kind)
                           (let ((h (fxround (* (/ (- time from) span) width))))
                             (let ((color (ecase id
                                            ((udp-id-create-packet) {Color Yellow})
                                            ((udp-id-nack-packet) {Color Blue})
                                            ((udp-id-insert-packet) {Color Blue})
                                            ((udp-id-duplicate-packet) {Color Orange})
                                            ((udp-id-retain-packet) {Color Dark-Gray})
                                            ((udp-id-release-packet) {Color Dark-Gray})
                                            ((udp-id-state-ok) {Color Green})
                                            ((udp-id-state-late) {Color Orange})
                                            ((udp-id-state-waiting) {Color Red})
                                            ((udp-id-reset-media) {Color Blue})
                                            (else {Color Red})))
                                   (left (- h 2))
                                   (right (+ h 3))
                                   @old!?
                                   (v (if (= kind udp-audio) 117 124)))
                               (let ((rect (new Rect left (- v 2) right (+ v 3))))
                                 (fill-rect surface rect color)
                                 (when (and now (between? now-h left right))
                                   (unless (memv? id highlighted)
                                     (set! highlighted (cons id highlighted))))))))
                         
                         (loop (for n from head to tail)
                               (for-each (lambda (highlighted)
                                           (bind (highlighted-column highlighted-value . others) highlighted
                                             (case highlighted-column
                                               ;; tier
                                               ((1)
                                                (let ((time (evolutionary-udp-time evolution n))
                                                      (id (evolutionary-udp-id evolution n))
                                                      (kind (evolutionary-udp-kind evolution n)))
                                                  ;; the -1 is a quick hack for server's #f
                                                  (when (= (or tier -1) highlighted-value)
                                                    (highlighted-rect time id kind))))
                                               ;; sequence
                                               ((5)
                                                (let ((highlighted-origin (and (not-null? others) (car others)))
                                                      (highlighted-kind (and (not-null? others) (cadr others))))
                                                  (let ((time (evolutionary-udp-time evolution n))
                                                        (origin (evolutionary-udp-origin evolution n))
                                                        (kind (evolutionary-udp-kind evolution n))
                                                        (value (evolutionary-udp-data1 evolution n)))
                                                    (when (and (= value highlighted-value)
                                                               (or (not highlighted-origin) (eqv? origin highlighted-origin))
                                                               (or (not highlighted-kind) (eqv? kind highlighted-kind)))
                                                      (let ((id (evolutionary-udp-id evolution n))
                                                            (kind (evolutionary-udp-kind evolution n)))
                                                        (highlighted-rect time id kind))))))
                                               ;; value
                                               (else
                                                (let ((time (evolutionary-udp-time evolution n)))
                                                  (let ((value (if (= highlighted-column 0)
                                                                   time
                                                                 (evolutionary-ref evolution n (- highlighted-column 1)))))
                                                    (when (= value highlighted-value)
                                                      (let ((id (evolutionary-udp-id evolution n))
                                                            (kind (evolutionary-udp-kind evolution n)))
                                                        (highlighted-rect time id kind)))))))))
                                         highlighted-values)))))
                   (increase! v 7))))))))
  
  
  (method override (right-mouse-up self evt)
    (zoom-reset self))
  
  
  (method override (view-update self)
    (let ((zone (current-zone)))
      (timeline-view/now-update zone from to #f)))
  
  
  (method override (now-update self)
    (let ((zone (current-zone)))
      (let ((update-evolution? (and (not visualize?) (not full-mode?))))
        (timeline-view/now-update zone from to now update-evolution? playing?)))))


;;;
;;;; Evolution
;;;


(class Together-Evolution-Panel extends Evolution-Panel
  
  
  (form
    (<install>
      (<border~>  border-type: solid border-color: {Color Dark-Gray})
      (<entries~> selection-handler: {Event-Handler :form on-selection-change} double-click-handler: {Event-Handler :form on-double-click})))
  
  
  (method override (form-model self form)
    (case (get-name form)
      ((header) Together-Evolution-Header)
      ((entries) Together-Evolution-Tree)
      (else (nextmethod self form))))
  
  
  (method protected (collect-entries self column)
    (if (= column 1)
        (sort ci<? (table->list names) key: cdr)
      (let ((entries (make-table test: eqv?)))
        (define (process value present)
          (unless (table-ref entries value #f)
            (let ((title (present self value)))
              (unless (empty-string? title)
                (table-set! entries value title)))))
        
        (iterate-table evolutions
          (lambda (id evolution)
            (loop (for n from (first-position evolution) to (last-position evolution))
                  (case column
                    ((2) (process (evolutionary-udp-id evolution n) present-event))
                    ((3) (process (evolutionary-udp-origin evolution n) present-origin))
                    ((4) (process (evolutionary-udp-kind evolution n) present-kind))))))
        (sort ci<? (table->list entries) key: cdr))))
  
  
  (method (on-selection-change self evt)
    (let ((zone (current-zone)))
      (let ((selection (get-selection evt)))
        (evolution-selection-update zone selection))))
  
  
  (method (on-double-click self evt)
    (let ((zone (current-zone)))
      (let ((selection (get-selection (get-sender evt))))
        (evolution-double-click zone selection)))))


(class Together-Evolution-Header extends Tree-Header
  
  
  (method override (draw-button self surface width h v title column)
    (let ((zone (current-zone)))
      (let ((root (get-root zone)))
        (let ((timeline (child root 'timeline))
              (rank (get-rank column)))
          (when (some? (lambda (highlight)
                         (= (first highlight) rank))
                       (get-highlighted-values timeline))
            (draw-highlighted surface 0 h v title #t {Color World-Red}))))))
  
  
  (method override (close-popups self (event: event #f) (all?: all? #f) (exclude: exclude #f) (initiator: initiator #f))
    (unless (memq? event '(mouse-down double-click))
      (nextmethod self event: event all?: all? exclude: exclude initiator: initiator))))


(class Together-Evolution-Tree extends Evolution-Tree
  
  
  (method override (can-copy? self)
    #t)
  
  
  (method override (copy-selection self)
    (let ((selection (get-selection self)))
      (if (null? selection)
          (bell)
        (let ((sorted-selection (sort nu<? selection)))
          (set-clipboard-text (join (map (lambda (cell) (get-cell-title self cell)) sorted-selection) " "))
          (add-clipboard (current-application))))))
  
  
  (method override (header-click self column)
    (let ((panel (find-ascendant self Together-Evolution-Panel)))
      (when (get-names panel)
        (if (alt-down?)
            (highlight-click self column)
          (filter-click self column)))))
  
  
  (method (filter-click self column)
    (let ((view (find-popup Filter-View))
          (rank (get-rank column)))
      (close-popups (get-window-manager) (current-window))
      (unless (and view (eq? (get-column view) column))
        (let ((panel (find-ascendant self Together-Evolution-Panel))
              (header (find-ascendant self Tree-Header))
              (enumerated? (between? rank 1 4)))
          (let ((entries (and enumerated? (collect-entries panel (get-rank column)))))
            (let ((view (make-filter-view self column enumerated? entries))
                  (rect (header-rect header column)))
              (popup header
                     view
                     (new Point
                       (- (get-right rect) 15)
                       (+ (get-top rect) 17)))
              (if enumerated?
                  (acquire-focus view)
                (let ((client (get-client (child view '(border scroller)))))
                  (select-all client)
                  (acquire-focus client)))))))))
  
  
  (method (highlight-click self column)
    (let ((view (find-popup Highlight-View))
          (rank (get-rank column)))
      (close-popups (get-window-manager) (current-window))
      (unless (and view (eq? (get-column view) column))
        (let ((panel (find-ascendant self Together-Evolution-Panel))
              (header (find-ascendant self Tree-Header))
              (enumerated? (between? rank 1 4)))
          (let ((entries (and enumerated? (collect-entries panel (get-rank column)))))
            (let ((view (make-highlight-view self column enumerated? entries))
                  (rect (header-rect header column)))
              (popup header
                     view
                     (new Point
                       (- (get-right rect) 15)
                       (+ (get-top rect) 17)))
              (if enumerated?
                  (acquire-focus view)
                (let ((client (get-client (child view '(border scroller)))))
                  (select-all client)
                  (acquire-focus client))))))))))


(definition (make-filter-view tree column enumerated? entries)
  (let ((view (new Filter-View
                size: {Dimension 186 300}
                background: {Color red: .000 green: .000 blue: .000 alpha: .85}
                tree: tree
                column: column
                enumerated?: enumerated?)))
    (case (column-sorting tree column)
      ((ascending) (set-checked? (child view 'ascending) #t))
      ((descending) (set-checked? (child view 'descending) #t))
      (else (set-checked? (child view 'unsorted) #t)))
    (if enumerated?
        (let ((scroller (new Scroller-View parent: view name: 'scroller position: {Point 5 120} size: {Dimension 176 144} vscroll?: #t style: 'tool)))
          (let ((content (get-content scroller)))
            (let ((v 0)
                  (values (column-filtering tree column)))
              (let ((client (new View parent: content)))
                (for-each (lambda (entry)
                            (bind (value . title) entry
                              (let ((checked? (or (not values) (member? value values))))
                                (new Filter-Label parent: client title: title position: (new Point 5 v) size: {Dimension 163 22} style: 'text background: #f color: {Color White} checked?: checked? value: value)))
                            (increase! v 20))
                          entries)
                (set-size client (new Dimension 163 (+ v 2)))
                (set-client scroller client)))))
      (let ((border (new Border-View parent: view name: 'border position: {Point 5 120} size: {Dimension 176 144} border-type: 'solid border-color: {Color Dark-Gray})))
        (let ((scroller (new Scroller-View parent: border name: 'scroller vscroll?: #t style: 'tool)))
          (let ((content (get-content scroller)))
            (let ((client (new Filter-Text parent: content background: 'none))
                  (values (column-filtering tree column)))
              (if (not values)
                  (set-string-content client "*\n")
                (unless (null? values)
                  (set-string-content client (substitute-alist '((#\( . "[") (#\) . "]")) (string-append (join (map ->string values) "\n") "\n")))))
              (set-client scroller client))))))
    view))


(class Filter-View extends Layout-View
  
  
  (property tree        initialize #f accessors generate)
  (property column      initialize #f accessors generate)
  (property enumerated? initialize #f accessors generate)
  
  
  (form
    (<install>
      (<Label-View>                   title: "Sort" font: {Font font-name: tahoma point-size: 14 shadow: thin} position: {Point 5 3} size: {Dimension 80 18} color: {Color World-Ochre})
      (<Check-Label> name: ascending  title: "Ascending" style: text background: #f position: {Point 10 23} color: {Color White} action-handler: {Event-Handler :form on-sort-ascending})
      (<Check-Label> name: descending title: "Descending" style: text background: #f position: {Point 10 43} color: {Color White} action-handler: {Event-Handler :form on-sort-descending})
      (<Check-Label> name: unsorted   title: "Unsorted" style: text background: #f position: {Point 10 63} color: {Color White} action-handler: {Event-Handler :form on-unsorted})
      (<Label-View>                   title: "Filter" font: {Font font-name: tahoma point-size: 14 shadow: thin} position: {Point 5 100} size: {Dimension 80 18} color: {Color World-Ochre})
      (<Push-Button>                  title: "All" style: text background: #f position: {Point 120 100} color: {Color red: .861 green: .081 blue: .093} action-handler: {Event-Handler :form on-filter-all})
      (<Push-Button>                  title: "None" style: text background: #f position: {Point 145 100} color: {Color red: .861 green: .081 blue: .093} action-handler: {Event-Handler :form on-filter-none})
      (<Push-Button>                  title: "OK" position: {Point 8 268} size: {Dimension 80 24} default?: #t action-handler: {Event-Handler :form on-ok})
      (<Push-Button>                  title: "Cancel" position: {Point 98 268} size: {Dimension 80 24} action-handler: {Event-Handler :form on-cancel})))
  
  
  (method override (escape-press self evt)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method override (return-press self evt)
    (apply-filter self)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method (sort-column self new-direction)
    (let ((zone (current-zone)))
      (let ((current-direction (column-sorting tree column)))
        (unless (eq? current-direction new-direction)
          (sort-column tree column new-direction sort-rows?: #f)
          (display-evolutions zone)
          (highlight-replay-value zone)))))
  
  
  (method (unsort-column self)
    (let ((zone (current-zone)))
      (unsort-columns tree sort-rows?: #f)
      (display-evolutions zone)
      (highlight-replay-value zone)))
  
  
  (method (on-sort-ascending self evt)
    (sort-column self 'ascending)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method (on-sort-descending self evt)
    (sort-column self 'descending)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method (on-unsorted self evt)
    (unsort-column self)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method (on-filter-all self evt)
    (if enumerated?
        (let ((client (get-client (child self 'scroller))))
          (for-each (lambda (label)
                      (set-checked? label #t))
                    (get-children client)))
      (let ((client (get-client (child self '(border scroller)))))
        (set-string-content client "*\n")
        (select-all client))))
  
  
  (method (on-filter-none self evt)
    (if enumerated?
        (let ((client (get-client (child self 'scroller))))
          (for-each (lambda (label)
                      (set-checked? label #f))
                    (get-children client)))
      (let ((client (get-client (child self '(border scroller)))))
        (set-string-content client "")
        (select-all client))))
  
  
  (method protected (apply-filter self)
    (let ((zone (current-zone)))
      (set-highlighted-cells (get-replay zone) '())
      (if enumerated?
          (let ((client (get-client (child self 'scroller))))
            (let ((all (get-children client)))
              (let ((checked (collect-if get-checked? all)))
                (if (= (length checked) (length all))
                    (unfilter-column tree column filter-rows?: #f)
                  (let ((values (map get-value checked)))
                    (filter-column tree column values type: 'number filter-rows?: #f))))))
        (let ((client (get-client (child self '(border scroller)))))
          (let ((content (get-string-content client)))
            (if (equal? (trim-whitespace content) "*")
                (unfilter-column tree column filter-rows?: #f)
              (let ((values (read-string-content content)))
                (filter-column tree column values type: 'number filter-rows?: #f))))))
      (display-evolutions zone)
      (highlight-replay-value zone)))
  
  
  (method (on-ok self evt)
    (apply-filter self)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method (on-cancel self evt)
    (close-popups (get-window-manager) (current-window))))


(definition (make-highlight-view tree column enumerated? entries)
  (let ((zone (current-zone)))
    (let ((root (get-root zone)))
      (let ((timeline (child root 'timeline))
            (view (new Highlight-View
                    size: {Dimension 186 300}
                    background: {Color red: .000 green: .000 blue: .000 alpha: .85}
                    tree: tree
                    column: column
                    enumerated?: enumerated?)))
        (let ((rank (get-rank column)))
          (let ((highlighted (collect-if (lambda (highlight) (= (first highlight) rank)) (get-highlighted-values timeline))))
            (if enumerated?
                (let ((scroller (new Scroller-View parent: view name: 'scroller position: {Point 5 23} size: {Dimension 176 241} vscroll?: #t style: 'tool)))
                  (let ((content (get-content scroller)))
                    (let ((v 0)
                          (values (map second highlighted)))
                      (let ((client (new View parent: content)))
                        (for-each (lambda (entry)
                                    (bind (value . title) entry
                                      (let ((checked? (or (not values) (member? value values))))
                                        (new Highlight-Label parent: client title: title position: (new Point 5 v) size: {Dimension 163 22} style: 'text background: #f color: {Color White} checked?: checked? value: value)))
                                    (increase! v 20))
                                  entries)
                        (set-size client (new Dimension 163 (+ v 2)))
                        (set-client scroller client)))))
              (set-visible? (child view 'all) #f)
              (let ((border (new Border-View parent: view name: 'border position: {Point 5 23} size: {Dimension 176 241} border-type: 'solid border-color: {Color Dark-Gray})))
                (let ((scroller (new Scroller-View parent: border name: 'scroller vscroll?: #t style: 'tool)))
                  (let ((content (get-content scroller)))
                    (let ((client (new Highlight-Text parent: content background: 'none))
                          (values (map second highlighted)))
                      (unless (null? values)
                        (set-string-content client (substitute-alist '((#\( . "[") (#\) . "]")) (string-append (join (map ->string values) "\n") "\n"))))
                      (set-client scroller client))))))
            view))))))


(class Highlight-View extends Layout-View
  
  
  (property tree        initialize #f accessors generate)
  (property column      initialize #f accessors generate)
  (property enumerated? initialize #f accessors generate)
  
  
  (form
    (<install>
      (<Label-View>             title: "Highlight" font: {Font font-name: tahoma point-size: 14 shadow: thin} position: {Point 5 3} size: {Dimension 80 18} color: {Color World-Ochre})
      (<Push-Button> name: all  title: "All" style: text background: #f position: {Point 120 3} color: {Color red: .861 green: .081 blue: .093} action-handler: {Event-Handler :form on-highlight-all})
      (<Push-Button> name: none title: "None" style: text background: #f position: {Point 145 3} color: {Color red: .861 green: .081 blue: .093} action-handler: {Event-Handler :form on-highlight-none})
      (<Push-Button>            title: "OK" position: {Point 8 268} size: {Dimension 80 24} default?: #t action-handler: {Event-Handler :form on-ok})
      (<Push-Button>            title: "Cancel" position: {Point 98 268} size: {Dimension 80 24} action-handler: {Event-Handler :form on-cancel})))
  
  
  (method override (escape-press self evt)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method override (return-press self evt)
    (apply-highlight self)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method (sort-column self new-direction)
    (let ((current-direction (column-sorting tree column)))
      (unless (eq? current-direction new-direction)
        (sort-column tree column new-direction)))
    (ensure-displayed tree))
  
  
  (method (on-sort-ascending self evt)
    (sort-column self 'ascending)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method (on-sort-descending self evt)
    (sort-column self 'descending)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method (on-unsorted self evt)
    (let ((zone (current-zone)))
      (unsort-columns tree)
      (display-evolutions zone)
      (highlight-replay-value zone)
      (close-popups (get-window-manager) (current-window))))
  
  
  (method (on-highlight-all self evt)
    (when enumerated?
      (let ((client (get-client (child self 'scroller))))
        (for-each (lambda (label)
                    (set-checked? label #t))
                  (get-children client)))))
  
  
  (method (on-highlight-none self evt)
    (if enumerated?
        (let ((client (get-client (child self 'scroller))))
          (for-each (lambda (label)
                      (set-checked? label #f))
                    (get-children client)))
      (let ((client (get-client (child self '(border scroller)))))
        (set-string-content client "")
        (select-all client))))
  
  
  (method protected (apply-highlight self)
    (let ((zone (current-zone)))
      (let ((root (get-root zone)))
        (let ((timeline (child root 'timeline)))
          (set-highlighted-cells (get-replay zone) '())
          (let ((rank (get-rank column))
                (values
                  (if enumerated?
                      (let ((client (get-client (child self 'scroller))))
                        (let ((all (get-children client)))
                          (let ((checked (collect-if get-checked? all)))
                            (map get-value checked))))
                    (let ((client (get-client (child self '(border scroller)))))
                      (let ((content (get-string-content client)))
                        (read-string-content content))))))
            (set-highlighted-values timeline (append (collect-if (lambda (highlight)
                                                                   (/= (first highlight) rank))
                                                                 (get-highlighted-values timeline))
                                                     (map (lambda (value)
                                                            (list rank value))
                                                          values)))
            (invalidate-view timeline))))))
  
  
  (method (on-ok self evt)
    (apply-highlight self)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method (on-cancel self evt)
    (close-popups (get-window-manager) (current-window))))


(class Check-Label extends Push-Button
  
  
  (property checked? initialize #f accessors explicit)


  (method public (get-checked? self)
    checked?)
  

  (method public (set-checked? self flag)
    (set! checked? flag)
    (invalidate-view self))
  
  
  (method override (process-action self sender . rest)
    (if action-handler
        (apply nextmethod self sender rest)
      (set-checked? self (not checked?))))
  
  
  (method override (draw self surface context)
    (nextmethod self surface context)
    (when checked?
      (let ((appl (current-application))
            (left 3)
            (top 4))
        (draw-image (get-images-portfolio appl) surface context {Image-Resource "CheckMarkWhite"} left top))))
  
  
  (method override (draw-text-at self surface h v title color enabled?)
    (draw-text surface (+ h 20) v title color enabled?: enabled?)))


(class Filter-Label extends Check-Label
  
  
  (property value initialize #f accessors generate))


(class Filter-Text extends World-Text-View
  
  
  (method override (new-model self)
    (new Text-Model base-style: {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin}} left-padding: 2))
  
  
  (method override (escape-press self evt)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method override (return-press self evt)
    (let ((end (get-end self)))
      (if (and (cell=? end (text-ending self))
               (= (get-col end) 0))
          (begin
            (apply-filter (find-ascendant self Filter-View))
            (close-popups (get-window-manager) (current-window)))
        (nextmethod self evt)))))


(class Highlight-Label extends Check-Label
  
  
  (property value initialize #f accessors generate))


(class Highlight-Text extends World-Text-View
  
  
  (method override (new-model self)
    (new Text-Model base-style: {Text-Style Text-Base font: {Font font-name: tahoma point-size: 15.5 shadow: thin}} left-padding: 2))
  
  
  (method override (escape-press self evt)
    (close-popups (get-window-manager) (current-window)))
  
  
  (method override (return-press self evt)
    (let ((end (get-end self)))
      (if (and (cell=? end (text-ending self))
               (= (get-col end) 0))
          (begin
            (apply-highlight (find-ascendant self Highlight-View))
            (close-popups (get-window-manager) (current-window)))
        (nextmethod self evt))))))
