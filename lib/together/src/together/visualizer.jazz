;;;============
;;;  Together
;;;============
;;;
;;;; Visualizer
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module together.visualizer jazz


(import (jazz.application)
        (jazz.clipboard)
        (jazz.component)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.handler)
        (jazz.io)
        (jazz.markup)
        (jazz.outline)
        (jazz.platform)
        (jazz.resource)
        (jazz.stream)
        (jazz.text)
        (jazz.tree)
        (jazz.ui)
        (jazz.view)
        (jazz.window)
        (gaea.geometry)
        (gaea.math)
        (world)
        (world.audio)
        (world.chronology)
        (world.client.tier)
        (world.client.udp)
        (world.context)
        (world.event)
        (world.evolution)
        (world.format)
        (world.interface.evolution)
        (world.interface.panel)
        (world.interface.replay)
        (world.interface.sheet)
        (world.interface.text)
        (world.interface.timeline)
        (world.interface.widgets)
        (world.manager)
        (world.record (phase syntax))
        (world.settings)
        (world.simulation)
        (world.time)
        (world.timeline)
        (world.visualization)
        (world.udp)
        (world.video)
        (together)
        (together.emulation)
        (together.zone))


(definition protected visualizer-text-color
  (world-setting 'world.visualizer-text {Color Dark-Gray}))


(definition protected visualizer-before <fl>
  40.)

(definition protected visualizer-after <fl>
  40.)


;;;
;;;; Panel
;;;


(class Together-Visualizer-Panel extends World-Panel
  
  
  (slot replay                initialize #f  accessors generate)
  (slot tier                  initialize #f  accessors generate)
  (slot origin-audio          initialize #f  getter generate)
  (slot origin-video          initialize #f  getter generate)
  (slot origin-evolution      initialize #f  getter generate)
  (slot server-evolution      initialize #f  getter generate)
  (slot receiver-evolution    initialize #f  getter generate)
  (slot call                  initialize #f  getter generate)
  (slot origins               initialize '() getter generate)
  (slot origin                initialize #f  getter generate)
  (slot streams               initialize #f  getter generate)
  (slot stream                initialize #f  getter generate)
  (slot stream-name           initialize #f  getter generate)
  (slot stream-label          initialize #f  getter generate)
  (slot stream-kind           initialize #f  getter generate)
  (slot channel-audio         initialize #f  getter generate)
  (slot channel-audio-codec   initialize #f  getter generate)
  (slot channel-audio-caps    initialize #f  getter generate)
  (slot channel-video         initialize #f  getter generate)
  (slot channel-video-codec   initialize #f  getter generate)
  (slot channel-video-caps    initialize #f  getter generate)
  (slot media-kinds           initialize '() getter generate)
  (slot media-kind            initialize #f  getter generate)
  (slot audio-creates         initialize #f  getter generate)
  (slot video-creates         initialize #f  getter generate)
  (slot sender-emulator       initialize #f  getter generate)
  (slot server-emulator       initialize #f  getter generate)
  (slot receiver-emulator     initialize #f  getter generate)
  (slot now                   initialize #f  getter generate)
  (slot widgets               initialize (new Widgets) getter generate)
  (slot last-now              initialize #f  accessors generate)
  (slot selection             initialize #f  accessors generate)
  (slot selection-frame       initialize #f  accessors generate)
  (slot selection-description initialize #f  accessors generate)
  
  
  (form
    (<install>                                  background: {Color red: .000 green: .000 blue: .000 alpha: .450} layout-type: fill
      (<Border-View>             name: border   border-type: solid border-color: {Color Dark-Gray}
        (<Stream-Visualizer>     name: stream
          (<Video-Visualizer>    name: video    position: {Point 218 26} size: {Dimension 182 104})
          (<Sender-Visualizer>   name: sender   position: {Point 18 26} size: {Dimension 552 24})
          (<Server-Visualizer>   name: server   position: {Point 18 66} size: {Dimension 552 24})
          (<Receiver-Visualizer> name: receiver position: {Point 18 106} size: {Dimension 552 24})))))
  
  
  (method override (conclude self initargs)
    (nextmethod self initargs)
    (set-panel (locate self 'stream) self)
    (set-panel (locate self 'video) self)
    (set-panel (locate self 'sender) self)
    (set-panel (locate self 'server) self)
    (set-panel (locate self 'receiver) self)
    (set-visualizer-render (~ render-video self)))
  
  
  (method override (destroy self)
    (close-emulators self)
    (nextmethod self))
  
  
  (method protected (setup-visualizer self)
    (setup-origins self)
    (setup-streams self)
    (setup-channels self)
    (setup-channel-rings self)
    (setup-media-kinds self)
    (setup-evolutions self)
    (setup-selection self)
    (setup-creates self)
    (setup-timeline self)
    (reset-emulators self)
    (reset-media-kind (locate self 'receiver))
    (set-%r replay)
    (set-%v self))
  
  
  (method (setup-origins self)
    (define (collect-origins)
      (let ((metadata (metadata-ref replay tier)))
        (if (= (first metadata) server-no)
            '()
          (let ((receive-streams (fourth metadata)))
            (sort nu<? (remove-duplicates (map fourth receive-streams)))))))
    
    (set! origins (collect-origins))
    (set! origin (and (not-null? origins) (car origins))))
  
  
  (method (setup-streams self)
    (define (collect-streams target-origin)
      (if (not target-origin)
          '()
        (let ((metadata (metadata-ref replay tier)))
          (if (= (first metadata) server-no)
              '()
            (let ((receive-streams (fourth metadata)))
              (sort nu<? (collect (lambda (stream)
                                    (bind (sender name no origin source-kind video-level channels) stream
                                      (and (= origin target-origin)
                                           stream)))
                                  receive-streams)
                key: second))))))
    
    (set! streams (collect-streams origin))
    (set! stream (and (not-null? streams) (car streams)))
    (set! stream-name (and stream (second stream)))
    (set! stream-label (present-stream self stream stream-name))
    (set! stream-kind (and stream (fifth stream))))
  
  
  (method (setup-channels self)
    (let ((audio #f)
          (audio-codec #f)
          (audio-caps #f)
          (video #f)
          (video-codec #f)
          (video-caps #f)
          (video-level #f))
      (when stream
        (bind (sender name no origin source-kind level channels) stream
          (for-each (lambda (channel)
                      (bind (no media-kind source-kind level resolution framerate bitrate codec caps) channel
                        (ecase media-kind
                          ((udp-audio)
                           (set! audio no)
                           (set! audio-codec codec)
                           (set! audio-caps caps))
                          ((udp-video)
                           ;; quick hack to choose the highest level
                           ;; which most of the time is the right one
                           (when (or (not video-level)
                                     (> level video-level))
                             (set! video no)
                             (set! video-codec codec)
                             (set! video-caps caps)
                             (set! video-level level))))))
                    channels)))
      (set! channel-audio audio)
      (set! channel-audio-codec audio-codec)
      (set! channel-audio-caps audio-caps)
      (set! channel-video video)
      (set! channel-video-codec video-codec)
      (set! channel-video-caps video-caps)))
  
  
  (method (setup-channel-rings self)
    (define (audio-ring)
      (and channel-audio
           (audio-ref replay channel-audio)))
    
    (define (video-ring)
      (and channel-video
           (video-ref replay channel-video)))
    
    (set! origin-audio (audio-ring))
    (set! origin-video (video-ring)))
  
  
  (method (setup-media-kinds self)
    (define (collect-media-kinds target-origin stream)
      (if (or (not target-origin)
              (not stream))
          '()
        (bind (sender name no origin source-kind video-level channels) stream
          (sort nu<? (collect (lambda (channel)
                                (bind (no media-kind) channel
                                  (and (= origin target-origin)
                                       media-kind)))
                              channels)))))
    
    (set! media-kinds (remove-duplicates (collect-media-kinds origin stream)))
    (set! media-kind (and (not-null? media-kinds) (car media-kinds))))
  
  
  (method (setup-creates self)
    (set! audio-creates (make-table test: eqv?))
    (set! video-creates (make-table test: eqv?))
    (when origin-evolution
      (loop (for create from (first-position origin-evolution) to (last-position origin-evolution))
            (when (= (evolutionary-udp-id origin-evolution create) udp-id-create-packet)
              (let ((no (flonum->fixnum (evolutionary-udp-channel origin-evolution create))))
                (when (or (eqv? no channel-audio)
                          (eqv? no channel-video))
                  (let ((kind (evolutionary-udp-kind origin-evolution create))
                        (sequence (evolutionary-udp-sequence origin-evolution create))
                        (info (+ create 1)))
                    (let ((data (let ((origin (flonum->fixnum (evolutionary-udp-origin origin-evolution create)))
                                      (kind (flonum->fixnum (evolutionary-udp-kind origin-evolution create)))
                                      (frame (evolutionary-udp-frame origin-evolution create))
                                      (part (flonum->fixnum (evolutionary-data1 origin-evolution info)))
                                      (total (flonum->fixnum (evolutionary-data2 origin-evolution info)))
                                      (flags (flonum->fixnum (evolutionary-data3 origin-evolution info)))
                                      (dts (evolutionary-udp-data3 origin-evolution create))
                                      (pts (evolutionary-udp-data4 origin-evolution create))
                                      (duration (evolutionary-data4 origin-evolution info)))
                                  (with-record media
                                    (let ((data (make-u8vector (calculate-media-size)))
                                          (nanodts (flonum->timestamp dts))
                                          (nanopts (flonum->timestamp pts))
                                          (nanoduration (flonum->timestamp duration)))
                                      (write-header-kind data kind)
                                      (write-header-sender data origin)
                                      (write-media-channel data no)
                                      (write-media-sequence data sequence)
                                      (write-media-frame data frame)
                                      (write-media-part data part)
                                      (write-media-total data total)
                                      (write-media-dts data nanodts)
                                      (write-media-pts data nanopts)
                                      (write-media-duration data nanoduration)
                                      (write-media-flags data (if (or (= flags -1) (= flags 123456)) 0 flags))
                                      (write-media-resent data 0)
                                      data)))))
                      (table-set! (if (= kind udp-audio)
                                      audio-creates
                                    video-creates)
                                  sequence
                                  data)))))))))
  
  
  (method (setup-evolutions self)
    (set! origin-evolution (and origin (evolution-ref replay origin)))
    (set! server-evolution (evolution-ref replay server-no))
    (set! receiver-evolution (evolution-ref replay tier)))
  
  
  (method (setup-selection self)
    (set! selection #f)
    (set! selection-description #f))
  
  
  (method protected (close-emulators self)
    (when sender-emulator
      (close sender-emulator)
      (set! sender-emulator #f))
    (when server-emulator
      (close server-emulator)
      (set! server-emulator #f))
    (when receiver-emulator
      (close receiver-emulator)
      (set! receiver-emulator #f)))
  
  
  ;; quicky to setup everything again
  (method protected (reset-emulators self)
    (close-emulators self)
    (if (not origin)
        (begin
          (set! call #f)
          (set! receiver-emulator #f))
      (set! call (simulate-udp-call (get-metadatas replay)))
      (set! sender-emulator (new Sender-Emulator call origin origin origin-evolution audio-creates video-creates stream-name channel-audio channel-video))
      (set! server-emulator (new Server-Emulator call server-no origin server-evolution audio-creates video-creates stream-name channel-audio channel-video))
      (set! receiver-emulator (new Receiver-Emulator call tier origin origin-audio channel-audio-codec channel-audio-caps origin-video channel-video-codec channel-video-caps origin-evolution receiver-evolution audio-creates video-creates stream-name channel-audio channel-video))
      (set-emulator (locate self 'sender) sender-emulator)
      (set-emulator (locate self 'server) server-emulator)
      (set-emulator (locate self 'receiver) receiver-emulator)
      (set! last-now #f)))
  
  
  (method protected (visualize-time self time playing?)
    (parameterize ((emulation? #t))
      (when (and origin (or (not now) (/= time now)))
        (emulate-time self time playing?)
        (set! now time)
        (invalidate-view self))))
  
  
  (method protected (emulate-time self time playing?)
    (cond ((and last-now (> time last-now))
           (emulate-from-last sender-emulator time playing?)
           (emulate-from-last server-emulator time playing?)
           (emulate-from-last receiver-emulator time playing?))
          (else
           (reset-emulators self)
           (emulate sender-emulator time playing?)
           (emulate server-emulator time playing?)
           (emulate receiver-emulator time playing?)))
    (set! last-now time))
  
  
  (method override (draw self surface context)
    (let ((left 5)
          (right (- (get-width self) 5)))
      (define (left-widget name title)
        (let ((right (+ left (draw-text surface left 3 title visualizer-text-color))))
          (add-widget widgets name (new Rect left 0 right 22))
          (set! left (+ right 20))))
      
      (define (right-widget name title)
        (let ((extent (get-text-extent surface title)))
          (let ((h (- right (get-width extent))))
            (let ((width (draw-text surface h 3 title timeline-text-color)))
              (add-widget widgets name (new Rect (- right width) 0 right 22))))))
      
      (reset widgets)
      (if (not origin)
          (left-widget 'origin "<no stream found>")
        (left-widget 'origin (format "{a}" (name-ref replay origin)))
        (if (not stream-label)
            (left-widget 'stream "<no channel found>")
          (left-widget 'stream stream-label)
          (left-widget 'media-kind (ecase media-kind
                                     ((udp-audio) "audio" @debug (format "audio ({a})" channel-audio))
                                     ((udp-video) "video" @debug (format "video ({a})" channel-video))))))
      (when selection-description
        (draw-text surface 335 3 selection-description visualizer-text-color))
      (right-widget 'metadata (format "{r precision: 1}x" visualizer-speed))))
  
  
  (method protected (render-video self)
    (let ((zone (current-zone)))
      (when (and (is? (current-space) together.replay-space:Replay-Space)
                 receiver-emulator)
        (let ((output (get-video-output receiver-emulator)))
          (when output
            (render output))))))
  
  
  (method (setup-timeline self)
    (let ((timeline (brother self 'timeline)))
      (set-origin timeline origin)
      (let ((start (evolutionary-time receiver-evolution (first-position receiver-evolution)))
            (end (evolutionary-time receiver-evolution (last-position receiver-evolution))))
        (set-visualizer-start timeline start)
        (set-visualizer-end timeline end))
      (when (get-plot-latency? timeline)
        (redraw timeline))))
  
  
  (method protected (cycle-origins self reversed?)
    (when (not-null? origins)
      (set! origin (cycle-element origins origin reversed?: reversed?))
      (setup-streams self)
      (setup-channels self)
      (setup-channel-rings self)
      (setup-media-kinds self)
      (setup-evolutions self)
      (setup-selection self)
      (setup-creates self)
      (setup-timeline self)
      (reset-emulators self)
      (when now
        (visualize-time self now #f))
      (invalidate-view self)))
  
  
  (method protected (cycle-streams self reversed?)
    (when (not-null? streams)
      (set! stream (cycle-element streams stream reversed?: reversed?))
      (set! stream-name (second stream))
      (set! stream-label (present-stream self stream stream-name))
      (set! stream-kind (fifth stream))
      (setup-channels self)
      (setup-channel-rings self)
      (setup-media-kinds self)
      (setup-evolutions self)
      (setup-selection self)
      (setup-creates self)
      (setup-timeline self)
      (reset-emulators self)
      (when now
        (visualize-time self now #f))
      (invalidate-view self)))
  
  
  (method protected (cycle-media-kinds self reversed?)
    (when (not-null? media-kinds)
      (set! media-kind (cycle-element media-kinds media-kind reversed?: reversed?))
      (reset-media-kind (locate self 'receiver))
      (setup-timeline self)
      (invalidate-view self)))
  
  
  (method (present-stream self stream stream-name)
    (and stream-name
         (let ((cut 20)
               (len (string-length stream-name)))
           (let ((effective-name (if (> len cut)
                                     (format "{a}..." (substring stream-name 0 cut))
                                   stream-name)))
             effective-name
             @debug
             (format "{a} ({a})" effective-name (third stream))))))
  
  
  (method protected (replay-simulation self)
    (together.simulation:simulate-replay origin origin-audio channel-audio-codec channel-audio-caps origin-video channel-video-codec channel-video-caps origin-evolution server-no tier))
  
  
  (method protected (extract-simulation self)
    (let ((client (current-client))
          (world (current-world)))
      (if (not receiver-evolution)
          (bell)
        (together.simulation:extract-evolution-simulation receiver-evolution)))))


;;;
;;;; Stream
;;;


(class Stream-Visualizer extends View
  
  
  (slot panel initialize #f accessors generate)
  
  
  (method override (size-change self size)
    (nextmethod self size)
    (let ((width (get-width size)))
      (set-position (child self 'video) (new Point (- width 199) 26))
      (let ((tier-size (new Dimension (- width 234) 24)))
        (set-size (child self 'sender) tier-size)
        (set-size (child self 'server) tier-size)
        (set-size (child self 'receiver) tier-size))))
  
  
  @network-visualizer
  (method override (draw self surface context)
    (let ((h 300.)
          (v 57.)
          (size 4.)
          (color {Color Blue}))
      (loop (for n from 0 below 10)
            (let ((h (+ h (* n 14.))))
              (let ((rect (new Rect$fl$ (- h size) (- v size) (+ h size) (+ v size))))
                (ellipse$fl$ surface rect color color)))))
    (let ((h 500.)
          (v 97.)
          (size 4.)
          (color {Color Blue}))
      (loop (for n from 0 below 10)
            (let ((h (+ h (* n 20.))))
              (let ((rect (new Rect$fl$ (- h size) (- v size) (+ h size) (+ v size))))
                (ellipse$fl$ surface rect color color))))))
  
  
  (method override (mouse-up self evt)
    (let ((widget (find-widget (get-widgets panel) (acquire panel self (get-position evt)))))
      (case widget
        ((origin)
         (cycle-origins panel (get-shift? evt)))
        ((stream)
         (cycle-streams panel (get-shift? evt)))
        ((media-kind)
         (cycle-media-kinds panel (get-shift? evt)))
        ((metadata)
         (pp (table-values (get-metadatas (get-replay panel)))))
        (else
         (nextmethod self evt))))))


;;;
;;;; Video
;;;


(class Video-Visualizer extends View
  
  
  (slot panel initialize #f accessors generate)
  
  
  (method override (draw self surface context)
    (let ((width (get-width size))
          (height (get-height size)))
      (let ((state-color (if (eq? (active-focus) self)
                             {Color Light-Blue alpha: .8}
                           {Color red: 180 green: 180 blue: 180 alpha: .8})))
        (frame-rect surface (new Rect 1 1 (- width 1) (- height 1)) state-color)
        (fill-rect surface (new Rect 2 2 (- width 2) (- height 2)) {Color Gray alpha: .1}))))
  
  
  (method override (focus-gained self)
    (nextmethod self)
    (invalidate-view self))
  
  
  (method override (focus-lost self)
    (nextmethod self)
    (invalidate-view self))
  
  
  (method override (mouse-down self evt)
    (when (get-replay panel)
      (acquire-focus self)))
  
  
  (method override (double-click self evt)
    (when (get-replay panel)
      (toggle-playing self)))
  
  
  (method (toggle-playing self)
    (let ((timeline (brother panel 'timeline)))
      (let ((playing? (not (get-playing? timeline))))
        @wait
        (unless (get-in-circle? (find-ascendant self Replay-Panel))
          (if playing?
              (uninstall-vista)
            (install-vista)))
        (set-playing? timeline playing?))))
  
  
  (method (toggle-full-mode self)
    (let ((world (current-world)))
      (let ((emulator (get-receiver-emulator panel))
            (timeline (brother panel 'timeline)))
        (when emulator
          (let ((output (get-video-output emulator)))
            (when output
              (let ((full-mode? (not (get-full-mode? timeline))))
                (set-full-mode? timeline full-mode?)
                (update-video-output self)
                (redraw timeline)
                (now-update timeline)
                (display-on/off world "Full mode" full-mode?))))))))
  
  
  (method protected (update-video-output self)
    (let ((world (current-world)))
      (when panel
        (let ((emulator (get-receiver-emulator panel))
              (timeline (brother panel 'timeline)))
          (when emulator
            (let ((output (get-video-output emulator)))
              (when output
                (let ((sheet (get-sheet output))
                      (full-mode? (get-full-mode? timeline)))
                  (make-orthographic-matrix! (get-projection-matrix sheet) 0. (get-width world) 0. (get-height world) 0. 10.)
                  (refresh-array/buffer sheet)
                  (cond (full-mode?
                         (let ((width (cast <fl> (- (get-width panel) 2))))
                           (let ((height (/ (* width 9.) 16.)))
                             (let ((evolution (brother panel 'evolution)))
                               (let ((position (nu+ (get-position panel) (new Point 1 (+ (get-v (get-position evolution)) (- (get-height evolution) (fxround height)) -11))))
                                     (size (new Dimension (fxround width) (fxround height))))
                                 (set-position sheet position)
                                 (set-size sheet size)
                                 (set-video-position position)
                                 (set-video-size size))))))
                        (else
                         (let ((position (nu+ (get-position panel) (new Point (- (fxround (get-width world)) 218) 29)))
                               (size {Dimension 178 100}))
                           (set-position sheet position)
                           (set-size sheet size)
                           (set-video-position position)
                           (set-video-size size))))))))))))
  
  
  (method override (key-press self evt)
    (case (get-key evt)
      ((#\space)
       (toggle-playing self))
      ((#\f)
       (toggle-full-mode self))
      ((#\r)
       (replay-simulation panel))
      ((#\s)
       (extract-simulation panel))))
  
  
  (method override (left-arrow-press self modifiers)
    (let ((timeline (brother panel 'timeline)))
      (step-backward timeline (if (shift-down?) .001 .01))))
  
  (method override (right-arrow-press self modifiers)
    (let ((timeline (brother panel 'timeline)))
      (step-forward timeline (if (shift-down?) .001 .01))))
  
  
  (method override (up-arrow-press self modifiers)
    (let ((timeline (brother panel 'timeline)))
      (play-faster timeline))
    (invalidate-view panel))
  
  (method override (down-arrow-press self modifiers)
    (let ((timeline (brother panel 'timeline)))
      (play-slower timeline))
    (invalidate-view panel)))


;;;
;;;; Tier
;;;


(class Tier-Visualizer extends View
  
  
  (slot panel initialize #f accessors generate)
  
  
  (method (draw-ring self surface left-x right-x before-x after-x span ring adds removes offset)
    (let ((replay (get-replay panel))
          (now (get-now panel))
          (selection (get-selection panel))
          (media-kind (get-media-kind panel)))
      (define (packet-color packet)
        (ecase media-kind
          ((udp-audio)
           (if (has-voice? packet)
               {Color Purple}
             {Color Blue}))
          (else
           (if (is-keyframe? packet)
               {Color Purple}
             {Color Blue}))))
      
      (when (and ring now)
        (let ((drawn (make-table test: eqv?)))
          (iterate-table-safe removes
            (lambda (sequence info)
              (bind (packet time complete?) info
                (let ((full .015))
                  (let ((age (- now time)))
                    (if (>= age full)
                        (begin
                          (table-clear adds sequence)
                          (table-clear removes sequence))
                      (with-packet self left-x right-x before-x after-x span ring offset packet
                        (lambda (selection-frame? h v)
                          (let ((size (interpolate age 0. full 4. 1.)))
                            (let ((rect (new Rect$fl$ (- h size) (- v size) (+ h size) (+ v size))))
                              (let ((frame (get-frame packet))
                                    (color (packet-color packet)))
                                (cond ((not frame)
                                       (ellipse$fl$ surface rect color #f))
                                      ((not selection-frame?)
                                       (ellipse$fl$ surface rect color (and complete? color)))
                                      (else
                                       (ellipse$fl$ surface rect color (and (get-data packet) color)))))
                              (when (and selection (eq? (get-sequence packet) selection))
                                (ellipse$fl$ surface (inflate-rect$fl$ rect 1 1) {Color White} #f))))))))))))
          (iterate-packets self left-x right-x before-x after-x span ring offset
            (lambda (index packet selection-frame? h v)
              (let ((full .015))
                (let ((added (table-ref adds (get-sequence packet) #f)))
                  ;; quick try not sure
                  (when added
                    (let ((age (- now added)))
                      (let ((size (cond ((<= age 0.) 1.)
                                        ((>= age full) 4.)
                                        (else (interpolate age 0. full 1. 4.)))))
                        (let ((rect (new Rect$fl$ (- h size) (- v size) (+ h size) (+ v size))))
                          (let ((frame (get-frame packet))
                                (color (packet-color packet)))
                            (cond ((not frame)
                                   (ellipse$fl$ surface rect color #f))
                                  ((not selection-frame?)
                                   (unless (table-ref drawn frame #f)
                                     (ellipse$fl$ surface rect color (and (visualizer-frame-complete? ring index) color))
                                     (table-set! drawn frame #t)))
                                  (else
                                   (ellipse$fl$ surface rect color (and (get-data packet) color)))))
                          (when (and selection (eq? (get-sequence packet) selection))
                            (ellipse$fl$ surface (inflate-rect$fl$ rect 1 1) {Color White} #f))))))))))))))
  
  
  (method protected virtual (ring-span self)
    )
    
  
  (method (with-boundaries self proc)
    (let ((span (ring-span self)))
      (let ((left-x 3.)
            (right-x (cast <fl> (- (get-width size) 3))))
        (let ((before-x (+ left-x visualizer-before))
              (after-x (- right-x visualizer-after)))
          (proc left-x right-x before-x after-x span)))))

  
  (method (with-packet self left-x right-x before-x after-x span ring offset packet proc)
    (let ((now (get-now panel))
          (selection-frame (get-selection-frame panel))
          (time-base (get-time-base ring)))
      (when time-base
        (let ((time (visualizer-remote->local time-base (get-dts packet)))
              (frame (get-frame packet)))
          (let ((h (interpolate now time (+ time span) before-x after-x))
                (v (+ offset 4.))
                (selection-frame? (and frame selection-frame (= frame selection-frame))))
            (define (call-proc h v)
              (let ((h (max left-x (min h right-x))))
                (proc selection-frame? h v)))
            
            (if selection-frame?
                (let ((part (get-part packet))
                      (total (get-total packet)))
                  (let ((width (- (* 10 total) 1)))
                    (let ((h (+ (- h (quotient width 2)) (* 10 part))))
                      (call-proc h v))))
              (let ((width 8))
                (let ((h (- h (quotient width 2))))
                  (call-proc h v)))))))))
  
  
  (method (iterate-packets self left-x right-x before-x after-x span ring offset proc)
    (define (collect-indexes)
      (let ((queue (new-queue)))
        (iterate-indexes ring
          (lambda (index)
            (enqueue queue index)))
        (queue-list queue)))
    
    (for-each (lambda (index)
                (let ((packet (packet-ref ring index)))
                  (with-packet self left-x right-x before-x after-x span ring offset packet
                    (lambda (selection-frame? h v)
                      (proc index packet selection-frame? h v)))))
              (collect-indexes)))
  
  
  (method (visualizer-click self h ring)
    (with-boundaries self
      (lambda (left-x right-x before-x after-x span)
        (define (find-packet h)
          (continuation-capture
            (lambda (return)
              (iterate-packets self left-x right-x before-x after-x span ring 8
                (lambda (index packet selection-frame? packet-h packet-v)
                  (when (and (>= h (- packet-h 4))
                             (<= h (+ packet-h 4)))
                    (continuation-return return packet))))
              #f)))
        
        (define (describe-packet packet)
          (format "Sequence {a}, frame {a}, part {a}, total {a}, data {a}"
                  @too-much "Keyframe {a}, dts {r precision: 3}, duration {a}, sequence {a}, frame {a}, part {a}, total {a}, data {a}"
                  @too-much (if (is-keyframe? packet) 'yes 'no)
                  @too-much (timestamp->flonum (get-dts packet))
                  @too-much (let ((duration (get-duration packet)))
                    (if (not duration)
                        (format "{a}" duration)
                      (format "{r precision: 3}" (/ duration nanosecond))))
                  (get-sequence packet)
                  (get-frame packet)
                  (get-part packet)
                  (get-total packet)
                  (if (get-data packet) 'yes 'no)))
        
        (let ((packet (find-packet h)))
          (when (neq? packet (get-selection panel))
            (set-selection panel (and packet (get-sequence packet)))
            (set-selection-frame panel (and packet (get-frame packet)))
            (set-selection-description panel (and packet (describe-packet packet)))
            (invalidate-view panel)))))))


;;;
;;;; Retain
;;;


(class Retain-Visualizer extends Tier-Visualizer
  
  
  (method (draw-retain self surface emulator)
    (when emulator
      (let ((media-kind (get-media-kind panel)))
        (when media-kind
          (let ((audio-ring (get-audio-ring emulator))
                (video-ring (get-video-ring emulator))
                (width (get-width size))
                (height (get-height size)))
            (with-boundaries self
              (lambda (left-x right-x before-x after-x span)
                (let ((before-h (fxround before-x))
                      (after-h (fxround after-x))
                      (top 3)
                      (bottom (- height 3))
                      (state-color {Color Green alpha: .8}))
                  (frame-rect surface (new Rect 1 (- top 2) (- width 1) (+ bottom 2)) state-color)
                  (frame-rect surface (new Rect 2 (- top 1) (- width 2) (+ bottom 1)) {Color Black})
                  (fill-rect surface (new Rect 3 top before-h bottom) {Color Gray alpha: .8})
                  (fill-rect surface (new Rect before-h top after-h bottom) {Color Green alpha: .8})
                  (fill-rect surface (new Rect after-h top (- width 3) bottom) {Color Red alpha: .8})
                  (ecase media-kind
                    ((udp-audio)
                     (when audio-ring
                       (draw-ring self surface left-x right-x before-x after-x span audio-ring (get-audio-adds emulator) (get-audio-removes emulator) 8)))
                    ((udp-video)
                     (when video-ring
                       (draw-ring self surface left-x right-x before-x after-x span video-ring (get-video-adds emulator) (get-video-removes emulator) 8)))))))))))))


;;;
;;;; Sender
;;;


(class Sender-Visualizer extends Retain-Visualizer
  
  
  (slot emulator initialize #f accessors generate)
  
  
  (method override (ring-span self)
    (timestamp->flonum (effective-retain-window (get-stream-kind panel))))
  
  
  (method override (draw self surface context)
    (draw-retain self surface emulator))
  
  
  (method override (mouse-up self evt)
    (let ((media-kind (get-media-kind panel)))
      (when media-kind
        (let ((h (get-h evt))
              (ring (if (= media-kind udp-audio)
                        (get-audio-ring emulator)
                      (get-video-ring emulator))))
          (visualizer-click self h ring))))))


;;;
;;;; Server
;;;


(class Server-Visualizer extends Retain-Visualizer
  
  
  (slot emulator initialize #f accessors generate)
  
  
  (method override (ring-span self)
    (timestamp->flonum (effective-retain-window (get-stream-kind panel))))
  
  
  (method override (draw self surface context)
    (draw-retain self surface emulator))
  
  
  (method override (mouse-up self evt)
    (let ((media-kind (get-media-kind panel)))
      (when media-kind
        (let ((h (get-h evt))
              (ring (if (= media-kind udp-audio)
                        (get-audio-ring emulator)
                      (get-video-ring emulator))))
          (visualizer-click self h ring))))))


;;;
;;;; Receiver
;;;


(class Receiver-Visualizer extends Tier-Visualizer
  
  
  (slot write-window  initialize #f getter generate)
  (slot late-window   initialize #f getter generate)
  (slot giveup-window initialize #f getter generate)
  (slot emulator      initialize #f accessors generate)
  
  
  (method protected (reset-media-kind self)
    (let ((media-kind (get-media-kind panel)))
      (when media-kind
        (set! write-window (timestamp->flonum (if (= media-kind udp-audio) udp-audio-process udp-video-process)))
        (set! late-window (timestamp->flonum (if (= media-kind udp-audio) udp-audio-late udp-video-late)))
        (set! giveup-window .1 @too-large (timestamp->flonum (if (= media-kind udp-audio) udp-audio-giveup udp-video-giveup))))))
  
  
  (method override (ring-span self)
    (let ((media-kind (get-media-kind panel)))
      (+ write-window late-window giveup-window)))
  
  
  (method override (draw self surface context)
    (when emulator
      (let ((media-kind (get-media-kind panel)))
        (when media-kind
          (let ((audio-ring (get-audio-ring emulator))
                (video-ring (get-video-ring emulator)))
            (let ((ring (if (= media-kind udp-audio) audio-ring video-ring)))
              (when (and media-kind ring)
                (let ((width (get-width size))
                      (height (get-height size)))
                  (with-boundaries self
                    (lambda (left-x right-x before-x after-x span)
                      (let ((total span))
                        (let ((before-h (fxround before-x))
                              (play-h (fxround (interpolate write-window 0. total before-x after-x)))
                              (freeze-h (fxround (interpolate (+ write-window late-window) 0. total before-x after-x)))
                              (after-h (fxround after-x))
                              (top 3)
                              (bottom (- height 3))
                              (state-color (case (get-state ring)
                                             ((ok) {Color Green alpha: .8})
                                             ((play) {Color Light-Blue alpha: .8})
                                             ((freeze) {Color Light-Blue alpha: .8})
                                             ((wait) {Color Red alpha: .8}))))
                          (frame-rect surface (new Rect 1 (- top 2) (- width 1) (+ bottom 2)) state-color)
                          (frame-rect surface (new Rect 2 (- top 1) (- width 2) (+ bottom 1)) {Color Black})
                          (fill-rect surface (new Rect 3 top before-h bottom) {Color Gray alpha: .8})
                          (fill-rect surface (new Rect before-h top play-h bottom) {Color Yellow alpha: .8})
                          (fill-rect surface (new Rect play-h top freeze-h bottom) {Color Green alpha: .8})
                          (fill-rect surface (new Rect freeze-h top after-h bottom) {Color Orange alpha: .8})
                          (fill-rect surface (new Rect after-h top (- width 3) bottom) {Color Red alpha: .8})
                          (ecase media-kind
                            ((udp-audio)
                             (draw-ring self surface left-x right-x before-x after-x span audio-ring (get-audio-adds emulator) (get-audio-removes emulator) 8))
                            ((udp-video)
                             (draw-ring self surface left-x right-x before-x after-x span video-ring (get-video-adds emulator) (get-video-removes emulator) 8)))))))))))))))
  
  
  (method override (mouse-up self evt)
    (let ((media-kind (get-media-kind panel)))
      (when media-kind
        (let ((h (get-h evt))
              (ring (if (= media-kind udp-audio)
                        (get-audio-ring emulator)
                      (get-video-ring emulator))))
          (visualizer-click self h ring)))))))
