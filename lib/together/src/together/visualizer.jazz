;;;============
;;;  Together
;;;============
;;;
;;;; Visualizer
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module together.visualizer jazz


(import (jazz.application)
        (jazz.clipboard)
        (jazz.component)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.handler)
        (jazz.markup)
        (jazz.outline)
        (jazz.platform)
        (jazz.resource)
        (jazz.text)
        (jazz.tree)
        (jazz.ui)
        (jazz.view)
        (jazz.window)
        (world)
        (world.chronology)
        (world.client.udp)
        (world.context)
        (world.event)
        (world.evolution)
        (world.geometry)
        (world.interface.evolution)
        (world.interface.panel)
        (world.interface.text)
        (world.interface.timeline)
        (world.manager)
        (world.settings)
        (world.simulation)
        (world.timeline)
        (world.visualization)
        (world.udp)
        (together))


(definition protected visualizer-text-color
  (world-setting 'world.visualizer-text {Color Dark-Gray}))


;;;
;;;; Panel
;;;


(class Together-Visualizer-Panel extends World-Panel
  
  
  (slot replay                initialize #f accessors generate)
  (slot tier                  initialize #f accessors generate)
  (slot origin-evolution      initialize #f getter generate)
  (slot server-evolution      initialize #f getter generate)
  (slot receiver-evolution    initialize #f getter generate)
  (slot call                  initialize #f getter generate)
  (slot client                initialize #f getter generate)
  (slot channels              initialize #f getter generate)
  (slot channel               initialize #f getter generate)
  (slot origin                initialize #f getter generate)
  (slot media-kind            initialize #f getter generate)
  (slot ring                  initialize #f getter generate)
  (slot visualizer            initialize #f getter generate)
  (slot now                   initialize #f getter generate)
  (slot selection             initialize #f accessors generate)
  (slot selection-frame       initialize #f accessors generate)
  (slot selection-description initialize #f accessors generate)
  
  
  (form
    (<install>                                background: {Color red: .000 green: .000 blue: .000 alpha: .450} layout-type: fill
      (<Border-View>            name: border  border-type: solid border-color: {Color Dark-Gray}
        (<Tier-Visualizer>      name: tier
          (<Channel-Visualizer> name: channel position: {Point 18 29} size: {Dimension 752 24})))))
  
  
  (method override (conclude self initargs)
    (nextmethod self initargs)
    (set-panel (locate self 'tier) self)
    (set-panel (locate self 'channel) self))
  
  
  (method protected (setup-visualizer self)
    (define (collect-channels)
      (let ((metadata (metadata-ref replay tier)))
        (if (= (first metadata) server-no)
            '()
          (sort nu<? (fourth metadata)))))
    
    (define (determine-channel channels)
      (and (not-null? channels)
           (car channels)))
    
    (set! channels (collect-channels))
    (let ((channel (determine-channel channels)))
      (set! origin (and channel (car channel)))
      (set! media-kind (and channel (cdr channel)))
      (set! origin-evolution (and origin (evolution-ref replay origin)))
      (set! server-evolution (evolution-ref replay server-no))
      (set! receiver-evolution (evolution-ref replay tier))
      (set! selection #f)
      (set! selection-description #f)
      (setup-timeline self)
      (set-%v self)
      (reset-visualizer self)))
  
  
  ;; quicky to setup everything again
  (method protected (reset-visualizer self)
    (if (not origin)
        (begin
          (set! call #f)
          (set! client #f)
          (set! channel #f)
          (set! ring #f)
          (set! visualizer #f))
      (set! call (parameterize ((visualization? #t))
                   (simulate-udp-call (get-names replay))))
      (set! client (require-tier call tier))
      (set! channel (find-receive-channel client origin media-kind))
      (set! ring (get-process-ring channel))
      (set! visualizer (visualize-call call client origin media-kind channel ring origin-evolution receiver-evolution)))
    (set-%c channel)
    (set-%e receiver-evolution)
    (set-%r ring))
  
  
  (method protected (visualize-time self time)
    (parameterize ((visualization? #t))
      (when origin
        (let ((last-time (get-last-time visualizer))
              (last-event (get-last-event visualizer)))
          (if (and last-time (> time last-time))
              (visualize-from visualizer (+ last-event 1) time)
            (reset-visualizer self)
            (visualize-from visualizer #f time)))
        (set! now time)
        (invalidate-view self))))
  
  
  (method override (draw self surface context)
    (if (not origin)
        (draw-text surface 5 3 "<no channel found>" visualizer-text-color)
      (draw-text surface 5 3 (format "{a} {a}" (name-ref replay origin) (udp-name media-kind)) visualizer-text-color))
    (when selection-description
      (draw-text surface 100 3 selection-description visualizer-text-color)))
  
  
  (method (setup-timeline self)
    (let ((timeline (brother self 'timeline)))
      (let ((from (evolutionary-time receiver-evolution (first-position receiver-evolution)))
            (to (evolutionary-time receiver-evolution (last-position receiver-evolution))))
        (set-visualizer-from timeline from)
        (set-visualizer-to timeline to))))
  
  
  (method protected (cycle-channels self reversed?)
    (when channel
      (let ((key (cons (get-origin channel) (get-media-kind channel))))
        (let ((new-key (if reversed?
                           (previous-element channels key test: equal?)
                         (next-element channels key test: equal?))))
          (set! origin (car new-key))
          (set! media-kind (cdr new-key))
          (set! origin-evolution (evolution-ref replay origin))
          (set! server-evolution (evolution-ref replay server-no))
          (set! receiver-evolution (evolution-ref replay tier))
          (set! selection #f)
          (set! selection-description #f)
          (setup-timeline self)
          (reset-visualizer self)
          (when now
            (visualize-time self now))
          (invalidate-view self))))))


;;;
;;;; Tier
;;;


(class Tier-Visualizer extends View
  
  
  (slot panel initialize #f accessors generate)
  
  
  (method override (mouse-up self evt)
    (let ((h (get-h evt))
          (v (get-v evt)))
      (define (in-tier?)
        (and (< v 25)
             (between? h 0 90)))
      
      (cond ((in-tier?)
             (cycle-channels panel (get-shift? evt)))
            (else
             (nextmethod self evt))))))


;;;
;;;; Channel
;;;


(class Channel-Visualizer extends View
  
  
  (slot panel initialize #f accessors generate)
  
  
  (method override (draw self surface context)
    (let ((giveup .05)
          (play-window .05)
          (channel (get-channel panel))
          (ring (get-ring panel)))
      (when channel
        (let ((total (+ giveup udp-ready-window udp-process-window))
              (width (get-width size))
              (height (get-height size)))
          (with-boundaries self
            (lambda (left-x right-x process-x)
              (let ((giveup-h (fxround (interpolate giveup 0. total left-x right-x)))
                    (freeze-h (fxround (interpolate (+ giveup udp-ready-window (- play-window)) 0. total left-x right-x)))
                    (process-h (fxround process-x))
                    (top 3)
                    (bottom (- height 3))
                    (state-color (case (get-state ring)
                                   ((ok) {Color Green alpha: .8})
                                   ((late) {Color Light-Blue alpha: .8})
                                   ((waiting) {Color Red alpha: .8}))))
                (when (eq? (active-focus) self)
                  (frame-rect surface (new Rect 0 (- top 3) width (+ bottom 3)) state-color))
                (frame-rect surface (new Rect 1 (- top 2) (- width 1) (+ bottom 2)) state-color)
                (frame-rect surface (new Rect 2 (- top 1) (- width 2) (+ bottom 1)) {Color Black})
                (fill-rect surface (new Rect 3 top giveup-h bottom) {Color Red alpha: .8})
                (fill-rect surface (new Rect giveup-h top freeze-h bottom) {Color Orange alpha: .8})
                (fill-rect surface (new Rect freeze-h top process-h bottom) {Color Green alpha: .8})
                (fill-rect surface (new Rect process-h top (- width 3) bottom) {Color Yellow alpha: .8})
                (draw-ring self surface left-x right-x process-x))))))))
  
  
  (method (draw-ring self surface left-x right-x process-x)
    (let ((replay (get-replay panel))
          (ring (get-ring panel))
          (now (get-now panel))
          (selection (get-selection panel)))
      (when (and ring now)
        (let ((base-time (get-base-time replay))
              (drawn (make-table test: eqv?)))
          (iterate-packets self left-x right-x process-x
            (lambda (index packet selection-frame? rect)
              (let ((frame (get-frame packet))
                    (header? (get-header? packet)))
                (let ((color (if header?
                                 {Color Purple}
                               {Color Blue})))
                  (cond ((not frame)
                         (frame-rect surface rect color))
                        ((not selection-frame?)
                         (unless (table-ref drawn frame #f)
                           (if (frame-complete? ring index)
                               (fill-rect surface rect color)
                             (frame-rect surface rect color))
                           (table-set! drawn frame #t)))
                        (else
                         (if (get-data packet)
                             (fill-rect surface rect color)
                           (frame-rect surface rect color))))))
              (when (and selection (eq? (get-sequence packet) selection))
                (frame-rect surface (inflate-rect rect 1 1) {Color White}))))))))
  
  
  (method (with-boundaries self proc)
    (let ((giveup .05))
      (let ((total (+ giveup udp-ready-window udp-process-window))
            (left-x 3.)
            (right-x (cast <fl> (- (get-width size) 3))))
        (let ((process-x (interpolate (+ giveup udp-ready-window) 0. total left-x right-x)))
          (proc left-x right-x process-x)))))
  
  
  (method (iterate-packets self left-x right-x process-x proc)
    (let ((ring (get-ring panel))
          (now (get-now panel))
          (selection-frame (get-selection-frame panel)))
      (define (collect-indexes)
        (let ((queue (new-queue)))
          (iterate-indexes ring
            (lambda (index)
              (enqueue queue index)))
          (queue-list queue)))
      
      (for-each (lambda (index)
                  (let ((packet (packet-ref ring index)))
                    (let ((time (+ (get-time-base ring) (get-timestamp packet) udp-process-window))
                          (frame (get-frame packet)))
                      (let ((h (fxround (interpolate now time (- time udp-process-window) process-x right-x)))
                            (v 12)
                            (min-h (fxround left-x))
                            (max-h (fxround right-x))
                            (selection-frame? (and frame selection-frame (= frame selection-frame))))
                        (define (call-proc h v)
                          (let ((h (max min-h (min h max-h))))
                            (proc index packet selection-frame? (new Rect (- h 4) (- v 4) (+ h 4) (+ v 4)))))
                        
                        (if selection-frame?
                            (let ((part (get-part packet))
                                  (total (get-total packet)))
                              (let ((width (- (* 9 total) 1)))
                                (let ((h (+ (- h (quotient width 2)) (* 9 part))))
                                  (call-proc h v))))
                          (let ((width 8))
                            (let ((h (- h (quotient width 2))))
                              (call-proc h v))))))))
                (collect-indexes))))
  
  
  (method (toggle-playing self)
    (let ((timeline (brother panel 'timeline)))
      (set-playing? timeline (not (get-playing? timeline)))))
  
  
  (method override (key-press self evt)
    (case (get-key evt)
      ((#\space)
       (toggle-playing self))))
  
  
  (method override (left-arrow-press self modifiers)
    (let ((timeline (brother panel 'timeline)))
      (step-backward timeline (if (shift-down?) .001 .01))))
  
  (method override (right-arrow-press self modifiers)
    (let ((timeline (brother panel 'timeline)))
      (step-forward timeline (if (shift-down?) .001 .01))))
  
  
  (method override (focus-gained self)
    (nextmethod self)
    (invalidate-view self))
  
  
  (method override (focus-lost self)
    (nextmethod self)
    (invalidate-view self))
  
  
  (method override (mouse-down self evt)
    (acquire-focus self))
  
  
  (method override (mouse-up self evt)
    (with-boundaries self
      (lambda (left-x right-x process-x)
        (define (find-packet h)
          (continuation-capture
            (lambda (return)
              (iterate-packets self left-x right-x process-x
                (lambda (index packet selection-frame? rect)
                  (when (and (>= h (get-left rect))
                             (<= h (get-right rect)))
                    (continuation-return return packet))))
              #f)))
        
        (define (describe-packet packet)
          (format "Header {a}, timestamp {a}, sequence {a}, frame {a}, part {a}, total {a}, data {a}"
                  (if (get-header? packet) 'yes 'no)
                  (get-timestamp packet)
                  (get-sequence packet)
                  (get-frame packet)
                  (get-part packet)
                  (get-total packet)
                  (if (get-data packet) 'yes 'no)))
        
        (acquire-focus self)
        (let ((packet (find-packet (get-h evt))))
          (when (neq? packet (get-selection panel))
            (set-selection panel (and packet (get-sequence packet)))
            (set-selection-frame panel (and packet (get-frame packet)))
            (set-selection-description panel (and packet (describe-packet packet)))
            (invalidate-view panel))))))
  
  
  (method override (double-click self evt)
    (toggle-playing self))))
