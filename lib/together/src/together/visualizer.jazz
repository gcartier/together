;;;============
;;;  Together
;;;============
;;;
;;;; Visualizer
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module together.visualizer jazz


(import (jazz.application)
        (jazz.clipboard)
        (jazz.component)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.handler)
        (jazz.markup)
        (jazz.outline)
        (jazz.platform)
        (jazz.resource)
        (jazz.text)
        (jazz.tree)
        (jazz.ui)
        (jazz.view)
        (jazz.window)
        (world)
        (world.chronology)
        (world.client.udp)
        (world.context)
        (world.event)
        (world.evolution)
        (world.geometry)
        (world.interface.evolution)
        (world.interface.panel)
        (world.interface.text)
        (world.interface.timeline)
        (world.manager)
        (world.settings)
        (world.simulation)
        (world.timeline)
        (world.visualization)
        (world.udp)
        (together))


(definition protected visualizer-text-color
  (world-setting 'world.visualizer-text {Color Dark-Gray}))


;;;
;;;; Panel
;;;


(class Together-Visualizer-Panel extends World-Panel
  
  
  (slot replay             initialize #f accessors generate)
  (slot tier               initialize #f accessors generate)
  (slot origin             initialize #f accessors generate)
  (slot media-kind         initialize #f accessors generate)
  (slot origin-evolution   initialize #f getter generate)
  (slot server-evolution   initialize #f getter generate)
  (slot receiver-evolution initialize #f getter generate)
  (slot call               initialize #f getter generate)
  (slot client             initialize #f getter generate)
  (slot channel            initialize #f getter generate)
  (slot ring               initialize #f getter generate)
  (slot visualizer         initialize #f getter generate)
  (slot now                initialize #f getter generate)
  (slot selection          initialize #f accessors generate)
  (slot description        initialize #f accessors generate)
  
  
  (form
    (<install>                          background: {Color red: .000 green: .000 blue: .000 alpha: .450} layout-type: fill
      (<Border-View>       name: border border-type: solid border-color: {Color Dark-Gray} layout-type: #f
        (<Tier-Visualizer> name: tier   position: {Point 19 30} size: {Dimension 752 24}))))
  
  
  (method override (conclude self initargs)
    (nextmethod self initargs)
    (set-panel (locate self 'tier) self))
  
  
  (method protected (setup-visualizer self)
    (define (determine-origin)
      (let ((metadata (metadata-ref replay tier)))
        (and (/= (first metadata) server-no)
             (let ((receive-channels (fourth metadata)))
               (let ((origins (collect (lambda (key)
                                         (bind (origin . media-kind) key
                                           (and (= media-kind udp-video)
                                                origin)))
                                       receive-channels)))
                 (and (not-null? origins)
                      (car origins)))))))
    
    (set! origin (determine-origin))
    (set! media-kind udp-video)
    (set! origin-evolution (and origin (evolution-ref replay origin)))
    (set! server-evolution (evolution-ref replay server-no))
    (set! receiver-evolution (evolution-ref replay tier))
    (set! selection #f)
    (set! description #f)
    (set-%v self)
    (reset-visualizer self))
  
  
  ;; quicky to setup everything again
  (method protected (reset-visualizer self)
    (if (not origin)
        (begin
          (set! call #f)
          (set! client #f)
          (set! channel #f)
          (set! ring #f)
          (set! visualizer #f))
      (set! call (parameterize ((visualization? #t))
                   (simulate-udp-call (get-names replay))))
      (set! client (require-tier call tier))
      (set! channel (find-receive-channel client origin media-kind))
      (set! ring (get-process-ring channel))
      (set! visualizer (visualize-call call client origin media-kind channel ring origin-evolution receiver-evolution)))
    (set-%c channel)
    (set-%e receiver-evolution)
    (set-%r ring))
  
  
  (method protected (visualize-time self time)
    (when origin
      (let ((last-time (get-last-time visualizer))
            (last-event (get-last-event visualizer)))
        (if (and last-time (> time last-time))
            (visualize-from visualizer (+ last-event 1) time)
          (reset-visualizer self)
          (visualize-from visualizer #f time)))
      (set! now time)
      (invalidate-view self)))
  
  
  (method override (draw self surface context)
    (if (not origin)
        (draw-text surface 5 3 "<no channel found>" visualizer-text-color)
      (draw-text surface 5 3 (format "{a} {a}" (name-ref replay origin) (udp-name media-kind)) visualizer-text-color))
    (when description
      (draw-text surface 100 3 description visualizer-text-color))))


;;;
;;;; Tier
;;;


(class Tier-Visualizer extends View
  
  
  (slot panel initialize #f accessors generate)
  
  
  (method override (draw self surface context)
    (let ((giveup .05)
          (play-window .05)
          (channel (get-channel panel))
          (ring (get-ring panel)))
      (when channel
        (let ((total (+ giveup udp-ready-window udp-process-window))
              (width (get-width size))
              (height (get-height size)))
          (with-boundaries self
            (lambda (left-x right-x process-x)
              (let ((giveup-h (fxround (interpolate giveup 0. total left-x right-x)))
                    (freeze-h (fxround (interpolate (+ giveup udp-ready-window (- play-window)) 0. total left-x right-x)))
                    (process-h (fxround process-x))
                    (top 3)
                    (bottom (- height 3))
                    (state-color (case (get-state ring)
                                   ((ok) {Color Green alpha: .8})
                                   ((late) {Color red: .005 green: .933 blue: .836 alpha: .8})
                                   ((waiting) {Color Red alpha: .8}))))
                (when (eq? (active-focus) self)
                  (frame-rect surface (new Rect 0 (- top 3) width (+ bottom 3)) state-color))
                (frame-rect surface (new Rect 1 (- top 2) (- width 1) (+ bottom 2)) state-color)
                (frame-rect surface (new Rect 2 (- top 1) (- width 2) (+ bottom 1)) {Color Black})
                (fill-rect surface (new Rect 3 top giveup-h bottom) {Color Red alpha: .8})
                (fill-rect surface (new Rect giveup-h top freeze-h bottom) {Color Orange alpha: .8})
                (fill-rect surface (new Rect freeze-h top process-h bottom) {Color Green alpha: .8})
                (fill-rect surface (new Rect process-h top (- width 3) bottom) {Color Yellow alpha: .8})
                (draw-ring self surface left-x right-x process-x))))))))
  
  
  (method (draw-ring self surface left-x right-x process-x)
    (let ((replay (get-replay panel))
          (ring (get-ring panel))
          (now (get-now panel))
          (selection (get-selection panel)))
      (when (and ring now)
        (let ((base-time (get-base-time replay)))
          (iterate-packets self left-x right-x process-x
            (lambda (packet rect)
              (let ((color (if (get-header? packet)
                               {Color Purple}
                             {Color Blue})))
                (if (get-data packet)
                    (fill-rect surface rect color)
                  (frame-rect surface rect color)))
              (when (and selection (eq? (get-sequence packet) selection))
                (frame-rect surface (inflate-rect rect 1 1) {Color White}))))))))
  
  
  (method (with-boundaries self proc)
    (let ((giveup .05))
      (let ((total (+ giveup udp-ready-window udp-process-window))
            (left-x 3.)
            (right-x (cast <fl> (- (get-width size) 3))))
        (let ((process-x (interpolate (+ giveup udp-ready-window) 0. total left-x right-x)))
          (proc left-x right-x process-x)))))
  
  
  (method (collect-packets self)
    (let ((ring (get-ring panel))
          (queue (new-queue)))
      (iterate-earliest ring
        (lambda (packet)
          (enqueue queue packet)))
      (queue-list queue)))
  
  
  (method (iterate-packets self left-x right-x process-x proc)
    (let ((ring (get-ring panel))
          (now (get-now panel)))
      ;; quick hack around update-time called after insert
      (when (get-time-base ring)
        (for-each (lambda (packet)
                    (let ((time (+ (get-time-base ring) (get-timestamp packet) udp-process-window))
                          (frame (get-frame packet)))
                      (let ((h (fxround (interpolate now time (- time udp-process-window) process-x right-x)))
                            (v 12))
                        (if (not frame)
                            (let ((width 8))
                              (let ((h (- h (quotient width 2))))
                                (proc packet (new Rect (- h 4) (- v 4) (+ h 4) (+ v 4)))))
                          (let ((part (get-part packet))
                                (total (get-total packet)))
                            (let ((width (- (* 9 total) 1)))
                              (let ((h (+ (- h (quotient width 2)) (* 9 part))))
                                (proc packet (new Rect (- h 4) (- v 4) (+ h 4) (+ v 4))))))))))
                  (collect-packets self)))))
  
  
  (method override (key-press self evt)
    (case (get-key evt)
      ((#\space)
       (let ((timeline (brother panel 'timeline)))
         (set-playing? timeline (not (get-playing? timeline)))))))
  
  
  (method override (left-arrow-press self modifiers)
    (let ((timeline (brother panel 'timeline)))
      (step-backward timeline (if (shift-down?) .001 .01))))
  
  (method override (right-arrow-press self modifiers)
    (let ((timeline (brother panel 'timeline)))
      (step-forward timeline (if (shift-down?) .001 .01))))
  
  
  (method override (focus-gained self)
    (nextmethod self)
    (invalidate-view self))
  
  
  (method override (focus-lost self)
    (nextmethod self)
    (invalidate-view self))
  
  
  (method override (mouse-down self evt)
    (acquire-focus self))
  
  
  (method override (mouse-up self evt)
    (with-boundaries self
      (lambda (left-x right-x process-x)
        (define (find-packet h)
          (continuation-capture
            (lambda (return)
              (iterate-packets self left-x right-x process-x
                (lambda (packet rect)
                  (when (and (>= h (get-left rect))
                             (< h (get-right rect)))
                    (continuation-return return packet))))
              #f)))
        
        (define (describe-packet packet)
          (format "Header {a}, timestamp {a}, sequence {a}, frame {a}, part {a}, total {a}, data {a}"
                  (if (get-header? packet) 'yes 'no)
                  (get-timestamp packet)
                  (get-sequence packet)
                  (get-frame packet)
                  (get-part packet)
                  (get-total packet)
                  (if (get-data packet) 'yes 'no)))
        
        (acquire-focus self)
        (let ((packet (find-packet (get-h evt))))
          (when (neq? packet (get-selection panel))
            (set-selection panel (and packet (get-sequence packet)))
            (set-description panel (and packet (describe-packet packet)))
            (invalidate-view panel))))))))
