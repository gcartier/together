;;;============
;;;  Together
;;;============
;;;
;;;; Visualizer
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module together.visualizer jazz


(import (jazz.application)
        (jazz.clipboard)
        (jazz.component)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.handler)
        (jazz.markup)
        (jazz.outline)
        (jazz.platform)
        (jazz.resource)
        (jazz.stream)
        (jazz.text)
        (jazz.tree)
        (jazz.ui)
        (jazz.view)
        (jazz.window)
        (world)
        (world.audio)
        (world.chronology)
        (world.client.udp)
        (world.context)
        (world.event)
        (world.evolution)
        (world.geometry)
        (world.interface.evolution)
        (world.interface.panel)
        (world.interface.replay)
        (world.interface.text)
        (world.interface.timeline)
        (world.manager)
        (world.math)
        (world.settings)
        (world.simulation)
        (world.time)
        (world.timeline)
        (world.visualization)
        (world.udp)
        (world.video)
        (together)
        (together.emulation)
        (together.zone))


(definition protected visualizer-text-color
  (world-setting 'world.visualizer-text {Color Dark-Gray}))

(definition protected visualizer-after
  (world-setting 'world.visualizer-after .05))

(definition protected visualizer-before
  (world-setting 'world.visualizer-before .05))


;;;
;;;; Panel
;;;


(class Together-Visualizer-Panel extends World-Panel
  
  
  (slot replay                initialize #f  accessors generate)
  (slot tier                  initialize #f  accessors generate)
  (slot origin-audio          initialize #f  getter generate)
  (slot origin-video          initialize #f  getter generate)
  (slot origin-evolution      initialize #f  getter generate)
  (slot server-evolution      initialize #f  getter generate)
  (slot receiver-evolution    initialize #f  getter generate)
  (slot call                  initialize #f  getter generate)
  (slot origins               initialize '() getter generate)
  (slot origin                initialize #f  getter generate)
  (slot streams               initialize #f  getter generate)
  (slot stream                initialize #f  getter generate)
  (slot stream-name           initialize #f  getter generate)
  (slot stream-label          initialize #f  getter generate)
  (slot channel-audio         initialize #f  getter generate)
  (slot channel-audio-caps    initialize #f  getter generate)
  (slot channel-video         initialize #f  getter generate)
  (slot media-kinds           initialize '() getter generate)
  (slot media-kind            initialize #f  getter generate)
  (slot audio-creates         initialize #f  getter generate)
  (slot video-creates         initialize #f  getter generate)
  (slot sender-emulator       initialize #f  getter generate)
  (slot server-emulator       initialize #f  getter generate)
  (slot receiver-emulator     initialize #f  getter generate)
  (slot now                   initialize #f  getter generate)
  (slot last-now              initialize #f  accessors generate)
  (slot selection             initialize #f  accessors generate)
  (slot selection-frame       initialize #f  accessors generate)
  (slot selection-description initialize #f  accessors generate)
  
  
  (form
    (<install>                                  background: {Color red: .000 green: .000 blue: .000 alpha: .450} layout-type: fill
      (<Border-View>             name: border   border-type: solid border-color: {Color Dark-Gray}
        (<Stream-Visualizer>     name: stream
          (<Video-Visualizer>    name: video    position: {Point 18 26} size: {Dimension 182 104})
          (<Sender-Visualizer>   name: sender   position: {Point 218 26} size: {Dimension 552 24})
          (<Server-Visualizer>   name: server   position: {Point 218 66} size: {Dimension 552 24})
          (<Receiver-Visualizer> name: receiver position: {Point 218 106} size: {Dimension 552 24})))))
  
  
  (method override (conclude self initargs)
    (nextmethod self initargs)
    (set-panel (locate self 'stream) self)
    (set-panel (locate self 'video) self)
    (set-panel (locate self 'sender) self)
    (set-panel (locate self 'server) self)
    (set-panel (locate self 'receiver) self)
    (set-visualizer-render (~ render-video self)))
  
  
  (method override (destroy self)
    (close-emulators self)
    (nextmethod self))
  
  
  (method protected (setup-visualizer self)
    (setup-origins self)
    (setup-streams self)
    (setup-channels self)
    (setup-channel-rings self)
    (setup-media-kinds self)
    (setup-evolutions self)
    (setup-selection self)
    (setup-creates self)
    (setup-timeline self)
    (reset-emulators self)
    (reset-media-kind (locate self 'receiver))
    (set-%r replay)
    (set-%v self))
  
  
  (method (setup-origins self)
    (define (collect-origins)
      (let ((metadata (metadata-ref replay tier)))
        (if (= (first metadata) server-no)
            '()
          (let ((receive-streams (fourth metadata)))
            (sort nu<? (remove-duplicates (map fourth receive-streams)))))))
    
    (set! origins (collect-origins))
    (set! origin (and (not-null? origins) (car origins))))
  
  
  (method (setup-streams self)
    (define (collect-streams target-origin)
      (if (not target-origin)
          '()
        (let ((metadata (metadata-ref replay tier)))
          (if (= (first metadata) server-no)
              '()
            (let ((receive-streams (fourth metadata)))
              (sort nu<? (collect (lambda (stream)
                                    (bind (sender name no origin source-kind video-level channels) stream
                                      (and (= origin target-origin)
                                           stream)))
                                  receive-streams)
                key: second))))))
    
    (set! streams (collect-streams origin))
    (set! stream (and (not-null? streams) (car streams)))
    (set! stream-name (and stream (second stream)))
    (set! stream-label (present-stream self stream stream-name)))
  
  
  (method (setup-channels self)
    (let ((audio #f)
          (audio-caps #f)
          (video #f)
          (video-level #f))
      (when stream
        (bind (sender name no origin source-kind level channels) stream
          (for-each (lambda (channel)
                      (bind (no media-kind source-kind level resolution framerate bitrate codec caps) channel
                        (ecase media-kind
                          ((udp-audio)
                           (set! audio no)
                           (set! audio-caps caps))
                          ((udp-video)
                           ;; quick hack to choose the highest level
                           ;; which most of the time is the right one
                           (when (or (not video-level)
                                     (> level video-level))
                             (set! video no)
                             (set! video-level level))))))
                    channels)))
      (set! channel-audio audio)
      (set! channel-audio-caps audio-caps)
      (set! channel-video video)))
  
  
  (method (setup-channel-rings self)
    (define (audio-ring)
      (and channel-audio
           (audio-ref replay channel-audio)))
    
    (define (video-ring)
      (and channel-video
           (video-ref replay channel-video)))
    
    (set! origin-audio (audio-ring))
    (set! origin-video (video-ring)))
  
  
  (method (setup-media-kinds self)
    (define (collect-media-kinds target-origin stream)
      (if (or (not target-origin)
              (not stream))
          '()
        (bind (sender name no origin source-kind video-level channels) stream
          (sort nu<? (collect (lambda (channel)
                                (bind (no media-kind) channel
                                  (and (= origin target-origin)
                                       media-kind)))
                              channels)))))
    
    (set! media-kinds (remove-duplicates (collect-media-kinds origin stream)))
    (set! media-kind (and (not-null? media-kinds) (car media-kinds))))
  
  
  (method (setup-creates self)
    (define (locate-info create kind sequence)
      (loop (for info from (+ create 1) to (last-position origin-evolution))
            (when (and (= (evolutionary-udp-id origin-evolution info) udp-id-create-info)
                       (= (evolutionary-udp-kind origin-evolution info) kind)
                       (= (evolutionary-udp-sequence origin-evolution info) sequence))
              (return info))
            (finally #f)))
    
    (set! audio-creates (make-table test: eqv?))
    (set! video-creates (make-table test: eqv?))
    (when origin-evolution
      (loop (for create from (first-position origin-evolution) to (last-position origin-evolution))
            (when (= (evolutionary-udp-id origin-evolution create) udp-id-create-packet)
              (let ((no (flonum->fixnum (evolutionary-udp-channel origin-evolution create))))
                (when (or (eqv? no channel-audio)
                          (eqv? no channel-video))
                  (let ((kind (evolutionary-udp-kind origin-evolution create))
                        (sequence (evolutionary-udp-sequence origin-evolution create)))
                    (let ((info (locate-info create kind sequence)))
                      (when info
                        (let ((data (let ((origin (flonum->fixnum (evolutionary-udp-origin origin-evolution create)))
                                          (kind (flonum->fixnum (evolutionary-udp-kind origin-evolution create)))
                                          (frame (evolutionary-udp-frame origin-evolution create))
                                          (part (flonum->fixnum (evolutionary-udp-data2 origin-evolution info)))
                                          (total (flonum->fixnum (evolutionary-udp-data3 origin-evolution info)))
                                          (keyframe? (= (evolutionary-udp-data3 origin-evolution create) 123456.))
                                          (dts (evolutionary-udp-data4 origin-evolution create))
                                          (pts (evolutionary-udp-data5 origin-evolution create))
                                          (duration (evolutionary-udp-data4 origin-evolution info)))
                                      (let ((data (make-u8vector (udp-media-header-size)))
                                            (nanodts (flonum->timestamp dts))
                                            (nanopts (flonum->timestamp pts))
                                            (nanoduration (flonum->timestamp duration)))
                                        (write-udp-kind data kind)
                                        (write-udp-sender data origin)
                                        (write-udp-channel data no)
                                        (write-udp-sequence data sequence)
                                        (write-udp-frame data frame)
                                        (write-udp-part data part)
                                        (write-udp-total data total)
                                        (write-udp-media-dts data nanodts)
                                        (write-udp-media-pts data nanopts)
                                        (write-udp-media-duration data nanoduration)
                                        (write-udp-media-keyframe? data keyframe?)
                                        (write-udp-media-off? data #f)
                                        (write-udp-resent data 0)
                                        data))))
                          (table-set! (if (= kind udp-audio)
                                          audio-creates
                                        video-creates)
                                      sequence
                                      data)))))))))))
  
  
  (method (setup-evolutions self)
    (set! origin-evolution (and origin (evolution-ref replay origin)))
    (set! server-evolution (evolution-ref replay server-no))
    (set! receiver-evolution (evolution-ref replay tier)))
  
  
  (method (setup-selection self)
    (set! selection #f)
    (set! selection-description #f))
  
  
  (method (close-emulators self)
    (when sender-emulator
      (close sender-emulator))
    (when server-emulator
      (close server-emulator))
    (when receiver-emulator
      (close receiver-emulator)))
  
  
  ;; quicky to setup everything again
  (method protected (reset-emulators self)
    (close-emulators self)
    (if (not origin)
        (begin
          (set! call #f)
          (set! receiver-emulator #f))
      (set! call (simulate-udp-call (get-metadatas replay)))
      (set! sender-emulator (new Sender-Emulator call origin origin origin-evolution audio-creates video-creates stream-name channel-audio channel-video))
      (set! server-emulator (new Server-Emulator call server-no origin server-evolution audio-creates video-creates stream-name channel-audio channel-video))
      (set! receiver-emulator (new Receiver-Emulator call tier origin origin-audio channel-audio-caps origin-video origin-evolution receiver-evolution audio-creates video-creates stream-name channel-audio channel-video))
      (set-emulator (locate self 'sender) sender-emulator)
      (set-emulator (locate self 'server) server-emulator)
      (set-emulator (locate self 'receiver) receiver-emulator)
      (set! last-now #f)))
  
  
  (method protected (visualize-time self time playing?)
    (parameterize ((emulation? #t))
      (when (and origin (or (not now) (/= time now)))
        (emulate-time self time playing?)
        (set! now time)
        (invalidate-view self))))
  
  
  (method protected (emulate-time self time playing?)
    (cond ((and last-now (> time last-now))
           (emulate-from-last sender-emulator time playing?)
           (emulate-from-last server-emulator time playing?)
           (emulate-from-last receiver-emulator time playing?))
          (else
           (reset-emulators self)
           (emulate sender-emulator time playing?)
           (emulate server-emulator time playing?)
           (emulate receiver-emulator time playing?)))
    (set! last-now time))
  
  
  (method override (draw self surface context)
    (if (not origin)
        (draw-text surface 5 3 "<no stream found>" visualizer-text-color)
      (draw-text surface 5 3 (format "{a}" (name-ref replay origin)) visualizer-text-color)
      (if (not stream-label)
          (draw-text surface 80 3 "<no channel found>" visualizer-text-color)
        (draw-text surface 80 3 stream-label visualizer-text-color)
        (draw-text surface 255 3 (ecase media-kind
                                   ((udp-audio) "audio" @debug (format "audio ({a})" channel-audio))
                                   ((udp-video) "video" @debug (format "video ({a})" channel-video)))
          visualizer-text-color)))
    (when selection-description
      (draw-text surface 335 3 selection-description visualizer-text-color))
    (let ((title (format "{r precision: 1}x" visualizer-speed)))
      (let ((width (get-width self))
            (extent (get-text-extent surface title)))
        (draw-text surface (- width (get-width extent) 5) 3 title timeline-text-color))))
  
  
  (method protected (render-video self)
    (let ((zone (current-zone)))
      (when (and (is? zone together.gathering:Gathering-Zone)
                 (eq? (get-stage zone) 'replay)
                 receiver-emulator)
        (let ((output (get-video-output receiver-emulator)))
          (when output
            (render output))))))
  
  
  (method (setup-timeline self)
    (let ((timeline (brother self 'timeline)))
      (set-origin timeline origin)
      (let ((start (evolutionary-time receiver-evolution (first-position receiver-evolution)))
            (end (evolutionary-time receiver-evolution (last-position receiver-evolution))))
        (set-visualizer-start timeline start)
        (set-visualizer-end timeline end))
      (when graph-latency?
        (invalidate-view timeline))))
  
  
  (method protected (cycle-origins self reversed?)
    (when (not-null? origins)
      (set! origin (cycle-element origins origin reversed?: reversed?))
      (setup-streams self)
      (setup-channels self)
      (setup-channel-rings self)
      (setup-media-kinds self)
      (setup-evolutions self)
      (setup-selection self)
      (setup-creates self)
      (setup-timeline self)
      (reset-emulators self)
      (when now
        (visualize-time self now #f))
      (invalidate-view self)))
  
  
  (method protected (cycle-streams self reversed?)
    (when (not-null? streams)
      (set! stream (cycle-element streams stream reversed?: reversed?))
      (set! stream-name (second stream))
      (set! stream-label (present-stream self stream stream-name))
      (setup-channels self)
      (setup-channel-rings self)
      (setup-media-kinds self)
      (setup-evolutions self)
      (setup-selection self)
      (setup-creates self)
      (setup-timeline self)
      (reset-emulators self)
      (when now
        (visualize-time self now #f))
      (invalidate-view self)))
  
  
  (method protected (cycle-media-kinds self reversed?)
    (when (not-null? media-kinds)
      (set! media-kind (cycle-element media-kinds media-kind reversed?: reversed?))
      (reset-media-kind (locate self 'receiver))
      (setup-timeline self)
      (invalidate-view self)))
  
  
  (method (present-stream self stream stream-name)
    (and stream-name
         (let ((cut 20)
               (len (string-length stream-name)))
           (let ((effective-name (if (> len cut)
                                     (format "{a}..." (substring stream-name 0 cut))
                                   stream-name)))
             effective-name
             @debug
             (format "{a} ({a})" effective-name (third stream))))))
  
  
  (method protected (replay-simulation self)
    (together.simulation:simulate-replay origin origin-audio channel-audio-caps origin-video origin-evolution server-no tier)))


;;;
;;;; Stream
;;;


(class Stream-Visualizer extends View
  
  
  (slot panel initialize #f accessors generate)
  
  
  @network-visualizer
  (method override (draw self surface context)
    (let ((h 300.)
          (v 57.)
          (size 4.)
          (color {Color Blue}))
      (loop (for n from 0 below 10)
            (let ((h (+ h (* n 14.))))
              (let ((rect (new Rect$fl$ (- h size) (- v size) (+ h size) (+ v size))))
                (ellipse$fl$ surface rect color color)))))
    (let ((h 500.)
          (v 97.)
          (size 4.)
          (color {Color Blue}))
      (loop (for n from 0 below 10)
            (let ((h (+ h (* n 20.))))
              (let ((rect (new Rect$fl$ (- h size) (- v size) (+ h size) (+ v size))))
                (ellipse$fl$ surface rect color color))))))
  
  
  (method override (mouse-up self evt)
    (let ((h (get-h evt))
          (v (get-v evt)))
      (define (in-origin?)
        (and (< v 25)
             (between? h 0 65)))
      
      (define (in-stream?)
        (and (< v 25)
             (between? h 65 245)))
      
      (define (in-media-kind?)
        (and (< v 25)
             (between? h 245 320)))
      
      (define (in-metadata?)
        (and (< v 25)
             (let ((width (get-width self)))
               (between? h (- width 50) width))))
      
      (cond ((in-origin?)
             (cycle-origins panel (get-shift? evt)))
            ((in-stream?)
             (cycle-streams panel (get-shift? evt)))
            ((in-media-kind?)
             (cycle-media-kinds panel (get-shift? evt)))
            ((in-metadata?)
             (pp (table-values (get-metadatas (get-replay panel)))))
            (else
             (nextmethod self evt))))))


;;;
;;;; Video
;;;


(class Video-Visualizer extends View
  
  
  (slot panel initialize #f accessors generate)
  
  
  (method override (draw self surface context)
    (let ((width (get-width size))
          (height (get-height size)))
      (let ((state-color (if (eq? (active-focus) self)
                             {Color Light-Blue alpha: .8}
                           {Color red: 180 green: 180 blue: 180 alpha: .8})))
        (frame-rect surface (new Rect 1 1 (- width 1) (- height 1)) state-color)
        (fill-rect surface (new Rect 2 2 (- width 2) (- height 2)) {Color Gray alpha: .1}))))
  
  
  (method override (focus-gained self)
    (nextmethod self)
    (invalidate-view self))
  
  
  (method override (focus-lost self)
    (nextmethod self)
    (invalidate-view self))
  
  
  (method override (mouse-down self evt)
    (when (get-replay panel)
      (acquire-focus self)))
  
  
  (method override (double-click self evt)
    (when (get-replay panel)
      (toggle-playing self)))
  
  
  (method (toggle-playing self)
    (let ((timeline (brother panel 'timeline)))
      (let ((playing? (not (get-playing? timeline))))
        (unless (get-in-circle? (find-ascendant self Replay-Panel))
          (if playing?
              (uninstall-camera)
            (install-camera)))
        (set-playing? timeline playing?))))
  
  
  (method (toggle-full-mode self)
    (let ((world (current-world)))
      (let ((emulator (get-receiver-emulator panel))
            (timeline (brother panel 'timeline)))
        (when emulator
          (let ((output (get-video-output emulator)))
            (when output
              (let ((full-mode? (not (get-full-mode? timeline))))
                (set-full-mode? timeline full-mode?)
                (update-video-output self)
                (redraw timeline)
                (now-update timeline)
                (display-on/off world "Full mode" full-mode?))))))))
  
  
  (method protected (update-video-output self)
    (let ((world (current-world)))
      (when panel
        (let ((emulator (get-receiver-emulator panel))
              (timeline (brother panel 'timeline)))
          (when emulator
            (let ((output (get-video-output emulator)))
              (when output
                (let ((sheet (get-sheet output))
                      (full-mode? (get-full-mode? timeline)))
                  (make-orthographic-matrix! (get-projection-matrix sheet) 0. (get-width world) 0. (get-height world) 0. 10.)
                  (cond (full-mode?
                         (let ((width (cast <fl> (- (get-width panel) 2))))
                           (let ((height (/ (* width 9.) 16.)))
                             (let ((evolution (brother panel 'evolution)))
                               (let ((position (nu+ (get-position panel) (new Point 1 (+ (get-v (get-position evolution)) (- (get-height evolution) (fxround height)) -11))))
                                     (size (new Dimension (fxround width) (fxround height))))
                                 (set-position sheet position)
                                 (set-size sheet size)
                                 (set-video-position position)
                                 (set-video-size size))))))
                        (else
                         (let ((position (nu+ (get-position panel) {Point 21 29}))
                               (size {Dimension 178 100}))
                           (set-position sheet position)
                           (set-size sheet size)
                           (set-video-position position)
                           (set-video-size size))))))))))))
  
  
  (method override (key-press self evt)
    (case (get-key evt)
      ((#\space)
       (toggle-playing self))
      ((#\f)
       (toggle-full-mode self))
      ((#\r)
       (replay-simulation panel))))
  
  
  (method override (left-arrow-press self modifiers)
    (let ((timeline (brother panel 'timeline)))
      (step-backward timeline (if (shift-down?) .001 .01))))
  
  (method override (right-arrow-press self modifiers)
    (let ((timeline (brother panel 'timeline)))
      (step-forward timeline (if (shift-down?) .001 .01))))
  
  
  (method override (up-arrow-press self modifiers)
    (let ((timeline (brother panel 'timeline)))
      (play-faster timeline))
    (invalidate-view panel))
  
  (method override (down-arrow-press self modifiers)
    (let ((timeline (brother panel 'timeline)))
      (play-slower timeline))
    (invalidate-view panel)))


;;;
;;;; Tier
;;;


(class Tier-Visualizer extends View
  
  
  (slot panel initialize #f accessors generate)
  
  
  (method (draw-ring self surface left-x right-x after-x before-x span ring adds removes offset)
    (let ((replay (get-replay panel))
          (now (get-now panel))
          (selection (get-selection panel)))
      (when (and ring now)
        (let ((base-time (get-base-time replay))
              (drawn (make-table test: eqv?)))
          (iterate-table-safe removes
            (lambda (sequence info)
              (bind (packet time complete?) info
                (let ((full .015))
                  (let ((age (- now time)))
                    (if (>= age full)
                        (begin
                          (table-clear adds sequence)
                          (table-clear removes sequence))
                      (with-packet self left-x right-x after-x before-x span ring offset packet
                        (lambda (selection-frame? h v)
                          (let ((size (interpolate age 0. full 4. 1.)))
                            (let ((rect (new Rect$fl$ (- h size) (- v size) (+ h size) (+ v size))))
                              (let ((frame (get-frame packet))
                                    (keyframe? (get-keyframe? packet)))
                                (let ((color (if keyframe?
                                                 {Color Purple}
                                               {Color Blue})))
                                  (cond ((not frame)
                                         (ellipse$fl$ surface rect color #f))
                                        ((not selection-frame?)
                                         (ellipse$fl$ surface rect color (and complete? color)))
                                        (else
                                         (ellipse$fl$ surface rect color (and (get-data packet) color))))))
                              (when (and selection (eq? (get-sequence packet) selection))
                                (ellipse$fl$ surface (inflate-rect$fl$ rect 1 1) {Color White} #f))))))))))))
          (iterate-packets self left-x right-x after-x before-x span ring offset
            (lambda (index packet selection-frame? h v)
              (let ((full .015))
                (let ((age (- now (table-ref adds (get-sequence packet) #f))))
                  (let ((size (cond ((<= age 0.) 1.)
                                    ((>= age full) 4.)
                                    (else (interpolate age 0. full 1. 4.)))))
                    (let ((rect (new Rect$fl$ (- h size) (- v size) (+ h size) (+ v size))))
                      (let ((frame (get-frame packet))
                            (keyframe? (get-keyframe? packet)))
                        (let ((color (if keyframe?
                                         {Color Purple}
                                       {Color Blue})))
                          (cond ((not frame)
                                 (ellipse$fl$ surface rect color #f))
                                ((not selection-frame?)
                                 (unless (table-ref drawn frame #f)
                                   (ellipse$fl$ surface rect color (and (frame-complete? ring index) color))
                                   (table-set! drawn frame #t)))
                                (else
                                 (ellipse$fl$ surface rect color (and (get-data packet) color))))))
                      (when (and selection (eq? (get-sequence packet) selection))
                        (ellipse$fl$ surface (inflate-rect$fl$ rect 1 1) {Color White} #f))))))))))))
  
  
  (method protected virtual (ring-span self)
    )
    
  
  (method (with-boundaries self proc)
    (let ((span (ring-span self)))
      (let ((total (+ visualizer-after span visualizer-before))
            (left-x 3.)
            (right-x (cast <fl> (- (get-width size) 3))))
        (let ((after-x (interpolate visualizer-after 0. total left-x right-x))
              (before-x (interpolate (+ visualizer-after span) 0. total left-x right-x)))
          (proc left-x right-x after-x before-x span)))))

  
  (method (with-packet self left-x right-x after-x before-x span ring offset packet proc)
    (let ((now (get-now panel))
          (selection-frame (get-selection-frame panel))
          (time-base (get-time-base ring)))
      (when time-base
        (let ((time (remote->local time-base (get-dts packet)))
              (frame (get-frame packet)))
          (let ((h (interpolate now (+ time span) time after-x before-x))
                (v (+ offset 4.))
                (selection-frame? (and frame selection-frame (= frame selection-frame))))
            (define (call-proc h v)
              (let ((h (max left-x (min h right-x))))
                (proc selection-frame? h v)))
            
            (if selection-frame?
                (let ((part (get-part packet))
                      (total (get-total packet)))
                  (let ((width (- (* 10 total) 1)))
                    (let ((h (+ (- h (quotient width 2)) (* 10 part))))
                      (call-proc h v))))
              (let ((width 8))
                (let ((h (- h (quotient width 2))))
                  (call-proc h v)))))))))
  
  
  (method (iterate-packets self left-x right-x after-x before-x span ring offset proc)
    (define (collect-indexes)
      (let ((queue (new-queue)))
        (iterate-indexes ring
          (lambda (index)
            (enqueue queue index)))
        (queue-list queue)))
    
    (for-each (lambda (index)
                (let ((packet (packet-ref ring index)))
                  (with-packet self left-x right-x after-x before-x span ring offset packet
                    (lambda (selection-frame? h v)
                      (proc index packet selection-frame? h v)))))
              (collect-indexes)))
  
  
  (method (visualizer-click self h ring)
    (with-boundaries self
      (lambda (left-x right-x after-x before-x span)
        (define (find-packet h)
          (continuation-capture
            (lambda (return)
              (iterate-packets self left-x right-x after-x before-x span ring 8
                (lambda (index packet selection-frame? packet-h packet-v)
                  (when (and (>= h (- packet-h 4))
                             (<= h (+ packet-h 4)))
                    (continuation-return return packet))))
              #f)))
        
        (define (describe-packet packet)
          (format @too-much "Keyframe {a}, dts {r precision: 3}, duration {a}, sequence {a}, frame {a}, part {a}, total {a}, data {a}"
                  "Sequence {a}, frame {a}, part {a}, total {a}, data {a}"
                  @too-much (if (get-keyframe? packet) 'yes 'no)
                  @too-much (get-dts packet)
                  @too-much (let ((duration (get-duration packet)))
                    (if (not duration)
                        (format "{a}" duration)
                      (format "{r precision: 3}" (/ duration nanosecond))))
                  (get-sequence packet)
                  (get-frame packet)
                  (get-part packet)
                  (get-total packet)
                  (if (get-data packet) 'yes 'no)))
        
        (let ((packet (find-packet h)))
          (when (neq? packet (get-selection panel))
            (set-selection panel (and packet (get-sequence packet)))
            (set-selection-frame panel (and packet (get-frame packet)))
            (set-selection-description panel (and packet (describe-packet packet)))
            (invalidate-view panel)))))))


;;;
;;;; Retain
;;;


(class Retain-Visualizer extends Tier-Visualizer
  
  
  (method (draw-retain self surface emulator)
    (when emulator
      (let ((media-kind (get-media-kind panel)))
        (when media-kind
          (let ((audio-ring (get-audio-ring emulator))
                (video-ring (get-video-ring emulator)))
            (let ((ring (if (= media-kind udp-audio) audio-ring video-ring)))
              (when ring
                (let ((width (get-width size))
                      (height (get-height size)))
                  (with-boundaries self
                    (lambda (left-x right-x after-x before-x span)
                      (let ((total (+ visualizer-after span visualizer-before)))
                        (let ((after-h (fxround after-x))
                              (before-h (fxround before-x))
                              (top 3)
                              (bottom (- height 3))
                              (state-color {Color Green alpha: .8}))
                          (frame-rect surface (new Rect 1 (- top 2) (- width 1) (+ bottom 2)) state-color)
                          (frame-rect surface (new Rect 2 (- top 1) (- width 2) (+ bottom 1)) {Color Black})
                          (fill-rect surface (new Rect 3 top after-h bottom) {Color Red alpha: .8})
                          (fill-rect surface (new Rect after-h top before-h bottom) {Color Green alpha: .8})
                          (fill-rect surface (new Rect before-h top (- width 3) bottom) {Color Gray alpha: .8})
                          (ecase media-kind
                            ((udp-audio)
                             (draw-ring self surface left-x right-x after-x before-x span audio-ring (get-audio-adds emulator) (get-audio-removes emulator) 8))
                            ((udp-video)
                             (draw-ring self surface left-x right-x after-x before-x span video-ring (get-video-adds emulator) (get-video-removes emulator) 8))))))))))))))))


;;;
;;;; Sender
;;;


(class Sender-Visualizer extends Retain-Visualizer
  
  
  (slot emulator initialize #f accessors generate)
  
  
  (method override (ring-span self)
    udp-sender-retain-window)
  
  
  (method override (draw self surface context)
    (draw-retain self surface emulator))
  
  
  (method override (mouse-up self evt)
    (let ((media-kind (get-media-kind panel)))
      (when media-kind
        (let ((h (get-h evt))
              (ring (if (= media-kind udp-audio)
                        (get-audio-ring emulator)
                      (get-video-ring emulator))))
          (visualizer-click self h ring))))))


;;;
;;;; Server
;;;


(class Server-Visualizer extends Retain-Visualizer
  
  
  (slot emulator initialize #f accessors generate)
  
  
  (method override (ring-span self)
    udp-server-retain-window)
  
  
  (method override (draw self surface context)
    (draw-retain self surface emulator))
  
  
  (method override (mouse-up self evt)
    (let ((media-kind (get-media-kind panel)))
      (when media-kind
        (let ((h (get-h evt))
              (ring (if (= media-kind udp-audio)
                        (get-audio-ring emulator)
                      (get-video-ring emulator))))
          (visualizer-click self h ring))))))


;;;
;;;; Receiver
;;;


(class Receiver-Visualizer extends Tier-Visualizer
  
  
  (slot giveup-window initialize #f getter generate)
  (slot late-window   initialize #f getter generate)
  (slot emulator      initialize #f accessors generate)
  
  
  (method protected (reset-media-kind self)
    (let ((media-kind (get-media-kind panel)))
      (when media-kind
        (set! giveup-window (if (= media-kind udp-audio) udp-audio-giveup udp-video-giveup))
        (set! late-window (if (= media-kind udp-audio) 0. udp-video-late)))))
  
  
  (method override (ring-span self)
    (let ((media-kind (get-media-kind panel)))
      (+ giveup-window (if (= media-kind udp-audio)
                           udp-audio-process-window
                         udp-video-process-window))))
  
  
  (method override (draw self surface context)
    (when emulator
      (let ((media-kind (get-media-kind panel)))
        (when media-kind
          (let ((audio-ring (get-audio-ring emulator))
                (video-ring (get-video-ring emulator)))
            (let ((ring (if (= media-kind udp-audio) audio-ring video-ring)))
              (when (and media-kind ring)
                (let ((width (get-width size))
                      (height (get-height size)))
                  (with-boundaries self
                    (lambda (left-x right-x after-x before-x span)
                      (let ((total (+ visualizer-after span visualizer-before)))
                        (let ((after-h (fxround after-x))
                              (freeze-h (fxround (interpolate (+ visualizer-after giveup-window (- late-window)) 0. total left-x right-x)))
                              (present-h (fxround (interpolate (+ visualizer-after giveup-window) 0. total left-x right-x)))
                              (before-h (fxround before-x))
                              (top 3)
                              (bottom (- height 3))
                              (state-color (case (get-state ring)
                                             ((ok) {Color Green alpha: .8})
                                             ((late) {Color Light-Blue alpha: .8})
                                             ((waiting) {Color Red alpha: .8}))))
                          (frame-rect surface (new Rect 1 (- top 2) (- width 1) (+ bottom 2)) state-color)
                          (frame-rect surface (new Rect 2 (- top 1) (- width 2) (+ bottom 1)) {Color Black})
                          (fill-rect surface (new Rect 3 top after-h bottom) {Color Red alpha: .8})
                          (fill-rect surface (new Rect after-h top freeze-h bottom) {Color Orange alpha: .8})
                          (fill-rect surface (new Rect freeze-h top present-h bottom) {Color Green alpha: .8})
                          (fill-rect surface (new Rect present-h top before-h bottom) {Color Yellow alpha: .8})
                          (fill-rect surface (new Rect before-h top (- width 3) bottom) {Color Gray alpha: .8})
                          (ecase media-kind
                            ((udp-audio)
                             (draw-ring self surface left-x right-x after-x before-x span audio-ring (get-audio-adds emulator) (get-audio-removes emulator) 8))
                            ((udp-video)
                             (draw-ring self surface left-x right-x after-x before-x span video-ring (get-video-adds emulator) (get-video-removes emulator) 8)))))))))))))))
  
  
  (method override (mouse-up self evt)
    (let ((media-kind (get-media-kind panel)))
      (when media-kind
        (let ((h (get-h evt))
              (ring (if (= media-kind udp-audio)
                        (get-audio-ring emulator)
                      (get-video-ring emulator))))
          (visualizer-click self h ring)))))))
