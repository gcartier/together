;;;============
;;;  Together
;;;============
;;;
;;;; Visualizer
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module together.visualizer jazz


(import (jazz.application)
        (jazz.clipboard)
        (jazz.component)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.handler)
        (jazz.markup)
        (jazz.outline)
        (jazz.platform)
        (jazz.resource)
        (jazz.stream)
        (jazz.text)
        (jazz.tree)
        (jazz.ui)
        (jazz.view)
        (jazz.window)
        (world)
        (world.audio)
        (world.chronology)
        (world.client.udp)
        (world.context)
        (world.event)
        (world.evolution)
        (world.geometry)
        (world.interface.evolution)
        (world.interface.panel)
        (world.interface.text)
        (world.interface.timeline)
        (world.manager)
        (world.settings)
        (world.simulation)
        (world.timeline)
        (world.visualization)
        (world.udp)
        (world.video)
        (together)
        (together.emulation))


(definition protected visualizer-text-color
  (world-setting 'world.visualizer-text {Color Dark-Gray}))

(definition protected visualizer-after
  (world-setting 'world.visualizer-after .05))

(definition protected visualizer-before
  (world-setting 'world.visualizer-before .1))


;;;
;;;; Panel
;;;


(class Together-Visualizer-Panel extends World-Panel
  
  
  (slot replay                initialize #f accessors generate)
  (slot tier                  initialize #f accessors generate)
  (slot origin-audio          initialize #f getter generate)
  (slot origin-audio-header   initialize #f getter generate)
  (slot origin-video          initialize #f getter generate)
  (slot origin-evolution      initialize #f getter generate)
  (slot server-evolution      initialize #f getter generate)
  (slot receiver-evolution    initialize #f getter generate)
  (slot call                  initialize #f getter generate)
  (slot origins               initialize #f getter generate)
  (slot origin                initialize #f getter generate)
  (slot media-kind            initialize #f getter generate)
  (slot giveup-window         initialize #f getter generate)
  (slot late-window           initialize #f getter generate)
  (slot emulator              initialize #f getter generate)
  (slot now                   initialize #f getter generate)
  (slot selection             initialize #f accessors generate)
  (slot selection-frame       initialize #f accessors generate)
  (slot selection-description initialize #f accessors generate)
  
  
  (form
    (<install>                                  background: {Color red: .000 green: .000 blue: .000 alpha: .450} layout-type: fill
      (<Border-View>             name: border   border-type: solid border-color: {Color Dark-Gray}
        (<Stream-Visualizer>     name: stream
          (<Video-Visualizer>    name: video    position: {Point 26 30} size: {Dimension 164 94})
          (<Sender-Visualizer>   name: sender   position: {Point 218 25} size: {Dimension 552 24})
          (<Server-Visualizer>   name: server   position: {Point 218 65} size: {Dimension 552 24})
          (<Receiver-Visualizer> name: receiver position: {Point 218 105} size: {Dimension 552 24})))))
  
  
  (method override (conclude self initargs)
    (nextmethod self initargs)
    (set-panel (locate self 'stream) self)
    (set-panel (locate self 'video) self)
    (set-panel (locate self 'sender) self)
    (set-panel (locate self 'server) self)
    (set-panel (locate self 'receiver) self)
    (set-visualizer-render (~ render-video self)))
  
  
  (method protected (setup-visualizer self)
    (define (collect-origins)
      (let ((metadata (metadata-ref replay tier)))
        (if (= (first metadata) server-no)
            '()
          (sort nu<? (remove-duplicates (map car (fourth metadata)))))))
    
    (define (setup-audio)
      (when origin
        (let ((info (audio-ref replay origin)))
          (when info
            (bind (ring header) info
              (set! origin-audio ring)
              (set! origin-audio-header header))))))
    
    (define (setup-video)
      (when origin
        (let ((info (video-ref replay origin)))
          (when info
            (bind (ring header) info
              (set! origin-video ring))))))
    
    (set! origins (collect-origins))
    (set! origin (and (not-null? origins) (car origins)))
    (set! media-kind udp-video)
    (set! origin-evolution (and origin (evolution-ref replay origin)))
    (set! server-evolution (evolution-ref replay server-no))
    (set! receiver-evolution (evolution-ref replay tier))
    (set! selection #f)
    (set! selection-description #f)
    (setup-audio)
    (setup-video)
    (setup-timeline self)
    (reset-media-kind self)
    (reset-emulator self)
    (set-%r replay)
    (set-%v self))
  
  
  (method protected (reset-media-kind self)
    (set! giveup-window (if (= media-kind udp-audio) udp-audio-giveup udp-video-giveup))
    (set! late-window (if (= media-kind udp-audio) 0. udp-video-late)))
  
  
  ;; quicky to setup everything again
  (method protected (reset-emulator self)
    (if (not origin)
        (begin
          (set! call #f)
          (set! emulator #f))
      (set! call (simulate-udp-call (get-names replay)))
      (set! emulator (new Receiver-Emulator call tier origin origin-audio origin-audio-header origin-video origin-evolution receiver-evolution))
      (set-emulator (locate self 'receiver) emulator)))
  
  
  (method protected (visualize-time self time)
    (parameterize ((emulation? #t))
      (when origin
        (emulate-time self time)
        (set! now time)
        (invalidate-view self))))
  
  
  (method protected (emulate-time self time)
    (let ((last-time (get-last-time emulator))
          (last-event (get-last-event emulator)))
      (if (and last-time (> time last-time))
          (visualize-from emulator (+ last-event 1) time)
        (reset-emulator self)
        (visualize-from emulator #f time))))
  
  
  (method override (draw self surface context)
    (if (not origin)
        (draw-text surface 5 3 "<no channel found>" visualizer-text-color)
      (draw-text surface 5 3 (format "{a} {a}" (name-ref replay origin) (udp-name media-kind)) visualizer-text-color))
    (when selection-description
      (draw-text surface 100 3 selection-description visualizer-text-color))
    (let ((title (format "{r precision: 1}x" visualizer-speed)))
      (let ((width (get-width self))
            (extent (get-text-extent surface title)))
        (draw-text surface (- width (get-width extent) 5) 3 title timeline-text-color))))
  
  
  (method protected (render-video self)
    (let ((zone (current-zone)))
      (when (and (is? zone together.community:Community-Zone)
                 (eq? (get-stage zone) 'replay)
                 emulator)
        (let ((output (get-video-output emulator)))
          (when output
            (render output))))))
  
  
  (method (setup-timeline self)
    (let ((timeline (brother self 'timeline)))
      (let ((start (evolutionary-time receiver-evolution (first-position receiver-evolution)))
            (end (evolutionary-time receiver-evolution (last-position receiver-evolution))))
        (set-visualizer-start timeline start)
        (set-visualizer-end timeline end))))
  
  
  (method protected (cycle-origins self reversed?)
    (set! media-kind (if (= media-kind udp-audio) udp-video udp-audio))
    (reset-media-kind self)
    (invalidate-view self)
    @wait
    (when origin
      (set! origin (cycle-element origins origin reversed?: reversed?))
      (set! origin-evolution (evolution-ref replay origin))
      (set! server-evolution (evolution-ref replay server-no))
      (set! receiver-evolution (evolution-ref replay tier))
      (set! selection #f)
      (set! selection-description #f)
      (setup-timeline self)
      (reset-emulator self)
      (when now
        (visualize-time self now))
      (invalidate-view self))))


;;;
;;;; Stream
;;;


(class Stream-Visualizer extends View
  
  
  (slot panel initialize #f accessors generate)
  
  
  (method override (draw self surface context)
    (let ((h 300.)
          (v 57.)
          (size 4.)
          (color {Color Blue}))
      (loop (for n from 0 below 10)
            (let ((h (+ h (* n 14.))))
              (let ((rect (new Rect$fl$ (- h size) (- v size) (+ h size) (+ v size))))
                (ellipse$fl$ surface rect color color)))))
    (let ((h 500.)
          (v 97.)
          (size 4.)
          (color {Color Blue}))
      (loop (for n from 0 below 10)
            (let ((h (+ h (* n 20.))))
              (let ((rect (new Rect$fl$ (- h size) (- v size) (+ h size) (+ v size))))
                (ellipse$fl$ surface rect color color))))))
  
  
  (method override (mouse-up self evt)
    (let ((h (get-h evt))
          (v (get-v evt)))
      (define (in-tier?)
        (and (< v 25)
             (between? h 0 90)))
      
      (cond ((in-tier?)
             (cycle-origins panel (get-shift? evt)))
            (else
             (nextmethod self evt))))))


;;;
;;;; Video
;;;


(class Video-Visualizer extends View
  
  
  (slot panel initialize #f accessors generate)
  
  
  (method override (draw self surface context)
    (let ((width (get-width size))
          (height (get-height size)))
      (let ((state-color {Color Light-Blue alpha: .8}))
        (when (eq? (active-focus) self)
          (frame-rect surface (new Rect 0 0 width height) state-color))
        (frame-rect surface (new Rect 1 1 (- width 1) (- height 1)) state-color)
        (fill-rect surface (new Rect 2 2 (- width 2) (- height 2)) {Color Gray alpha: .1}))))
  
  
  (method override (focus-gained self)
    (nextmethod self)
    (invalidate-view self))
  
  
  (method override (focus-lost self)
    (nextmethod self)
    (invalidate-view self))
  
  
  (method override (mouse-down self evt)
    (acquire-focus self))
  
  
  (method override (double-click self evt)
    (toggle-playing self))
  
  
  (method (toggle-playing self)
    (let ((timeline (brother panel 'timeline)))
      (let ((playing? (not (get-playing? timeline))))
        (set-playing? timeline playing?))))
  
  
  (method (toggle-full-mode self)
    (let ((world (current-world)))
      (let ((emulator (get-emulator panel))
            (timeline (brother panel 'timeline)))
        (let ((full-mode? (not (get-full-mode? timeline)))
              (sheet (get-sheet (get-video-output emulator))))
          (set-full-mode? timeline full-mode?)
          (cond (full-mode?
                 (let ((width (cast <fl> (- (get-width panel) 2))))
                   (let ((height (/ (* width 9.) 16.)))
                     (let ((evolution (brother panel 'evolution)))
                       (let ((position (new Point 156 (+ (get-v (get-position evolution)) (- (get-height evolution) (fxround height)) -1)))
                             (size (new Dimension (fxround width) (fxround height))))
                         (set-position sheet position)
                         (set-size sheet size)
                         (set-video-position position)
                         (set-video-size size))))))
                (else
                 (let ((position {Point 184 43})
                       (size {Dimension 160 90}))
                   (set-position sheet position)
                   (set-size sheet size)
                   (set-video-position position)
                   (set-video-size size))))
          (redraw timeline)
          (now-update timeline)
          (display-on/off world "Full mode" full-mode?)))))
  
  
  (method override (key-press self evt)
    (case (get-key evt)
      ((#\space)
       (toggle-playing self))
      ((#\f)
       (toggle-full-mode self))))
  
  
  (method override (left-arrow-press self modifiers)
    (let ((timeline (brother panel 'timeline)))
      (step-backward timeline (if (shift-down?) .001 .01))))
  
  (method override (right-arrow-press self modifiers)
    (let ((timeline (brother panel 'timeline)))
      (step-forward timeline (if (shift-down?) .001 .01))))
  
  
  (method override (up-arrow-press self modifiers)
    (let ((timeline (brother panel 'timeline)))
      (play-faster timeline))
    (invalidate-view panel))
  
  (method override (down-arrow-press self modifiers)
    (let ((timeline (brother panel 'timeline)))
      (play-slower timeline))
    (invalidate-view panel)))


;;;
;;;; Tier
;;;


(class Tier-Visualizer extends View
  
  
  (slot panel initialize #f accessors generate))


;;;
;;;; Sender
;;;


(class Sender-Visualizer extends Tier-Visualizer
  
  
  (method override (draw self surface context)
    (let ((width (get-width size))
          (height (get-height size)))
      (let ((top 3)
            (bottom (- height 3))
            (state-color {Color Light-Blue alpha: .8}))
        (frame-rect surface (new Rect 1 (- top 2) (- width 1) (+ bottom 2)) state-color)
        (frame-rect surface (new Rect 2 (- top 1) (- width 2) (+ bottom 1)) {Color Black})
        (fill-rect surface (new Rect 3 (- top 0) (- width 3) (+ bottom 0)) {Color Green alpha: .8})))))


;;;
;;;; Server
;;;


(class Server-Visualizer extends Tier-Visualizer
  
  
  (method override (draw self surface context)
    (let ((width (get-width size))
          (height (get-height size)))
      (let ((top 3)
            (bottom (- height 3))
            (state-color {Color Green alpha: .8}))
        (frame-rect surface (new Rect 1 (- top 2) (- width 1) (+ bottom 2)) state-color)
        (frame-rect surface (new Rect 2 (- top 1) (- width 2) (+ bottom 1)) {Color Black})
        (fill-rect surface (new Rect 3 (- top 0) (- width 3) (+ bottom 0)) {Color Yellow alpha: .8})))))


;;;
;;;; Receiver
;;;


(class Receiver-Visualizer extends Tier-Visualizer
  
  
  (slot emulator initialize #f accessors generate)
  
  
  (method override (draw self surface context)
    (let ((media-kind (get-media-kind panel))
          (audio-ring (get-audio-ring emulator))
          (video-ring (get-video-ring emulator))
          (giveup-window (get-giveup-window panel))
          (late-window (get-late-window panel))
          (emulator (get-emulator panel)))
      (when (and audio-ring video-ring)
        (let ((total (+ visualizer-after giveup-window udp-process-window visualizer-before))
              (width (get-width size))
              (height (get-height size)))
          (with-boundaries self
            (lambda (left-x right-x present-x before-x)
              (let ((after-h (fxround (interpolate visualizer-after 0. total left-x right-x)))
                    (freeze-h (fxround (interpolate (+ visualizer-after giveup-window (- late-window)) 0. total left-x right-x)))
                    (present-h (fxround present-x))
                    (before-h (fxround (interpolate (+ visualizer-after giveup-window udp-process-window) 0. total left-x right-x)))
                    (top 3)
                    (bottom (- height 3))
                    (state-color (case (get-state video-ring)
                                   ((ok) {Color Green alpha: .8})
                                   ((late) {Color Light-Blue alpha: .8})
                                   ((waiting) {Color Red alpha: .8}))))
                (frame-rect surface (new Rect 1 (- top 2) (- width 1) (+ bottom 2)) state-color)
                (frame-rect surface (new Rect 2 (- top 1) (- width 2) (+ bottom 1)) {Color Black})
                (fill-rect surface (new Rect 3 top after-h bottom) {Color Red alpha: .8})
                (fill-rect surface (new Rect after-h top freeze-h bottom) {Color Orange alpha: .8})
                (fill-rect surface (new Rect freeze-h top present-h bottom) {Color Green alpha: .8})
                (fill-rect surface (new Rect present-h top before-h bottom) {Color Yellow alpha: .8})
                (fill-rect surface (new Rect before-h top (- width 3) bottom) {Color Gray alpha: .8})
                (ecase media-kind
                  ((udp-audio)
                   (draw-ring self surface left-x right-x present-x before-x audio-ring (get-audio-adds emulator) (get-audio-removes emulator) 8))
                  ((udp-video)
                   (draw-ring self surface left-x right-x present-x before-x video-ring (get-video-adds emulator) (get-video-removes emulator) 8))))))))))
  
  
  (method (draw-ring self surface left-x right-x present-x before-x ring adds removes offset)
    (let ((replay (get-replay panel))
          (now (get-now panel))
          (selection (get-selection panel)))
      (when (and ring now)
        (let ((base-time (get-base-time replay))
              (drawn (make-table test: eqv?)))
          (iterate-table-safe removes
            (lambda (sequence info)
              (bind (packet time complete?) info
                (let ((full .015))
                  (let ((age (- now time)))
                    (if (>= age full)
                        (begin
                          (table-clear adds sequence)
                          (table-clear removes sequence))
                      (with-packet self left-x right-x present-x before-x ring offset packet
                        (lambda (selection-frame? h v)
                          (let ((size (interpolate age 0. full 4. 1.)))
                            (let ((rect (new Rect$fl$ (- h size) (- v size) (+ h size) (+ v size))))
                              (let ((frame (get-frame packet))
                                    (header? (get-header? packet)))
                                (let ((color (if header?
                                                 {Color Purple}
                                               {Color Blue})))
                                  (cond ((not frame)
                                         (ellipse$fl$ surface rect color #f))
                                        ((not selection-frame?)
                                         (ellipse$fl$ surface rect color (and complete? color)))
                                        (else
                                         (ellipse$fl$ surface rect color (and (get-data packet) color))))))
                              (when (and selection (eq? (get-sequence packet) selection))
                                (ellipse$fl$ surface (inflate-rect$fl$ rect 1 1) {Color White} #f))))))))))))
          (iterate-packets self left-x right-x present-x before-x ring offset
            (lambda (index packet selection-frame? h v)
              (let ((full .015))
                (let ((age (- now (table-ref adds (get-sequence packet) #f))))
                  (let ((size (cond ((<= age 0.) 1.)
                                    ((>= age full) 4.)
                                    (else (interpolate age 0. full 1. 4.)))))
                    (let ((rect (new Rect$fl$ (- h size) (- v size) (+ h size) (+ v size))))
                      (let ((frame (get-frame packet))
                            (header? (get-header? packet)))
                        (let ((color (if header?
                                         {Color Purple}
                                       {Color Blue})))
                          (cond ((not frame)
                                 (ellipse$fl$ surface rect color #f))
                                ((not selection-frame?)
                                 (unless (table-ref drawn frame #f)
                                   (ellipse$fl$ surface rect color (and (frame-complete? ring index) color))
                                   (table-set! drawn frame #t)))
                                (else
                                 (ellipse$fl$ surface rect color (and (get-data packet) color))))))
                      (when (and selection (eq? (get-sequence packet) selection))
                        (ellipse$fl$ surface (inflate-rect$fl$ rect 1 1) {Color White} #f))))))))))))
  
  
  (method (with-boundaries self proc)
    (let ((giveup-window (get-giveup-window panel)))
      (let ((total (+ visualizer-after giveup-window udp-process-window visualizer-before))
            (left-x 3.)
            (right-x (cast <fl> (- (get-width size) 3))))
        (let ((present-x (interpolate (+ visualizer-after giveup-window) 0. total left-x right-x))
              (before-x (interpolate (+ visualizer-after giveup-window udp-process-window) 0. total left-x right-x)))
          (proc left-x right-x present-x before-x)))))
  
  
  (method (with-packet self left-x right-x present-x before-x ring offset packet proc)
    (let ((now (get-now panel))
          (selection-frame (get-selection-frame panel))
          (time-base (get-time-base ring)))
      ;; quick test
      (when time-base
        (let ((time (+ time-base (get-timestamp packet)))
            (frame (get-frame packet)))
        (let ((h (interpolate now (+ time udp-process-window) time present-x before-x))
              (v (+ offset 4.))
              (selection-frame? (and frame selection-frame (= frame selection-frame))))
          (define (call-proc h v)
            (let ((h (max left-x (min h right-x))))
              (proc selection-frame? h v)))
          
          (if selection-frame?
              (let ((part (get-part packet))
                    (total (get-total packet)))
                (let ((width (- (* 10 total) 1)))
                  (let ((h (+ (- h (quotient width 2)) (* 10 part))))
                    (call-proc h v))))
            (let ((width 8))
              (let ((h (- h (quotient width 2))))
                (call-proc h v)))))))))
  
  
  (method (iterate-packets self left-x right-x present-x before-x ring offset proc)
    (define (collect-indexes)
      (let ((queue (new-queue)))
        (iterate-indexes ring
          (lambda (index)
            (enqueue queue index)))
        (queue-list queue)))
    
    (for-each (lambda (index)
                (let ((packet (packet-ref ring index)))
                  (with-packet self left-x right-x present-x before-x ring offset packet
                    (lambda (selection-frame? h v)
                      (proc index packet selection-frame? h v)))))
              (collect-indexes)))
  
  
  (method override (mouse-up self evt)
    (let ((ring (if (= (get-media-kind panel) udp-audio) (get-audio-ring emulator) (get-video-ring emulator))))
      (with-boundaries self
        (lambda (left-x right-x present-x before-x)
          (define (find-packet h)
            (continuation-capture
              (lambda (return)
                (iterate-packets self left-x right-x present-x before-x ring 8
                  (lambda (index packet selection-frame? packet-h packet-v)
                    (when (and (>= h (- packet-h 4))
                               (<= h (+ packet-h 4)))
                      (continuation-return return packet))))
                #f)))
          
          (define (describe-packet packet)
            (format "Header {a}, timestamp {r precision: 3}, duration {r precision: 3}, sequence {a}, frame {a}, part {a}, total {a}, data {a}"
                    (if (get-header? packet) 'yes 'no)
                    (get-timestamp packet)
                    (/ (get-duration packet) nanosecond)
                    (get-sequence packet)
                    (get-frame packet)
                    (get-part packet)
                    (get-total packet)
                    (if (get-data packet) 'yes 'no)))
          
          (let ((packet (find-packet (get-h evt))))
            (when (neq? packet (get-selection panel))
              (set-selection panel (and packet (get-sequence packet)))
              (set-selection-frame panel (and packet (get-frame packet)))
              (set-selection-description panel (and packet (describe-packet packet)))
              (invalidate-view panel)))))))))
