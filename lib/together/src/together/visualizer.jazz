;;;============
;;;  Together
;;;============
;;;
;;;; Visualizer
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module together.visualizer jazz


(import (jazz.application)
        (jazz.clipboard)
        (jazz.component)
        (jazz.event)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.handler)
        (jazz.markup)
        (jazz.outline)
        (jazz.platform)
        (jazz.resource)
        (jazz.text)
        (jazz.tree)
        (jazz.ui)
        (jazz.view)
        (jazz.window)
        (world)
        (world.chronology)
        (world.client.udp)
        (world.context)
        (world.event)
        (world.evolution)
        (world.geometry)
        (world.interface.evolution)
        (world.interface.panel)
        (world.interface.text)
        (world.interface.timeline)
        (world.manager)
        (world.settings)
        (world.simulation)
        (world.timeline)
        (world.visualization)
        (world.udp)
        (together))


(definition protected visualizer-text-color
  (world-setting 'world.visualizer-text {Color Dark-Gray}))

(definition protected visualizer-after
  (world-setting 'world.visualizer-after .05))

(definition protected visualizer-before
  (world-setting 'world.visualizer-before .1))


;;;
;;;; Panel
;;;


(class Together-Visualizer-Panel extends World-Panel
  
  
  (slot replay                initialize #f accessors generate)
  (slot tier                  initialize #f accessors generate)
  (slot origin-evolution      initialize #f getter generate)
  (slot server-evolution      initialize #f getter generate)
  (slot receiver-evolution    initialize #f getter generate)
  (slot call                  initialize #f getter generate)
  (slot client                initialize #f getter generate)
  (slot channels              initialize #f getter generate)
  (slot channel               initialize #f getter generate)
  (slot origin                initialize #f getter generate)
  (slot media-kind            initialize #f getter generate)
  (slot ring                  initialize #f getter generate)
  (slot visualizer            initialize #f getter generate)
  (slot now                   initialize #f getter generate)
  (slot selection             initialize #f accessors generate)
  (slot selection-frame       initialize #f accessors generate)
  (slot selection-description initialize #f accessors generate)
  
  
  (form
    (<install>                                background: {Color red: .000 green: .000 blue: .000 alpha: .450} layout-type: fill
      (<Border-View>            name: border  border-type: solid border-color: {Color Dark-Gray}
        (<Tier-Visualizer>      name: tier
          (<Channel-Visualizer> name: channel position: {Point 18 29} size: {Dimension 752 24})))))
  
  
  (method override (conclude self initargs)
    (nextmethod self initargs)
    (set-panel (locate self 'tier) self)
    (set-panel (locate self 'channel) self))
  
  
  (method protected (setup-visualizer self)
    (define (collect-channels)
      (let ((metadata (metadata-ref replay tier)))
        (if (= (first metadata) server-no)
            '()
          (sort nu<? (fourth metadata)))))
    
    (define (determine-channel channels)
      (and (not-null? channels)
           (car channels)))
    
    (set! channels (collect-channels))
    (let ((channel (determine-channel channels)))
      (set! origin (and channel (car channel)))
      (set! media-kind (and channel (cdr channel)))
      (set! origin-evolution (and origin (evolution-ref replay origin)))
      (set! server-evolution (evolution-ref replay server-no))
      (set! receiver-evolution (evolution-ref replay tier))
      (set! selection #f)
      (set! selection-description #f)
      (setup-timeline self)
      (set-%p self)
      (reset-visualizer self)))
  
  
  ;; quicky to setup everything again
  (method protected (reset-visualizer self)
    (if (not origin)
        (begin
          (set! call #f)
          (set! client #f)
          (set! channel #f)
          (set! ring #f)
          (set! visualizer #f))
      (set! call (simulate-udp-call (get-names replay)))
      (set! client (require-tier call tier))
      (set! channel (find-receive-channel client origin media-kind))
      (set! ring (get-process-ring channel))
      (set! visualizer (visualize-call call client origin media-kind channel ring origin-evolution receiver-evolution)))
    (set-%c channel)
    (set-%e receiver-evolution)
    (set-%r ring)
    (set-%v visualizer))
  
  
  (method protected (visualize-time self time)
    (parameterize ((visualization? #t))
      (when origin
        (let ((last-time (get-last-time visualizer))
              (last-event (get-last-event visualizer)))
          (if (and last-time (> time last-time))
              (visualize-from visualizer (+ last-event 1) time)
            (reset-visualizer self)
            (visualize-from visualizer #f time)))
        (set! now time)
        (invalidate-view self))))
  
  
  (method override (draw self surface context)
    (if (not origin)
        (draw-text surface 5 3 "<no channel found>" visualizer-text-color)
      (draw-text surface 5 3 (format "{a} {a}" (name-ref replay origin) (udp-name media-kind)) visualizer-text-color))
    (when selection-description
      (draw-text surface 100 3 selection-description visualizer-text-color))
    (let ((title (format "{r precision: 1}" visualizer-speed)))
      (let ((width (get-width self))
            (extent (get-text-extent surface title)))
        (draw-text surface (- width (get-width extent) 5) 3 title timeline-text-color))))
  
  
  (method (setup-timeline self)
    (let ((timeline (brother self 'timeline)))
      (let ((start (evolutionary-time receiver-evolution (first-position receiver-evolution)))
            (end (evolutionary-time receiver-evolution (last-position receiver-evolution))))
        (set-visualizer-start timeline start)
        (set-visualizer-end timeline end))))
  
  
  (method protected (cycle-channels self reversed?)
    (when channel
      (let ((key (cons (get-origin channel) (get-media-kind channel))))
        (let ((new-key (if reversed?
                           (previous-element channels key test: equal?)
                         (next-element channels key test: equal?))))
          (set! origin (car new-key))
          (set! media-kind (cdr new-key))
          (set! origin-evolution (evolution-ref replay origin))
          (set! server-evolution (evolution-ref replay server-no))
          (set! receiver-evolution (evolution-ref replay tier))
          (set! selection #f)
          (set! selection-description #f)
          (setup-timeline self)
          (reset-visualizer self)
          (when now
            (visualize-time self now))
          (invalidate-view self))))))


;;;
;;;; Tier
;;;


(class Tier-Visualizer extends View
  
  
  (slot panel initialize #f accessors generate)
  
  
  (method override (mouse-up self evt)
    (let ((h (get-h evt))
          (v (get-v evt)))
      (define (in-tier?)
        (and (< v 25)
             (between? h 0 90)))
      
      (cond ((in-tier?)
             (cycle-channels panel (get-shift? evt)))
            (else
             (nextmethod self evt))))))


;;;
;;;; Channel
;;;


(class Channel-Visualizer extends View
  
  
  (slot panel initialize #f accessors generate)
  
  
  (method override (draw self surface context)
    (let ((channel (get-channel panel))
          (ring (get-ring panel)))
      (when channel
        (let ((total (+ visualizer-after udp-ready-window udp-process-window visualizer-before))
              (width (get-width size))
              (height (get-height size)))
          (with-boundaries self
            (lambda (left-x right-x present-x before-x)
              (let ((after-h (fxround (interpolate visualizer-after 0. total left-x right-x)))
                    (freeze-h (fxround (interpolate (+ visualizer-after udp-ready-window (- udp-late-window)) 0. total left-x right-x)))
                    (present-h (fxround present-x))
                    (before-h (fxround (interpolate (+ visualizer-after udp-ready-window udp-process-window) 0. total left-x right-x)))
                    (top 3)
                    (bottom (- height 3))
                    (state-color (case (get-state ring)
                                   ((ok) {Color Green alpha: .8})
                                   ((late) {Color Light-Blue alpha: .8})
                                   ((waiting) {Color Red alpha: .8}))))
                (when (eq? (active-focus) self)
                  (frame-rect surface (new Rect 0 (- top 3) width (+ bottom 3)) state-color))
                (frame-rect surface (new Rect 1 (- top 2) (- width 1) (+ bottom 2)) state-color)
                (frame-rect surface (new Rect 2 (- top 1) (- width 2) (+ bottom 1)) {Color Black})
                (fill-rect surface (new Rect 3 top after-h bottom) {Color Red alpha: .8})
                (fill-rect surface (new Rect after-h top freeze-h bottom) {Color Orange alpha: .8})
                (fill-rect surface (new Rect freeze-h top present-h bottom) {Color Green alpha: .8})
                (fill-rect surface (new Rect present-h top before-h bottom) {Color Yellow alpha: .8})
                (fill-rect surface (new Rect before-h top (- width 3) bottom) {Color Gray alpha: .8})
                (draw-ring self surface left-x right-x present-x before-x))))))))
  
  
  (method (draw-ring self surface left-x right-x present-x before-x)
    (let ((replay (get-replay panel))
          (ring (get-ring panel))
          (now (get-now panel))
          (visualizer (get-visualizer panel))
          (selection (get-selection panel)))
      (when (and ring now)
        (let ((base-time (get-base-time replay))
              (drawn (make-table test: eqv?)))
          (iterate-table-safe (get-removes visualizer)
            (lambda (sequence info)
              (bind (packet time complete?) info
                (let ((full .015))
                  (let ((age (- now time)))
                    (if (>= age full)
                        (begin
                          (table-clear (get-adds visualizer) sequence)
                          (table-clear (get-removes visualizer) sequence))
                      (with-packet self left-x right-x present-x before-x packet
                        (lambda (selection-frame? h v)
                          (let ((size (interpolate age 0. full 4. 1.)))
                            (let ((rect (new Rect$fl$ (- h size) (- v size) (+ h size) (+ v size))))
                              (let ((frame (get-frame packet))
                                    (header? (get-header? packet)))
                                (let ((color (if header?
                                                 {Color Purple}
                                               {Color Blue})))
                                  (cond ((not frame)
                                         (ellipse$fl$ surface rect color #f))
                                        ((not selection-frame?)
                                         (ellipse$fl$ surface rect color (and complete? color)))
                                        (else
                                         (ellipse$fl$ surface rect color (and (get-data packet) color))))))
                              (when (and selection (eq? (get-sequence packet) selection))
                                (ellipse$fl$ surface (inflate-rect$fl$ rect 1 1) {Color White} #f))))))))))))
          (iterate-packets self left-x right-x present-x before-x
            (lambda (index packet selection-frame? h v)
              (let ((full .015))
                (let ((age (- now (table-ref (get-adds visualizer) (get-sequence packet) #f))))
                  (let ((size (cond ((<= age 0.) 1.)
                                    ((>= age full) 4.)
                                    (else (interpolate age 0. full 1. 4.)))))
                    (let ((rect (new Rect$fl$ (- h size) (- v size) (+ h size) (+ v size))))
                      (let ((frame (get-frame packet))
                            (header? (get-header? packet)))
                        (let ((color (if header?
                                         {Color Purple}
                                       {Color Blue})))
                          (cond ((not frame)
                                 (ellipse$fl$ surface rect color #f))
                                ((not selection-frame?)
                                 (unless (table-ref drawn frame #f)
                                   (ellipse$fl$ surface rect color (and (frame-complete? ring index) color))
                                   (table-set! drawn frame #t)))
                                (else
                                 (ellipse$fl$ surface rect color (and (get-data packet) color))))))
                      (when (and selection (eq? (get-sequence packet) selection))
                        (ellipse$fl$ surface (inflate-rect$fl$ rect 1 1) {Color White} #f))))))))))))
  
  
  (method (with-boundaries self proc)
    (let ((total (+ visualizer-after udp-ready-window udp-process-window visualizer-before))
          (left-x 3.)
          (right-x (cast <fl> (- (get-width size) 3))))
      (let ((present-x (interpolate (+ visualizer-after udp-ready-window) 0. total left-x right-x))
            (before-x (interpolate (+ visualizer-after udp-ready-window udp-process-window) 0. total left-x right-x)))
        (proc left-x right-x present-x before-x))))
  
  
  (method (with-packet self left-x right-x present-x before-x packet proc)
    (let ((ring (get-ring panel))
          (now (get-now panel))
          (selection-frame (get-selection-frame panel)))
      (let ((time (+ (get-time-base ring) (get-timestamp packet)))
            (frame (get-frame packet)))
        (let ((h (interpolate now (+ time udp-process-window) time present-x before-x))
              (v 12.)
              (selection-frame? (and frame selection-frame (= frame selection-frame))))
          (define (call-proc h v)
            (let ((h (max left-x (min h right-x))))
              (proc selection-frame? h v)))
          
          (if selection-frame?
              (let ((part (get-part packet))
                    (total (get-total packet)))
                (let ((width (- (* 10 total) 1)))
                  (let ((h (+ (- h (quotient width 2)) (* 10 part))))
                    (call-proc h v))))
            (let ((width 8))
              (let ((h (- h (quotient width 2))))
                (call-proc h v))))))))
  
  
  (method (iterate-packets self left-x right-x present-x before-x proc)
    (let ((ring (get-ring panel)))
      (define (collect-indexes)
        (let ((queue (new-queue)))
          (iterate-indexes ring
            (lambda (index)
              (enqueue queue index)))
          (queue-list queue)))
      
      (for-each (lambda (index)
                  (let ((packet (packet-ref ring index)))
                    (with-packet self left-x right-x present-x before-x packet
                      (lambda (selection-frame? h v)
                        (proc index packet selection-frame? h v)))))
                (collect-indexes))))
  
  
  (method (toggle-playing self)
    (let ((timeline (brother panel 'timeline)))
      (let ((playing? (not (get-playing? timeline))))
        (set-playing? timeline playing?)
        (if (not playing?)
            (set-fast-playing? timeline #f)
          (set-fast-playing? timeline (shift-down?))))))
  
  
  (method override (key-press self evt)
    (case (get-key evt)
      ((#\space)
       (toggle-playing self))))
  
  
  (method override (left-arrow-press self modifiers)
    (let ((timeline (brother panel 'timeline)))
      (step-backward timeline (if (shift-down?) .001 .01))))
  
  (method override (right-arrow-press self modifiers)
    (let ((timeline (brother panel 'timeline)))
      (step-forward timeline (if (shift-down?) .001 .01))))
  
  
  (method override (up-arrow-press self modifiers)
    (let ((timeline (brother panel 'timeline)))
      (play-faster timeline))
    (invalidate-view panel))
  
  (method override (down-arrow-press self modifiers)
    (let ((timeline (brother panel 'timeline)))
      (play-slower timeline))
    (invalidate-view panel))
  
  
  (method override (focus-gained self)
    (nextmethod self)
    (invalidate-view self))
  
  
  (method override (focus-lost self)
    (nextmethod self)
    (invalidate-view self))
  
  
  (method override (mouse-down self evt)
    (acquire-focus self))
  
  
  (method override (mouse-up self evt)
    (with-boundaries self
      (lambda (left-x right-x present-x before-x)
        (define (find-packet h)
          (continuation-capture
            (lambda (return)
              (iterate-packets self left-x right-x present-x before-x
                (lambda (index packet selection-frame? packet-h packet-v)
                  (when (and (>= h (- packet-h 4))
                             (<= h (+ packet-h 4)))
                    (continuation-return return packet))))
              #f)))
        
        (define (describe-packet packet)
          (format "Header {a}, timestamp {a}, sequence {a}, frame {a}, part {a}, total {a}, data {a}"
                  (if (get-header? packet) 'yes 'no)
                  (get-timestamp packet)
                  (get-sequence packet)
                  (get-frame packet)
                  (get-part packet)
                  (get-total packet)
                  (if (get-data packet) 'yes 'no)))
        
        (acquire-focus self)
        (let ((packet (find-packet (get-h evt))))
          (when (neq? packet (get-selection panel))
            (set-selection panel (and packet (get-sequence packet)))
            (set-selection-frame panel (and packet (get-frame packet)))
            (set-selection-description panel (and packet (describe-packet packet)))
            (invalidate-view panel))))))
  
  
  (method override (double-click self evt)
    (toggle-playing self))))
