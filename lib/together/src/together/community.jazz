;;;============
;;;  Together
;;;============
;;;
;;;; Community Zone
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module together.community jazz


(import (jazz.action)
        (jazz.component)
        (jazz.console)
        (jazz.event)
        (jazz.exemplar)
        (jazz.figure)
        (jazz.geometry)
        (jazz.graphic)
        (jazz.handler)
        (jazz.io)
        (jazz.markup)
        (jazz.math)
        (jazz.network)
        (jazz.opengl.window)
        (jazz.outline)
        (jazz.process)
        (jazz.resource)
        (jazz.text)
        (jazz.tree)
        (jazz.ui)
        (jazz.view)
        (jazz.window)
        (time)
        (world)
        (world.audio)
        (world.autoload)
        (world.client.text)
        (world.client.tier)
        (world.client.udp)
        (world.context)
        (world.evolution)
        (world.geometry)
        (world.interface)
        (world.interface.clients)
        (world.interface.command)
        (world.interface.dialogs)
        (world.interface.documents)
        (world.interface.evolution)
        (world.interface.frame)
        (world.interface.panel)
        (world.interface.sheet)
        (world.interface.text)
        (world.interface.tiers)
        (world.interface.timeline)
        (world.io)
        (world.pane)
        (world.profiling)
        (world.ring)
        (world.settings)
        (world.skybox)
        (world.task)
        (world.udp)
        (world.video)
        (world.window)
        (together)
        (together.settings)
        (together.zone))


(definition guillaume?
  (world-setting 'together.guillaume? #f))


(definition auto-hide?
  (world-setting 'together.auto-hide? #t))

(definition auto-audio?
  (world-setting 'together.auto-audio? #t))

(definition auto-video?
  (world-setting 'together.auto-video? #t))

(definition hide-people?
  (world-setting 'together.hide-people? #t))

(definition hide-chat?
  (world-setting 'together.hide-chat? #t))


(definition show-debug?
  (world-setting 'together.show-debug? #f))


(class Community-Zone extends Together-Zone
  
  
  (slot configuration   initialize #f                getter generate)
  (slot selected-group  initialize #f                getter generate)
  (slot selected-player initialize #f                getter generate)
  (slot joined-circle   initialize #f                getter generate)
  (slot circle-start    initialize #f                getter generate)
  (slot view-focused    initialize #f                getter generate)
  (slot draw-hook       initialize #f                getter generate)
  (slot hide-ring       initialize (new Time-Ring 1) getter generate)
  (slot hide-thread     initialize #f                getter generate)
  (slot replay          initialize #f                getter generate)
  
  
  (method override (zone-ready self)
    (nextmethod self)
    (when (window?)
      (let ((world (current-world)))
        (setup-stage self)
        (setup-configuration self)
        (install-zone self)
        (install-stage self)
        (install-hooks self)
        (set-escape-hook world (~ escape-press self))
        (set-draw-me? self #f)
        (view-people self)
        (when guillaume?
          (create-group (current-tier) "Circle")))))
  
  
  (method override (destroy self)
    (when (window?)
      (let ((world (current-world))
            (client (current-client))
            (audio (current-audio))
            (video (current-video)))
        (let ((udp-client (get-udp-client client)))
          (stop udp-client)
          (close-send-channels udp-client)
          (close-receive-channels udp-client))
        (stop-audio audio feedback?: #f)
        (stop-video video feedback?: #f)
        (close-outputs audio)
        (close-outputs video)
        (uninstall-hooks self)
        (uninstall-stage self)
        (uninstall-zone self)
        (set! stage #f)
        (no-showcase world)
        (set-draw-me? self #t)
        (uninstall-camera)))
    (nextmethod self))
  
  
  (method (setup-stage self)
    (set! stage 'gathering))
  
  
  (method (setup-configuration self)
    (let ((file (together-file)))
      (set! configuration (instantiate (read-form file)))))
  
  
  (method override (mute-audio? self)
    (neq? stage 'circle))
  
  
  (method override (refresh-interface? self)
    (and (developer?)
         (eq? stage 'circle)))
  
  
  (method (install-zone self)
    (let ((interface (current-interface)))
      (let ((version (process-version (current-process)))
            (release (process-release (current-process)))
            (name (get-character-name configuration)))
        ;; common
        (new Kind-Label name: 'people-label parent: interface title: "People" location: '(10 64) size: {Dimension 220 40} font: {Font font-name: tahoma point-size: 16 shadow: thin} justification: 'center)
        (new People-Panel name: 'people parent: interface location: '(10 100) proportion: '(220 (bounds -300)) layout-type: 'border)
        (new Kind-Label name: 'chat-label parent: interface title: "Chat" location: '(-10 64) size: {Dimension 220 40} font: {Font font-name: tahoma point-size: 16 shadow: thin} justification: 'center)
        (let ((chat (child interface 'chat)))
          (set-border-type (child chat 'border) 'solid)
          (set-border-color (child chat 'border) {Color Dark-Gray})
          (set-location chat '(-10 100))
          (set-proportion chat '(220 (bounds -354))))
        (let ((to (new View name: 'command-to parent: interface size: {Dimension 220 40})))
          (new Kind-Label name: 'to parent: to title: "To" position: {Point 0 0} size: {Dimension 22 40} font: {Font font-name: tahoma point-size: 15.5 shadow: thin} justification: 'head)
          (new Kind-Label name: 'dest parent: to title: "The gathering" position: {Point 22 0} size: {Dimension 220 40} font: {Font font-name: tahoma point-size: 15.5 shadow: thin} justification: 'head))
        (let ((command (child interface 'command)))
          (set-border-type (child command 'border) 'solid)
          (set-border-color (child command 'border) {Color Dark-Gray})
          (set-location command '(-10 -200))
          (set-size command (new Dimension 220 19)))
        (when (developer?)
          (new Kind-Label name: 'admin-label parent: interface title: "Admin" location: '(center 144) size: {Dimension 220 40} font: {Font font-name: tahoma point-size: 16 shadow: thin} justification: 'center)
          (new Admin-Panel name: 'admin parent: interface location: '(center 180) proportion: '((bounds -500) (bounds -380)) layout-type: 'fill)
          (initial-banner (locate (child interface 'admin) '(console text)) (format "Together server v{a}" (present version))))
        (add-exception-view self)
        ;; gathering
        (let ((root (new Together-Root name: 'gathering parent: interface location: 'fill size: (get-size interface) layout-type: 'justify)))
          (new Label-View name: 'together parent: root title: tier-title location: '(center 30) size: {Dimension 400 80} auto-size?: #t font: {Font font-name: tahoma point-size: 60 shadow: thin})
          (new Name-Label name: 'name parent: root title: name location: '(-10 10) size: {Dimension 200 40} auto-size?: #t font: {Font font-name: tahoma point-size: 15.5 shadow: thin} justification: 'center)
          (new Version-Label name: 'version parent: root title: (format "v{a}" (present version)) location: '(30 -90) size: {Dimension 200 40} font: {Font font-name: tahoma point-size: 12.5 shadow: thin})
          (new Version-Label name: 'release parent: root title: release location: '(30 -70) size: {Dimension 200 40} font: {Font font-name: tahoma point-size: 12.5 shadow: thin})
          (new Push-Button name: 'quit parent: root title: "Quit" location: '(30 -30) size: {Dimension 100 24} font: {Font font-name: tahoma point-size: 13 shadow: thin} action-handler: (~ on-quit self))
          (when (developer?)
            (new Push-Button name: 'goto-replay parent: root title: "Replay" location: '(200 -30) size: {Dimension 150 24} font: {Font font-name: tahoma point-size: 13 shadow: thin} action-handler: (~ on-goto-replay self)))
          (new Kind-Label name: 'circle parent: root title: "" location: '(center (center -40)) size: {Dimension 200 40} auto-size?: #t font: {Font font-name: tahoma point-size: 19.5 antialias: default} justification: 'center)
          (new Push-Button name: 'join parent: root title: "Join" enabled?: #f location: '(center center) size: {Dimension 180 36} font: {Font Label-User point-size: 16.5 antialias: default} action-handler: (~ on-join self))
          (new Toggle-Button name: 'about parent: root title: "About & Copyright" location: '(-30 -30) size: {Dimension 160 24} font: {Font font-name: tahoma point-size: 13 shadow: thin} action-handler: (~ on-about self))
          (new Kind-Label name: 'circle-label parent: root title: "New circle name" location: '(center -120) size: {Dimension 200 40} auto-size?: #t font: {Font Label-User point-size: 17.5 antialias: default} justification: 'tail)
          (new Name-View name: 'circle-view parent: root location: '(center -90) border-type: 'solid border-color: {Color Dark-Gray} action-view: 'circle-create)
          (new Push-Button name: 'circle-create parent: root title: "Create & Join" enabled?: #f location: '(center -30) size: {Dimension 180 36} font: {Font Label-User point-size: 16.5 antialias: default} action-handler: (~ on-create&join self)))
        ;; circle
        (let ((root (new Together-Root name: 'circle parent: interface location: 'fill size: (get-size interface) layout-type: 'justify)))
          (new Kind-Label name: 'circle-name parent: root title: name location: '(-10 10) size: {Dimension 200 40} auto-size?: #t font: {Font font-name: tahoma point-size: 15.5 shadow: thin} justification: 'center)
          (new Push-Button name: 'toggle-people parent: root location: '(30 30) size: {Dimension 150 24} font: {Font font-name: tahoma point-size: 13 shadow: thin} action-handler: (~ on-toggle-people self))
          (new Push-Button name: 'toggle-chat parent: root location: '(210 30) size: {Dimension 150 24} font: {Font font-name: tahoma point-size: 13 shadow: thin} action-handler: (~ on-toggle-chat self))
          (let ((circlebar (new Circlebar-View name: 'circlebar parent: root location: '(0 tail) proportion: '(bounds 60))))
            (new Circlebar-Button name: 'leave parent: circlebar title: "Leave" location: '(30 -30) size: {Dimension 100 24} font: {Font font-name: tahoma point-size: 13 shadow: thin} action-handler: (~ on-leave self))
            (new Circlebar-Button name: 'audio parent: circlebar location: '(180 -30) size: {Dimension 150 24} font: {Font font-name: tahoma point-size: 13 shadow: thin} action-handler: (~ on-toggle-audio self))
            (new Circlebar-Button name: 'video parent: circlebar location: '(340 -30) size: {Dimension 150 24} font: {Font font-name: tahoma point-size: 13 shadow: thin} action-handler: (~ on-toggle-video self))
            (new Circlebar-Button name: 'layouts parent: circlebar location: '(540 -30) size: {Dimension 150 24} font: {Font font-name: tahoma point-size: 13 shadow: thin} action-handler: (~ on-cycle-layouts self))
            (layout-view circlebar)))
        ;; replay
        (let ((root (new Together-Root name: 'replay parent: interface location: 'fill size: (get-size interface) layout-type: 'justify)))
          (new Together-Timeline-Panel parent: root name: 'timeline visible?: #f layouter: (lambda (panel) (timeline-panel-layouter panel)))
          (new Together-Evolution-Panel parent: root name: 'evolution visible?: #f layouter: (lambda (panel) (evolution-panel-layouter panel)))
          (new Push-Button name: 'back parent: root title: "Back" location: '(30 -30) size: {Dimension 100 24} font: {Font font-name: tahoma point-size: 13 shadow: thin} action-handler: (~ on-back self)))
        ;; hide all
        (for-each (lambda (child)
                    (set-visible? child #f))
                  (get-children interface)))))
  
  
  (method (install-stage self)
    (let ((interface (current-interface)))
      (case stage
        ((gathering)
         (install-gathering self))
        ((circle)
         (install-circle self))
        ((replay)
         (install-replay self)))
      (show root)
      (send-to-back root)
      (when (developer?)
        (unless (eq? (active-focus) (locate (child interface 'admin) '(console text)))
          (focus-world)))))
  
  
  (method (install-gathering self)
    (let ((interface (current-interface))
          (world (current-world))
          (audio (current-audio))
          (video (current-video)))
      (define (show parent name)
        (set-visible? (child parent name) #t))
      
      (define (visible parent name flag)
        (set-visible? (child parent name) flag))
      
      (define (title parent name str)
        (set-title (child parent name) str))
      
      (define (color parent name color)
        (set-color (child parent name) color))
      
      (define (location parent name loc)
        (set-location (child parent name) loc))
      
      (define (proportion parent name prop)
        (set-proportion (child parent name) prop))
      
      (set! root (child interface 'gathering))
      (stop-audio audio feedback?: #f)
      (stop-video video feedback?: #f)
      (show root 'together)
      (show root 'version)
      (show root 'release)
      (show root 'quit)
      (when (developer?)
        (show root 'goto-replay))
      (show root 'name)
      (when (developer?)
        (let ((admin-visible? (get-visible? (child interface 'admin))))
          (visible root 'circle (not admin-visible?))
          (visible root 'join (not admin-visible?))))
      (show root 'circle-label)
      (show root 'circle-view)
      (show root 'circle-create)
      (show interface 'people-label)
      (show interface 'people)
      (show interface 'chat-label)
      (show interface 'chat)
      (proportion interface 'chat '(220 (bounds -300)))
      (show interface 'command-to)
      (title interface '(command-to dest) "The gathering")
      (color interface '(command-to dest) {Color red: 32 green: 205 blue: 33})
      (location interface 'command-to '(-10 -158))
      (show interface 'command)
      (location interface 'command '(-10 -146))
      (show root 'about)
      (update-circle/join self)
      (layout-view interface)
      (layout-view root)
      (no-showcase world)))
  
  
  (method (install-circle self)
    (let ((interface (current-interface))
          (world (current-world))
          (audio (current-audio))
          (video (current-video)))
      (define (show parent name)
        (set-visible? (child parent name) #t))
      
      (define (visible parent name flag)
        (set-visible? (child parent name) flag))
      
      (define (title parent name str)
        (set-title (child parent name) str))
      
      (define (color parent name color)
        (set-color (child parent name) color))
      
      (define (location parent name loc)
        (set-location (child parent name) loc))
      
      (define (proportion parent name prop)
        (set-proportion (child parent name) prop))
      
      (set! root (child interface 'circle))
      (show root 'circle-name)
      (title root 'circle-name joined-circle)
      (show root 'toggle-people)
      (show root 'toggle-chat)
      (show root 'circlebar)
      (visible interface 'people-label (not hide-people?))
      (visible interface 'people (not hide-people?))
      (proportion interface 'chat '(220 (bounds -354)))
      (title interface '(command-to dest) joined-circle)
      (color interface '(command-to dest) {Color World-Red})
      (location interface 'command-to '(-10 -212))
      (location interface 'command '(-10 -200))
      (visible interface 'chat-label (not hide-chat?))
      (visible interface 'chat (not hide-chat?))
      (visible interface 'command-to (not hide-chat?))
      (visible interface 'command (not hide-chat?))
      (delay-hide-interface self)
      (layout-view interface)
      (layout-view root)
      (no-showcase world)
      (when auto-audio?
        (start-audio audio))
      (when auto-video?
        (start-video video))
      (update-audio self)
      (update-video self)
      (update-layouts self)
      (update-buttons self)
      (when auto-hide?
        (install-hider self))))
  
  
  (method (install-replay self)
    (let ((interface (current-interface)))
      (define (show parent name)
        (set-visible? (child parent name) #t))
      
      (define (visible parent name flag)
        (set-visible? (child parent name) flag))
      
      (set! root (child interface 'replay))
      (show root 'timeline)
      (show root 'evolution)
      (show root 'back)
      (visible interface 'people-label #f)
      (visible interface 'people #f)
      (visible interface 'chat-label #f)
      (visible interface 'chat #f)
      (visible interface 'command-to #f)
      (visible interface 'command #f)
      (layout-view interface)
      (layout-view root)))
  
  
  (method (uninstall-stage self)
    (when (and (eq? stage 'circle) auto-hide?)
      (uninstall-hider self))
    (hide root))
  
  
  (method (uninstall-zone self)
    (let ((interface (current-interface)))
      (close (child interface 'people-label))
      (close (child interface 'people))
      (close (child interface 'chat-label))
      (close (child interface 'command-to))
      (when (developer?)
        (close (child interface 'admin-label))
        (close (child interface 'admin)))
      (close (child interface 'gathering))
      (close (child interface 'circle))
      (close (child interface 'replay))
      (close (child interface 'exception))))
  
  
  (method (on-about self evt)
    (let ((interface (current-interface)))
      (define (show parent name)
        (set-visible? (child parent name) #t))
      
      (define (closer frame)
        (show root 'circle)
        (show root 'join)
        (show interface 'people-label)
        (show interface 'people)
        (show interface 'chat-label)
        (show interface 'chat)
        (show interface 'command-to)
        (show interface 'command)
        (show root 'circle-label)
        (show root 'circle-view)
        (show root 'circle-create)
        (when view-focused
          (inhibit-focus-selects-all self view-focused
            (lambda ()
              (acquire-focus view-focused)))))
      
      (let ((frame (top-frame)))
        (if (is? frame World-Document)
            (begin
              (close frame)
              (closer frame))
          (show-about self closer: closer)))))
  
  
  (method (show-about self (title: title #f) (closable?: closable? #t) (closer: closer #f))
    (let ((interface (current-interface))
          (world (current-world)))
      (define (hide parent name)
        (set-visible? (child parent name) #f))
      
      (set! view-focused (active-focus))
      (hide root 'circle)
      (hide root 'join)
      (hide interface 'people-label)
      (hide interface 'people)
      (hide interface 'chat-label)
      (hide interface 'chat)
      (hide interface 'command-to)
      (hide interface 'command)
      (when (developer?)
        (hide interface 'admin-label)
        (hide interface 'admin))
      (hide root 'circle-label)
      (hide root 'circle-view)
      (hide root 'circle-create)
      (open-about world name: 'about&copyright title: (or title "About & Copyright") movable?: #f closable?: closable? closer: closer background: {Color red: .000 green: .000 blue: .000 alpha: .250})))
  
  
  (method (update-circle/join self)
    (let ((interface (current-interface)))
      (cond ((not selected-group)
             (set-title (child root 'circle) "")
             (set-enabled? (child root 'join) #f))
            (else
             (set-title (child root 'circle) selected-group)
             (set-enabled? (child root 'join) #t)
             (layout-view root)))))
  
  
  ;;;
  ;;;; Mouse
  ;;;
  
  
  (method override (mouse-moved self x y)
    (when (eq? stage 'circle)
      (show-interface self))
    (when (developer?)
      (show/hide-debug self (fxround x) (fxround y))))
  
  
  (method override (mouse-down self h v)
    (mouse-action self h v)
    (click-sheet self h v))
  
  
  (method override (mouse-up self h v)
    (mouse-action self h v))
  
  
  (method override (mouse-action self h v)
    (when (eq? stage 'circle)
      (show-interface self)))
  
  
  (method override (double-click self h v)
    (mouse-action self h v)
    (click-sheet self h v))
  
  
  (method override (multiple-click self h v)
    (mouse-action self h v)
    (click-sheet self h v))
  
  
  (method (install-hider self)
    (let ((thread (new-thread
                    (lambda ()
                      (declare (proper-tail-calls))
                      (let (loop)
                        (let ((proc (wait hide-ring)))
                          (when proc
                            (delay-event
                              (lambda ()
                                (proc)))
                            (loop)))))
                    'hider)))
      (set! hide-thread thread)
      (thread-start! thread)))
  
  
  (method (uninstall-hider self)
    (empty hide-ring)
    (insert-earliest hide-ring #f))
  
  
  ;; we probably need a tolerance so moving
  ;; only 1 pixel doesn't show the interface
  (method (show-interface self)
    (let ((window (current-window))
          (interface (current-interface)))
      @wait-later-version-as-it-needs-debugging
      (show-cursor window)
      (set-visible? (child root 'circle-name) #t)
      (set-visible? (child root 'toggle-people) #t)
      (set-visible? (child root 'toggle-chat) #t)
      (set-visible? (child root 'circlebar) #t)
      (set-uptodate? (child root 'circlebar) #f)
      (delay-hide-interface self)))
  
  
  (method (delay-hide-interface self)
    (when auto-hide?
      (let ((hide-time (+ (current-seconds) 2.)))
        (empty hide-ring)
        (insert hide-ring hide-time (lambda ()
                                      (with-task-mutex
                                        (lambda ()
                                          (when (eq? stage 'circle)
                                            (let ((window (current-window))
                                                  (interface (current-interface)))
                                              @wait-later-version-as-it-needs-debugging
                                              (hide-cursor window)
                                              (set-visible? (child root 'circle-name) #f)
                                              (set-visible? (child root 'toggle-people) #f)
                                              (set-visible? (child root 'toggle-chat) #f)
                                              (set-visible? (child root 'circlebar) #f)
                                              (set-uptodate? (child root 'circlebar) #f))))))))))
  
  
  (method (show/hide-debug self h v)
    (let ((interface (current-interface)))
      (let ((toolbar (child interface 'debug)))
        (let ((pos (new Point h v)))
          (let ((in? (in-rect? pos (get-rect toolbar))))
            (set-visible? toolbar in?))))))
  
  
  ;;;
  ;;;; Events
  ;;;
  
  
  (method (on-toggle-people self evt)
    (let ((interface (current-interface)))
      (when (eq? stage 'circle)
        (toggle-visible? (child interface 'people-label))
        (toggle-visible? (child interface 'people))
        (update-buttons self))))
  
  
  (method (on-toggle-chat self evt)
    (let ((interface (current-interface)))
      (when (eq? stage 'circle)
        (toggle-visible? (child interface 'chat-label))
        (toggle-visible? (child interface 'chat))
        (toggle-visible? (child interface 'command-to))
        (toggle-visible? (child interface 'command))
        (update-buttons self))))
  
  
  (method (on-message self evt)
    (let ((interface (current-interface)))
      (show-chat self)
      (acquire-focus (locate (child interface 'command) 'text))))
  
  
  (method (update-buttons self)
    (let ((interface (current-interface)))
      (when (eq? stage 'circle)
        (set-title (child root 'toggle-people)
                   (if (get-visible? (child interface 'people))
                       "Hide People"
                     "Show People"))
        (set-title (child root 'toggle-chat)
                   (if (get-visible? (child interface 'chat))
                       "Hide Chat"
                     "Show Chat")))))
  
  
  (method (on-leave-circle self evt)
    (when (eq? stage 'circle)
      (leave-circle self)))
  
  
  (method (on-toggle-denoise self evt)
    (let ((world (current-world)))
      (when (eq? stage 'circle)
        (set-audio-denoise? (not (get-audio-denoise?)))
        (display-on/off world "Denoise" (get-audio-denoise?)))))
  
  
  (method (on-toggle-audio self evt)
    (let ((audio (current-audio)))
      (when (eq? stage 'circle)
        (toggle-audio audio)
        (update-audio self))))
  
  
  (method (update-audio self)
    (let ((interface (current-interface))
          (audio (current-audio)))
      (set-title (child root '(circlebar audio))
                 (if (audio-playing? audio)
                     "Stop Audio"
                   "Start Audio"))))
  
  
  (method (on-toggle-video self evt)
    (let ((video (current-video)))
      (when (eq? stage 'circle)
        (toggle-video video)
        (update-video self)
        (invalidate-interface))))
  
  
  (method (update-video self)
    (let ((interface (current-interface))
          (video (current-video)))
      (set-title (child root '(circlebar video))
                 (if (video-playing? video)
                     "Stop Video"
                   "Start Video"))))
  
  
  (method (escape-press self)
    (let ((frame (top-frame)))
      (if frame
          (close frame)
        (when (and guillaume? (eq? stage 'gathering))
          (delay-event
            (lambda ()
              (with-task-mutex
                (lambda ()
                  (open-login-zone))))))))
    #t)
  
  
  (method override (enter-press self)
    (when (and (eq? stage 'gathering)
               (eq? (active-focus) (current-interface))
               selected-group
               (not selected-player))
      (join-circle self selected-group)))
  
  
  (method override (tab-press self)
    )
  
  
  (method package (on-join self evt)
    (join-circle self selected-group))
  
  
  (method (on-leave self evt)
    (leave-circle self))
  
  
  (method (on-create&join self evt)
    (create&join-circle self))
  
  
  (method override (name-return self)
    (create&join-circle self))
  
  
  (method (create&join-circle self)
    (let ((interface (current-interface))
          (tier (current-client))
          (world (current-world)))
      (let ((view (child root 'circle-view)))
        (let ((text (locate view 'text)))
          (let ((name (trim-whitespace (get-string-content text))))
            (unless (empty-string? name)
              (let ((exception (create-group tier name)))
                (if exception
                    (display-error world exception)
                  (clear-message world)
                  (set-string-content text "")
                  (join-circle self name)))))))))
  
  
  (method (join-circle self name)
    (let ((tier (current-client))
          (world (current-world))
          (zone (current-zone)))
      (reset (current-chronology))
      (reset (current-evolution))
      (let ((exception (join-group tier name)))
        (if exception
            (display-error world exception)
          (clear-message world)
          (uninstall-camera)
          (remove-skybox zone)
          (set! joined-circle name)
          (set! circle-start (current-seconds))
          (goto-stage self 'circle)
          (invalidate-interface)))))
  
  
  (method (leave-circle self)
    (let ((tier (current-client))
          (zone (current-zone)))
      (leave-group tier joined-circle)
      (install-camera)
      (install-skybox zone (find-skybox together-skybox))
      (set! joined-circle #f)
      (goto-stage self 'gathering)
      (invalidate-interface)))
  
  
  (method (goto-stage self what)
    (uninstall-stage self)
    (set! stage what)
    (install-stage self))
  
  
  (method (on-quit self evt)
    (quit-process (current-process)))
  
  
  (method (on-goto-replay self evt)
    (show-replay/last self))
  
  
  (method (on-back self evt)
    (hide-replay self))
  
  
  ;;;
  ;;;; Hooks
  ;;;
  
  
  (method (install-hooks self)
    (let ((interface (current-interface))
          (tier (current-client))
          (audio (current-audio))
          (video (current-video)))
      (set-server-entered-hook tier (~ server-entered self))
      (set-server-exited-hook tier (~ server-exited self))
      (set-hierarchy-update-hook tier (~ hierarchy-update self))
      (set-render-hook video (~ render-video self))
      (set! draw-hook (~ draw-sheets self))
      (register-draw-hook interface draw-hook)
      (set-displayed-hook (child interface 'chat) (~ chat-displayed self))
      (set-return-handler (child interface 'command) (~ command-return self))
      (set-escape-handler (child interface 'command) (~ command-escape self))
      (set-view-replay (~ view-replay self))))
  
  
  (method (uninstall-hooks self)
    (let ((interface (current-interface))
          (tier (current-client))
          (audio (current-audio))
          (video (current-video)))
      (set-server-entered-hook tier #f)
      (set-server-exited-hook tier #f)
      (set-hierarchy-update-hook tier #f)
      (set-render-hook video #f)
      (unregister-draw-hook interface draw-hook)
      (set-displayed-hook (child interface 'chat) #f)
      (set-return-handler (child interface 'command) #f)
      (set-escape-handler (child interface 'command) #f)
      (reset-view-replay)))
  
  
  ;;;
  ;;;; Server
  ;;;
  
  
  (method (server-entered self character-name)
    (let ((world (current-world)))
      (display-message world (format "{a} entered" character-name))))
  
  
  (method (server-exited self character-name disconnected?)
    (let ((world (current-world)))
      (let ((message (if disconnected? "disconnected" "exited")))
        (display-message world (format "{a} {a}" character-name message)))))
  
  
  (method (hierarchy-update self hierarchy)
    (let ((tree (people-tree self)))
      (with-preserved-selection tree
        (lambda ()
          (view-hierarchy self hierarchy))
        use: 'data
        test: equal?
        generate-event?: #t)
      (when guillaume?
        (when (not (get-single-selection tree))
          (select-user-data-row tree '(group "Circle") test: equal? error?: #f))))
    (when (eq? stage 'circle)
      (invalidate-interface)))
  
  
  ;;;
  ;;;; Media
  ;;;
  
  
  (method (render-video self video)
    (neq? stage 'circle))
  
  
  (method (draw-sheets self surface)
    (let ((client (current-client))
          (interface (current-interface))
          (audio (current-audio))
          (video (current-video)))
      (define (draw-output output)
        (when (is? output Sheet-Video-Sink)
          (let ((id (get-id output)))
            (let ((name (if (not id) "Me" (let ((member (find-group-member-by-id client id)))
                                            ;; quick temporary hack
                                            (if (not member)
                                                ""
                                              (first member))))))
              (if (eq? (get-stream-state output) 'drawn)
                  (let ((view (if (eq? video-mode 'fit) (get-sheet output) interface)))
                    (set-font surface {Font font-name: tahoma point-size: 15.5})
                    (let ((extent (get-text-extent surface name)))
                      (let ((pos (get-position view))
                            (offset (new Point 2 (- (get-height view) (get-height extent) 1))))
                        (let ((h (+ (get-h pos) (get-h offset)))
                              (v (+ (get-v pos) (get-v offset))))
                          (draw-text surface h v name {Color White})
                          (when (audio-off? id output)
                            (set-color surface {Color Dark-Red})
                            (set-line-width surface 2)
                            (line surface h (+ v (get-height extent)) (+ h (get-width extent)) v))))))
                (let ((sheet (get-sheet output)))
                  (let ((pos (get-position sheet))
                        (rect (get-rect sheet)))
                    (fill-rect surface (inflate-rect rect -1 -1) {Color red: 30 green: 30 blue: 30})
                    (frame-rect surface rect {Color Dim-Gray})
                    (set-font surface {Font font-name: tahoma point-size: 24 hint-style: slight hint-metrics: on})
                    (let ((extent (get-text-extent surface name)))
                      (let ((offset (center extent (get-size sheet))))
                        (let ((h (+ (get-h pos) (get-h offset)))
                              (v (+ (get-v pos) (get-v offset))))
                          (draw-text surface h v name {Color White})
                          (when (audio-off? id output)
                            (set-color surface {Color Dark-Red})
                            (set-line-width surface 2)
                            (line surface h (+ v (get-height extent)) (+ h (get-width extent)) v))))))))))))
      
      (define (audio-off? id output)
        (if (eq? output (get-self-output video))
            (not (audio-playing? audio))
          (let ((audio-output (find-output audio id)))
            (or (not audio-output)
                (eq? (get-stream-state audio-output) 'off)))))
      
      (define (draw-debugging)
        (set-font surface {Font font-name: tahoma point-size: 24 hint-style: slight hint-metrics: on})
        @should-go-to-info
        (draw-text surface 20 80 (format "{a}" (get-client-no client)) {Color White})
        (draw-text surface 20 80 (format "{a}s" (fxround (- (current-seconds) circle-start))) {Color World-Ochre})
        (draw-text surface 20 130 (format "{a} {a}" (media-quality udp-audio) (media-quality udp-video)) {Color World-Red})
        (draw-text surface 20 180 (format "{a} {a}" (client-drop) (server-drop)) {Color World-Red})
        (draw-text surface 20 230 (format "{a} {a}" (chronology-duration) (evolution-duration)) {Color World-Red})
        (draw-text surface 20 280 (latest-nacks) {Color World-Red}))
      
      (define (media-quality kind)
        (let ((total 0.)
              (count 0))
          (iterate-table (get-receive-channels (get-udp-client client))
            (lambda (key channel)
              (when (= (get-media-kind channel) kind)
                (let ((mean (mean-average (get-process-average channel))))
                  (when mean
                    (increase! total mean)
                    (increase! count))))))
          (if (= count 0)
              "N/A"
            (format "{r precision: 1}%" (* 100. (/ total (cast <fl> count)))))))
      
      (define (client-drop)
        (let ((drop (get-client-drop (get-udp-client client))))
          (if drop
              (format "{r precision: 1}%" drop)
            "N/A")))
      
      (define (server-drop)
        (let ((drop (get-server-drop (get-udp-client client))))
          (if drop
              (format "{r precision: 1}%" drop)
            "N/A")))
      
      (define (chronology-duration)
        (let ((chronology (current-chronology)))
          (with-mutex chronology
            (lambda ()
              (if (= (get-count chronology) 0)
                  "N/A"
                (let ((first (first-position chronology))
                      (last (last-position chronology)))
                  (format "{r precision: 1}s"
                          (- (chronological-time chronology last)
                             (chronological-time chronology first)))))))))
      
      (define (evolution-duration)
        (let ((evolution (current-evolution)))
          (with-mutex evolution
            (lambda ()
              (if (= (get-count evolution) 0)
                  "N/A"
                (let ((first (first-position evolution))
                      (last (last-position evolution)))
                  (format "{r precision: 1}s"
                          (- (evolutionary-time evolution last)
                             (evolutionary-time evolution first)))))))))
      
      (define (latest-nacks)
        (let ((total 0)
              (count 0))
          (iterate-table (get-receive-channels (get-udp-client client))
            (lambda (key channel)
              (when (= (get-media-kind channel) udp-video)
                (let ((len (length (get-latest-nacks channel))))
                  (increase! total len)
                  (increase! count)))))
          (if (= count 0)
              "N/A"
            (format "{a}" (fxround (/ (cast <fl> total) (cast <fl> count)))))))
      
      (let ((self-output (find-output video #f)))
        (when (eq? stage 'circle)
          (for-each (lambda (output)
                      (unless (eq? output self-output)
                        (draw-output output)))
                    (get-ordered-outputs video))
          (when self-output
            (draw-output self-output))
          (when show-debug?
            (draw-debugging))))))
  
  
  (method (click-sheet self h v)
    (let ((video (current-video)))
      (define (clicked-mini)
        (let ((pos (new Point h v)))
          (continuation-capture
            (lambda (return)
              (define (try output)
                (let ((sheet (get-sheet output)))
                  (when (in-rect? pos (get-rect sheet))
                    (continuation-return return output))))
              
              (when (eq? (get-video-layout) 'fullscreen)
                (let ((ordered-outputs (get-ordered-outputs video))
                      (fullscreen-output (effective-fullscreen-output video)))
                  (for-each (lambda (output)
                              (unless (eq? output fullscreen-output)
                                (try output)))
                            ordered-outputs)))
              #f))))
      
      (when (eq? stage 'circle)
        (let ((mini (clicked-mini)))
          (when mini
            (set-fullscreen-output video mini)
            (update-layouts video))))))
  
  
  ;;;
  ;;;; People
  ;;;
  
  
  (method (people-tree self)
    (let ((interface (current-interface)))
      (locate (child interface 'people) '(people people))))
  
  
  (method (view-people self)
    (let ((tier (current-tier)))
      (view-hierarchy self (list-hierarchy tier))))
  
  
  (method (view-hierarchy self hierarchy)
    (let ((tier (current-tier))
          (me (current-me)))
      (let ((tree (people-tree self)))
        (remove-every-row tree)
        (with-update-locked tree
          (lambda ()
            (bind (gathering . groups) hierarchy
              (let ((players (cdr gathering)))
                (let ((row (add-row tree
                                  state: 'expanded
                                  children: (list (new Tree-Node
                                                    title: "The gathering"
                                                    font: {Font Label-User}
                                                    color: {Color red: 32 green: 205 blue: 33})))))
                  (for-each (lambda (info)
                              (bind (player id no) info
                                (add-row tree
                                         father: row
                                         children: (list (new Tree-Node title: player font: {Font Label-User} color: {Color World-Blue}))
                                         user-data: (list 'player player #f))))
                            (let ((me (get-name me)))
                              (sort di<? players key: (lambda (player)
                                                        (if (equal? player me)
                                                            (cons 0 player)
                                                          (cons 1 player))))))))
              (when (not-null? hierarchy)
                (add-row tree
                         children: (list (new Tree-Node title: "" font: {Font Label-User})))
                (for-each (lambda (info)
                            (bind (group . players) info
                              (let ((row (add-row tree
                                                  state: 'expanded
                                                  children: (list (new Tree-Node title: group font: {Font Label-User} color: {Color World-Red}))
                                                  user-data: (list 'group group))))
                                (for-each (lambda (info)
                                            (bind (player id no) info
                                              (add-row tree
                                                       father: row
                                                       children: (list (new Tree-Node title: player font: {Font Label-User} color: {Color World-Blue}))
                                                       user-data: (list 'player player group))))
                                          players))))
                          (sort di<? groups key: car)))))))))
  
  
  (method package (people-selection-change self)
    (let ((tree (people-tree self)))
      (let ((selected (or (get-single-selected-data tree) (list 'group #f))))
        (bind (kind . rest) selected
          (define (select group player)
            (set! selected-group group)
            (set! selected-player player)
            (when (eq? stage 'gathering)
              (update-circle/join self)))
          
          (case kind
            ((player)
             (bind (player group) rest
               (select group player)))
            ((group)
             (bind (group) rest
               (select group #f))))))))
  
  
  (method package (people-double-click self)
    (people-action-selected self))
  
  
  (method package (people-return-press self)
    (people-action-selected self))
  
  
  (method (people-action-selected self)
    (when (eq? stage 'gathering)
      (when (and selected-group (not selected-player))
        (join-circle self selected-group))))
  
  
  ;;;
  ;;;; Chat
  ;;;
  
  
  (method (chat-displayed self chat)
    (show-chat self)
    #f)
  
  
  (method (show-chat self)
    (let ((interface (current-interface)))
      (set-visible? (child interface 'chat-label) #t)
      (set-visible? (child interface 'chat) #t)
      (set-visible? (child interface 'command-to) #t)
      (set-visible? (child interface 'command) #t)
      (update-buttons self)))
  
  
  (method (command-return self command)
    (define (parse-content content)
      (if (not (developer?))
          (values 'group (group-recipient) content)
        (cond ((starts-with? content "/s ")
               (values 'server #f (substring content 3 (string-length content))))
              ((starts-with? content "/g ")
               (values 'group (group-recipient) (substring content 3 (string-length content))))
              ((starts-with? content "/w ")
               (let ((str (substring content 3 (string-length content))))
                 (let ((pos (find str #\space)))
                   (if (not pos)
                       (values 'whisper (get-name (current-me)) str)
                     (let ((recipient (substring str 0 pos))
                           (message (substring str (+ pos 1) (string-length str))))
                       (show-panel-whisper recipient message)
                       (values 'whisper recipient message))))))
              ((starts-with? content "/r ")
               (let ((last-whisperer (get-last-whisperer (current-world)))
                     (message (substring content 3 (string-length content))))
                 (if (not last-whisperer)
                     (values 'group (group-recipient) message)
                   (show-panel-whisper last-whisperer message)
                   (values 'whisper last-whisperer message))))
              (else
               (values 'group (group-recipient) content)))))
    
    (define (group-recipient)
      (if (eq? stage 'circle)
          joined-circle
        #f))
    
    (define (show-panel-whisper recipient message)
      (let ((interface (current-interface)))
        (let ((panel (child interface 'chat)))
          (show-whisper panel recipient message))))
    
    (let ((world (current-world))
          (tier (current-client)))
      (let ((text (locate command 'text)))
        (let ((content (get-string-content text)))
          (unless (whitespace? content)
            (receive (kind recipient message) (parse-content content)
              (client-message tier kind recipient message)
              (set-string-content text "")))))))
  
  
  (method (command-escape self command)
    )
  
  
  ;;;
  ;;;; Layouts
  ;;;


  (method (on-cycle-layouts self evt)
    (let ((world (current-world)))
      (when (eq? stage 'circle)
        (cycle-layouts self)
        (update-layouts self)
        (display-message world (capitalize (symbol->string (get-video-layout)))))))
  
  
  (method (cycle-layouts self)
    (let ((video (current-video)))
      (case (get-video-layout)
        ((gallery)
         (fullscreen-layout video)
         (invalidate-interface))
        ((fullscreen)
         (gallery-layout video)
         (invalidate-interface)))))
  
  
  (method (update-layouts self)
    (let ((interface (current-interface)))
      (set-title (child root '(circlebar layouts))
                 (case (get-video-layout)
                   ((gallery) "Fullscreen")
                   (else "Gallery")))))
  
  
  ;;;
  ;;;; Debug
  ;;;
  
  
  (method (on-toggle-debug self evt)
    (when (eq? stage 'circle)
      (set! show-debug? (not show-debug?))
      (invalidate-interface)))
  
  
  (method (on-toggle-admin self evt)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'admin)))
        (if (get-visible? panel)
            (begin
              (hide-admin self)
              ;; should not be necessary
              (focus-world))
          (show-admin self)
          (acquire-focus (locate panel '(console text)))))))
  
  
  (method (show-admin self)
    (let ((interface (current-interface)))
      (set-visible? (child interface 'admin-label) #t)
      (set-visible? (child interface 'admin) #t)
      (when (eq? stage 'gathering)
        (set-visible? (child root 'join) #f)
        (set-visible? (child root 'circle) #f))
      (layout-view interface)))
  
  
  (method (hide-admin self)
    (let ((interface (current-interface)))
      (set-visible? (child interface 'admin-label) #f)
      (set-visible? (child interface 'admin) #f)
      (when (eq? stage 'gathering)
        (set-visible? (child root 'join) #t)
        (set-visible? (child root 'circle) #t))))
  
  
  (method (on-toggle-replay self evt)
    (case stage
      ((gathering)
       (show-replay/last self))
      ((circle)
       (bell))
      ((replay)
       (hide-replay self))))
  
  
  (method (show-replay/last self)
    (if (not replay)
        (let ((last-replay (world-setting 'world.last-replay #f)))
          (if last-replay
              (bind (name from to now) last-replay
                (let ((dir (new-directory {Directory Settings "work" "requests"} name)))
                  (if (exists? dir)
                      (view-replay self dir from to now)
                    (show-replay self))))
            (show-replay self)))
      (show-replay self)))
  
  
  (method (show-replay self)
    (goto-stage self 'replay))
  
  
  (method (hide-replay self)
    (goto-stage self 'gathering))
  
  
  (method (view-replay self dir (from #f) (to #f) (now #f))
    (let ((interface (current-interface))
          (world (current-world)))
      (if (eq? stage 'circle)
          (display-error world "Cannot view replay in circle")
        (receive (names metadatas chronologies evolutions) (collect-replays dir)
          (define (determine-my-tier)
            (let ((character-name (get-character-name (current-client))))
              (table-find names character-name test: equal?)))
          
          (define (determine-base-time)
            (second (table-ref metadatas #f)))
          
          (let ((tier (determine-my-tier)))
            (if (not tier)
                (display-error world (format "Unable to find my tier {a}" (get-character-name (current-client))))
              (let ((base-time (determine-base-time)))
                (hide-admin self)
                (show-replay self)
                (set! replay (new Replay dir tier names metadatas chronologies evolutions base-time))
                (let ((panel (child root 'timeline)))
                  (set-title panel (get-name dir))
                  (set-highlighted-value panel #f)
                  (set-chronology panel (table-ref chronologies tier))
                  (set-evolution panel (table-ref evolutions tier))
                  (set-evolutions panel evolutions)
                  (setup-replay panel base-time)
                  (when (and from to)
                    (set-bounds panel from to)
                    (update-span panel))
                  (when now
                    (set-now panel now))
                  (set-from replay from)
                  (set-to replay to)
                  (set-now replay now))
                (let ((panel (child root 'evolution)))
                  (if (not now)
                      (clear-evolutions panel)
                    (view-names/evolutions panel names evolutions base-time (- now .025) (+ now .025) now)))
                (set-setting options-settings 'world.last-replay (list (get-name dir) (get-from replay) (get-to replay) (get-now replay)))
                (save-content options-settings))))))))
  
  
  (method package (update-view/now self from to now)
    (let ((panel (child root 'evolution)))
      (let ((names (get-names replay))
            (evolutions (get-evolutions replay))
            (base-time (get-base-time replay)))
        (set-from replay from)
        (set-to replay to)
        (set-now replay now)
        (set-highlighted-cells replay '())
        (when now
          (view-names/evolutions panel names evolutions base-time (- now .025) (+ now .025) now))
        (let ((value (get-highlighted-value replay))
              (col (get-highlighted-column replay)))
          (when value
            (let ((origin (get-highlighted-origin replay))
                  (kind (get-highlighted-kind replay))
                  (tree (locate panel 'entries)))
              (highlight-value self tree origin kind value col)
              (invalidate-view tree))))
        (set-setting options-settings 'world.last-replay (list (get-name (get-directory replay)) from to now))
        (save-content options-settings))))
  
  
  (method package (update-selection self selection)
    (when (not-null? selection)
      (let ((panel (child root 'evolution)))
        (let ((tree (locate panel 'entries)))
          ;; unhighlight
          (for-each (lambda (cell)
                      (let ((data (get-cell-data tree cell)))
                        (set-frame-color data #f)))
                    (get-highlighted-cells replay))
          (set-highlighted-value replay #f)
          (set-highlighted-cells replay '())
          ;; highlight
          (let ((cell (car selection)))
            (let ((line (get-line cell))
                  (col (get-col cell)))
              (let ((row (get-row tree line)))
                (let ((user-data (get-user-data row))
                      (sequence? (= col 5)))
                  (let ((origin (and sequence? (vector-ref user-data (- col 2))))
                        (kind (and sequence? (vector-ref user-data (- col 1))))
                        (value (vector-ref user-data col)))
                    (highlight-value self tree origin kind value col))))))
          ;; invalidate
          (invalidate-view tree))))
    ;; timeline highlighted
    (let ((timeline (child root 'timeline))
          (panel (child root 'evolution)))
      (let ((tree (locate panel 'entries)))
        (let ((selection (get-selection tree)))
          (if (null? selection)
              (set-highlighted-value timeline #f)
            (let ((cell (car selection)))
              (let ((line (get-line cell))
                    (col (get-col cell)))
                (cond ;; time
                      ((= col 0)
                       (let ((row (get-row tree line)))
                         (let ((user-data (get-user-data row)))
                           (let ((value (vector-ref user-data col)))
                             (set-highlighted-value timeline value)
                             (set-highlighted-column timeline 1)))))
                      ;; tier
                      ((= col 1)
                       (let ((row (get-row tree line)))
                         (let ((user-data (get-user-data row)))
                           (let ((value (vector-ref user-data col)))
                             (if (neq? value (get-tier replay))
                                 (set-highlighted-value timeline #f)
                               (set-highlighted-value timeline value)
                               (set-highlighted-column timeline 0))))))
                      ;; sequence
                      ((= col 5)
                       (let ((row (get-row tree line)))
                         (let ((user-data (get-user-data row)))
                           (let ((origin (vector-ref user-data (- col 2)))
                                 (kind (vector-ref user-data (- col 1)))
                                 (value (vector-ref user-data col)))
                             (set-highlighted-origin timeline origin)
                             (set-highlighted-kind timeline kind)
                             (set-highlighted-value timeline value)
                             (set-highlighted-column timeline col)))))
                      ;; value
                      (else
                       (let ((row (get-row tree line)))
                         (let ((user-data (get-user-data row)))
                           (let ((value (vector-ref user-data col)))
                             (set-highlighted-value timeline value)
                             (set-highlighted-column timeline col)))))))))
          (invalidate-view timeline)))))
  
  
  (method (highlight-value self tree origin kind value col)
    (set-highlighted-origin replay origin)
    (set-highlighted-kind replay kind)
    (set-highlighted-value replay value)
    (set-highlighted-column replay col)
    (for-each-visible-row tree
      (lambda (row line)
        (let ((user-data (get-user-data row))
              (sequence? (= col 5)))
          (let ((data-origin (and sequence? (vector-ref user-data (- col 2))))
                (data-kind (and sequence? (vector-ref user-data (- col 1))))
                (data-value (vector-ref user-data col)))
            (when (and (eqv? data-value value)
                       (or (not origin) (eqv? data-origin origin))
                       (or (not kind) (eqv? data-kind kind)))
              (let ((data (get-child row col)))
                (set-frame-color data {Color Red})
                (set-highlighted-cells replay (cons (new Cell line col) (get-highlighted-cells replay))))))))))
  
  
  (method (on-request-replays self evt)
    (let ((interface (current-interface)))
      (let ((panel (child interface 'admin)))
        (let ((text (locate panel '(console text))))
          (show-admin self)
          (acquire-focus text)
          (insert-string text "request all replay")
          (console-return text
            (lambda ()
              (console-evaluate text)))))))
  
  
  (method (on-toggle-capture self evt)
    (let ((world (current-world)))
      (set-capture-screen? (not capture-screen?))
      (display-on/off world "Capture screen" capture-screen?)))
  
  
  (method (on-toggle-mode self evt)
    (let ((world (current-world)))
      (set-video-mode
        (if (eq? video-mode 'fit)
            'fill
          'fit))
      (display-message world (format "Video mode: {a}" video-mode)))))


;;;
;;;; Name-Label
;;;


(class Name-Label extends Label-View
  
  
  (method override (text-color self)
    {Color World-Ochre})
  
  
  (method override (mouse-up self evt)
    (when (developer?)
      (open-login-zone))))


;;;
;;;; People-Panel
;;;


(class People-Panel extends World-Panel
  
  
  (form
    (<install>
      (<Border-View>   name: content location: center border-type: solid border-color: {Color Dark-Gray} style: entry layout-type: fill background: {Color red: .000 green: .000 blue: .000 alpha: .250}
        (<People-View> name: people  location: center)))))


;;;
;;;; People-View
;;;


(class People-View extends Scroller-View
  
  
  (form
    (<install>                                 style: document hscroll?: #t vscroll?: #t
      (<content~>                              layout-type: fill
        (<Tree-Header>                         style: document shown?: #f
          (<content~>
            (<Tree-View>          name: people portfolio: :images filled-column: person background: #f selection-handler: {Event-Handler :form on-selection-change} double-click-handler: {Event-Handler :form on-double-click} return-press-handler: {Event-Handler :form on-return-press}
              (<Tree-Node-Column> name: person title: "Person" width: 235 toplevel-controls?: #f display-images?: #f display-levels?: #f)))))))
  
  
  (method package (on-selection-change self evt)
    (let ((zone (current-zone)))
      (people-selection-change zone)))
  
  
  (method package (on-double-click self evt)
    (let ((zone (current-zone)))
      (people-double-click zone)))
  
  
  (method override (on-return-press self evt)
    (let ((zone (current-zone)))
      (people-return-press zone))))


;;;
;;;; Admin-Panel
;;;


(class Admin-Panel extends World-Panel
  
  
  (form
    (<install>
      (<Border-View>  name: content location: center border-type: solid border-color: {Color Dark-Gray} style: entry layout-type: fill background: {Color red: .000 green: .000 blue: .000 alpha: .250}
        (<Admin-View> name: console location: center)))))


;;;
;;;; Admin-View
;;;


(class Admin-View extends Scroller-View
  
  
  (form
    (<install>
      (<!>                 name: content
        (<Admin-Text-View> name: text    background: #f)))))


;;;
;;;; Circlebar
;;;


;; clearly I don't need 2 distinct World-Sheet and Circlebar-View views
;; investigate or do the foundation work of using world panes everywhere!


(definition hack-transformation?
  (make-parameter #f))


(definition protected (draw-circlebar-sheet)
  (let ((interface (current-interface))
        (world (current-world))
        (zone (current-zone)))
    (let ((view (child (get-root zone) 'circlebar))
          (sheet (get-circlebar-sheet world)))
      (unless (get-uptodate? view)
        (let ((texture (get-texture sheet)))
          (let ((surface (get-surface texture))
                (data (get-data texture)))
            (clear surface)
            (set-clipper surface (new Rect 0 0 2000 2000) @w (get-box (get-offscreen-invalid-region handle)))
            (when (get-visible? view)
              (parameterize ((hack-transformation? #t))
                (paint-drawing view surface '())))
            (map-texture texture)
            (set-uptodate? view #t))))
      (let ((x (cast <fl> (get-left view)))
            (y (cast <fl> (get-top view)))
            (h (cast <fl> (get-height view))))
        (let ((matrix (make-translation-matrix (vertex x (- (get-height world) y h) 0.))))
          (render-sheet sheet matrix))))))


(class Circlebar-View extends Layout-View
  
  
  (slot uptodate? initialize #f accessors generate)
  
  
  (form
    (<install> layout-type: justify))
  
  
  (method override (with-clipping-self-transformation self surface thunk)
    (let ((hack? (hack-transformation?)))
      (with-clipping-transformation surface (if hack? 0 (get-h position)) (if hack? 0 (get-v position)) (get-width size) (get-height size) (get-transformation self)
        thunk))))


(class Circlebar-Button extends Push-Button
  
  
  (method override (invalidate-hook self)
    (set-uptodate? (find-ascendant self Circlebar-View) #f)))


;;;
;;;; Replay
;;;


(class Replay extends Object
  
  
  (slot directory    getter generate)
  (slot tier         getter generate)
  (slot names        getter generate)
  (slot metadatas    getter generate)
  (slot chronologies getter generate)
  (slot evolutions   getter generate)
  (slot base-time    getter generate)
  (slot head         getter generate)
  (slot tail         getter generate)
  
  (slot from               initialize #f  accessors generate)
  (slot to                 initialize #f  accessors generate)
  (slot now                initialize #f  accessors generate)
  (slot highlighted-origin initialize #f  accessors generate)
  (slot highlighted-kind   initialize #f  accessors generate)
  (slot highlighted-value  initialize #f  accessors generate)
  (slot highlighted-column initialize #f  accessors generate)
  (slot highlighted-cells  initialize '() accessors generate)
  
  
  (method override (initialize self directory tier names metadatas chronologies evolutions base-time)
    (define (determine-head)
      (apply min (map (lambda (evolution)
                        (evolutionary-time evolution (first-position evolution)))
                      (table-values evolutions))))
    
    (define (determine-tail)
      (apply max (map (lambda (evolution)
                        (evolutionary-time evolution (last-position evolution)))
                      (table-values evolutions))))
    
    (nextmethod self)
    (set! self.directory directory)
    (set! self.tier tier)
    (set! self.names names)
    (set! self.metadatas metadatas)
    (set! self.chronologies chronologies)
    (set! self.evolutions evolutions)
    (set! self.base-time base-time)
    (set! self.head (determine-head))
    (set! self.tail (determine-tail))))


(class Together-Timeline-Panel extends Timeline-Panel
  
  
  (slot evolutions          initialize '() accessors generate)
  (slot highlighted-title   initialize #f  accessors generate)
  (slot highlighted-markers initialize #f  accessors generate)
  (slot highlighted-origin  initialize #f  accessors generate)
  (slot highlighted-kind    initialize #f  accessors generate)
  (slot highlighted-value   initialize #f  accessors generate)
  (slot highlighted-column  initialize #f  accessors generate)
  
  
  (method override (plot-evolutions self surface from to)
    (let ((width (cast <fl> (get-width self))))
      (cond (highlighted-markers
             (let ((first (first-position chronology))
                   (last (last-position chronology)))
               (define (find-head)
                 (loop (for n from first to last)
                       (when (>= (chronological-time chronology n) from)
                         (return n))
                       (finally first)))
               
               (define (find-tail head)
                 (loop (for n from head to last)
                       (when (> (chronological-time chronology n) to)
                         (return (- n 1)))
                       (finally last)))
               
               (let ((head (find-head)))
                 (let ((tail (find-tail head)))
                   (draw-text surface 5 3 (->string highlighted-title) {Color Gray alpha: .7})
                   (for-each (lambda (n)
                               (when (and (>= n head)
                                          (<= n tail))
                                 (let ((time (chronological-time chronology n))
                                       (marker (chronological-marker chronology n)))
                                   (let ((h (fxround (* (/ (- time from) span) width))))
                                     (let ((color (if (even? marker) {Color Purple} {Color Red}))
                                           (v 120))
                                       (fill-rect surface (new Rect (- h 0) (- v 4) (+ h 1) (+ v 5)) color))))))
                             highlighted-markers)))))
            (highlighted-value
             (draw-text surface 5 3 (->string highlighted-value) {Color Gray alpha: .7})
             (iterate-table evolutions
               (lambda (id evolution)
                 (let ((first (first-position evolution))
                       (last (last-position evolution)))
                   (define (find-head)
                     (loop (for n from first to last)
                           (when (>= (evolutionary-time evolution n) from)
                             (return n))
                           (finally first)))
                   
                   (define (find-tail head)
                     (loop (for n from head to last)
                           (when (> (evolutionary-time evolution n) to)
                             (return (- n 1)))
                           (finally last)))
                   
                   (let ((head (find-head)))
                     (let ((tail (find-tail head)))
                       (loop (for n from head to tail)
                             (case highlighted-column
                               ((0)
                                (let ((time (evolutionary-time evolution n)))
                                  (let ((h (fxround (* (/ (- time from) span) width))))
                                    (let ((color {Color Red})
                                          (v 120))
                                      (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color)))))
                               ((5)
                                (let ((time (evolutionary-time evolution n))
                                      (origin (evolutionary-data1 evolution n))
                                      (kind (evolutionary-data2 evolution n))
                                      (value (evolutionary-data3 evolution n)))
                                  (when (and (eqv? origin highlighted-origin)
                                             (eqv? kind highlighted-kind)
                                             (eqv? value highlighted-value))
                                    (let ((h (fxround (* (/ (- time from) span) width))))
                                      (let ((color {Color Red})
                                            (v 120))
                                        (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color))))))
                               (else
                                (let ((time (evolutionary-time evolution n))
                                      (value (evolutionary-ref evolution n (- highlighted-column 1))))
                                  (when (eqv? value highlighted-value)
                                    (let ((h (fxround (* (/ (- time from) span) width))))
                                      (let ((color {Color Red})
                                            (v 120))
                                        (fill-rect surface (new Rect (- h 2) (- v 2) (+ h 3) (+ v 3)) color)))))))))))))))))
  
  
  (method override (right-mouse-up self evt)
    (zoom-reset self))
  
  
  (method override (view-update self)
    (let ((zone (current-zone)))
      (update-view/now zone from to #f)))
  
  
  (method override (now-update self)
    (let ((zone (current-zone)))
      (update-view/now zone from to now))))


(class Together-Evolution-Panel extends Evolution-Panel
  
  
  (form
    (<install>
      (<entries~> selection-handler: {Event-Handler :form on-selection-change})))
  
  
  (method (on-selection-change self evt)
    (let ((zone (current-zone)))
      (let ((selection (get-selection evt)))
        (update-selection zone selection))))))
