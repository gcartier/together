;;;============
;;;  Together
;;;============
;;;
;;;; Together Experiments
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module together.experiment jazz


(import (jazz.platform)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (world)
        (world.client.tier)
        (world.context)
        (world.task)
        (world.video)
        (together.zone))


;;;
;;;; Experiment
;;;


(definition protected experiments
  '())

(definition protected (add-experiment experiment)
  (set! experiments (append experiments (list experiment))))

(definition protected (remove-experiment experiment)
  (set! experiments (remove! experiment experiments)))


(class Experiment extends Object
  
  
  (slot title    getter generate)
  (slot action   getter generate)
  (slot clear?   getter generate)
  (slot running? accessors generate)
  
  
  (method override (initialize self title action (clear? #f))
    (nextmethod self)
    (set! self.title title)
    (set! self.action action)
    (set! self.clear? clear?)
    (set! self.running? #f))
  
  
  (method override (print self output readably)
    (print-unreadable self output
      (lambda (output)
        (format output "{a}" title)))))


;;;
;;;; Experiments
;;;


(definition protected (install-experiments)
  (for-each (lambda (resolution)
              (add-experiment
                (new Experiment
                  (format "Camera {a}x{a}" (get-width resolution) (get-height resolution))
                  (lambda (feedback)
                    (cond-expand
                      (test
                       (change-camera-resolution resolution)
                       (feedback (format "Camera resolution set to {a}x{a}" (get-width resolution) (get-height resolution))))
                      (else
                       (select-camera-resolution resolution feedback)))))))
            (cache-decreasing-camera-resolutions))
  (cond-expand
    (test
     (add-experiment
       (new Experiment
         "Camera on"
         camera-on-non-blocking
         #t))
     (add-experiment
       (new Experiment
         "Camera off"
         camera-off-non-blocking
         #t))
     (add-experiment
       (new Experiment
         "Camera on blocking"
         camera-on-blocking
         #t))
     (add-experiment
       (new Experiment
         "Camera off blocking"
         camera-off-blocking
         #t)))
    (else)))


(definition (select-camera-resolution resolution feedback)
  (let ((client (current-client))
        (zone (current-zone)))
    (if (neq? (get-stage zone) 'circle)
        (begin
          (bell)
          (feedback "Only available in circle"))
      (with-task-mutex
        (lambda ()
          (change-camera-resolution resolution)
          (when (camera-playing? client)
            (release-camera client)
            (play-camera client))))
      (feedback (format "Camera resolution set to {a}x{a}" (get-width resolution) (get-height resolution)))))
  (sleep .25))


(definition camera-pipeline
  #f)


(definition (camera-on set-state suffix feedback)
  (if camera-pipeline
      (bell)
    (let ((camera-resolution (determine-camera-resolution)))
      (let ((camera-width (get-width camera-resolution))
            (camera-height (get-height camera-resolution)))
        (let ((pipeline (gst-pipeline "avfvideosrc name=src"
                                      (tie "video/x-raw, width={camera-width}, height={camera-height}, pixel-aspect-ratio=(fraction)1/1")
                                      "appsink async=false sync=false name=sink")))
          (feedback "State NULL")
          (set-state pipeline GST_STATE_READY)
          (feedback "State READY")
          (set-state pipeline GST_STATE_PAUSED)
          (feedback "State PAUSED")
          (set-state pipeline GST_STATE_PLAYING)
          (feedback "State PLAYING")
          (set! camera-pipeline pipeline)
          (feedback (format "Camera is on{a}" suffix)))))))


(definition (camera-off set-state suffix feedback)
  (if (not camera-pipeline)
      (bell)
    (feedback "State PLAYING")
    (set-state camera-pipeline GST_STATE_PAUSED)
    (feedback "State PAUSED")
    (set-state camera-pipeline GST_STATE_READY)
    (feedback "State READY")
    (set-state camera-pipeline GST_STATE_NULL)
    (feedback "State NULL")
    (gst_object_unref camera-pipeline)
    (set! camera-pipeline #f)
    (feedback (format "Camera is off{a}" suffix))))


(definition (camera-on-non-blocking feedback)
  (camera-on gst_element_set_state "" feedback))

(definition (camera-off-non-blocking feedback)
  (camera-off gst_element_set_state "" feedback))


(definition (camera-on-blocking feedback)
  (camera-on gst_element_set_state_blocking " (blocking)" feedback))

(definition (camera-off-blocking feedback)
  (camera-off gst_element_set_state_blocking " (blocking)" feedback)))
