;;;============
;;;  Together
;;;============
;;;
;;;; Replay Simulation
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module together.simulation jazz


;;;
;;;; Simulate
;;;


@w
(thread-start!
  (new-thread
    (lambda ()
      (let ((ring (new Time-Ring 256 max-size: 4096 key-proc: identity))
            (now (current-seconds))
            (base (second (car error-list))))
        (define (dbg (data #f))
          (terminal data
                    (get-size ring)
                    (get-head ring)
                    (get-tail ring)
                    (get-count ring)
                    @w
                    (get-content ring)))
        
        (define (collect-times)
          (let ((queue (new-queue)))
            (iterate-content ring
              (lambda (time obj)
                (enqueue queue time)))
            (queue-list queue)))
        
        (define (collect-ring)
          (let ((queue (new-queue)))
            (iterate-content ring
              (lambda (time obj)
                (enqueue queue obj)))
            (queue-list queue)))
        
        (let ((n 1))
          (for-each (lambda (info)
                      (bind (what . rest) info
                        (case what
                          ((insert)
                           (bind (time sequence) rest
                             (let ((time (* n .01)))
                               (increase! n)
                               @w(terminal 'insert time sequence)
                               @w(when (= sequence 251)
                                 (terminal 'BEFORE (collect-ring)))
                               (let ((problem (insert ring (+ now time) sequence)))
                                 (when (= sequence 5)
                                   (terminal (collect-times))
                                   (terminal (collect-ring))
                                   (exit))
                                 @w(when (= sequence 251)
                                   (terminal 'AFTER (collect-ring))
                                   (exit))
                                 @w(when problem
                                   (terminal '******** problem))))))
                          ((wait-all)
                           @w
                           (let ((lst (wait-all ring)))
                             (terminal 'wait-all lst))))))
                    error-list))
        (let ((times (collect-times))
              (content (collect-ring)))
          (assert (equal? (sort < times) times))
          (assert (equal? (sort < content) content)))
        (terminal 'ring
                  (get-size ring)
                  (get-head ring)
                  (get-tail ring)
                  (get-count ring)
                  (collect-times)
                  (collect-ring))
        (terminal 'wait-all (wait-all ring))))))


@w
(sleep 200000)


@w
(thread-start!
  (new-thread
    (lambda ()
      (let ((ring (new Time-Ring 10 max-size: 4096 key-proc: identity))
            (now (current-seconds)))
        (define (dbg (data #f))
          (terminal data
                    (get-size ring)
                    (get-head ring)
                    (get-tail ring)
                    (get-count ring)
                    @w
                    (get-content ring)))
        
        (define (dbg-insert ring time obj)
          (let ((problem (insert ring time obj)))
            (when problem
              (terminal '******** problem))))
        
        (dbg)
        (insert-earliest ring 1)
        (wait ring)
        (dbg)
        (insert-earliest ring 1)
        (wait ring)
        (dbg)
        (loop (for n from 1 to 50)
              (let ()
                (if (= n 10)
                    (begin
                      (dbg-insert ring (+ now (/ n 100.)) n)
                      (dbg-insert ring (+ now (/ n 100.)) n)
                      (dbg-insert ring (+ now (/ n 100.)) n))
                  (if (= n 20)
                      (dbg-insert ring now n)
                    (dbg-insert ring (+ now (/ n 100.)) n))))
              (dbg))
        (sleep .195)
        (loop (repeat 50)
              (let ((data (wait-all ring)))
                (dbg data)))))))


@w
(sleep 2))
