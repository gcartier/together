;;;============
;;;  Together
;;;============
;;;
;;;; Replay Simulation
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module together.simulation jazz


(import (jazz.component)
        (jazz.geometry)
        (jazz.io)
        (jazz.math)
        (jazz.stream)
        (jazz.syntax (phase syntax))
        (jazz.zlib)
        (world)
        (world.audio)
        (world.chronology)
        (world.client.udp)
        (world.context)
        (world.event)
        (world.evolution)
        (world.interface.evolution)
        (world.interface.timeline)
        (world.math)
        (world.server.udp)
        (world.settings)
        (world.simulation)
        (world.stream)
        (world.time)
        (world.udp)
        (together.community)
        (together.replay))


(definition protected debug-insert?
  (world-setting 'together.debug-insert? #f))

(definition protected debug-process?
  (world-setting 'together.debug-process? #f))


;;;
;;;; Output
;;;


;; NOTES
;; - why volume different than gst-play & quicktime
;;   - it is the panorama method=0
;; - buffering takes care of small glitches?
;;   - if I add .01 on each buffer I hear correct audio
;;     and then a big gap
;; - I don't understand why but it would seem we need
;;   buffer-time > time of gc * 2 for imperceptible gcs
;; - duration seems totally ignored
;; - maybe it is the time to test opus

;; TODO
;; - test durations
;; - how does gstreamer play at 2x or .5x
;; - add audiorate element
;;   - can i do it simply for only 1 lib
;; - scaletempo element
;; - save audio somehow or using soundflower and look
;;   at it in-depth using audacity!?


;;;
;;;; Stream
;;;


(class Test-Audio-Sink extends Audio-Sink


  (method override (setup-element self)
    (nextmethod self)
    (let ((pipeline (gst-launch (tie "appsrc name=src")
                                (and (eq? codec 'opus) "opusdec name=dec")
                                (and (eq? codec 'vorbis) "vorbisdec name=dec")
                                "osxaudiosink name=sink")))
      (gst_object_set_name pipeline "output")
      (let ((appsrc (gst_bin_get_by_name pipeline "src")))
        (case codec
          ((opus)
           (gst_app_src_set_caps appsrc
                                 (gst_caps "audio/x-opus"
                                           "channel-mapping-family" (g_value_int 0))))
          ((vorbis)
           (gst_app_src_set_caps appsrc
                                 (gst_caps "audio/x-vorbis"))))
        (g_object_set appsrc
                      "is-live"     (g_value_boolean #t)
                      "stream-type" (g_value_int GST_APP_STREAM_TYPE_STREAM)
                      "format"      (g_value_int GST_FORMAT_TIME))
        (gst_element_set_state pipeline GST_STATE_READY)
        (set! self.pipeline pipeline)
        (set! self.appsrc appsrc)))))


(definition (test-output)
  (let ((output (new Test-Audio-Sink codec: audio-codec)))
    (setup output)
    (start output)
    output))


(definition public (stream-local location (max #f))
  (let ((audio (current-audio)))
    (let ((file (new-file {Directory Settings} (list "streams" (add-extension location "streamaudio")))))
      (let ((port (open-input-file (path-settings file))))
        (let ((time-base (new Time-Base))
              (output (test-output) @w (visualizer-output audio))
              (max (or max 500)))
          (let (loop (count 0))
            (receive (buffer timestamp duration) (read-frame port)
              (when (and buffer (< count max))
                (if (audio-buffer-header? buffer)
                    (receive-audio audio output buffer timestamp duration)
                  (let ((time (current-seconds))
                        (nanostamp (+ (timestamp->flonum timestamp) 0. @w (* count .01))))
                    (update-start time-base time nanostamp)
                    (let ((sendtime (remote->local time-base nanostamp)))
                      (sleep (- sendtime time))
                      (receive-audio audio output buffer timestamp (+ 1000000000 duration)))))
                (loop (+ count 1)))))
          (release output))))))


;;;
;;;; Audio
;;;


(definition (real-modulo x m)
  (- x (* (floor (/ x m)) m)))


(definition public (rise-latency)
  (lambda (elapse)
    (/ elapse 25.)))


(definition public (updown-latency (bottom: bottom 5.) (top: top 5.) (slope: slope 1.) (min: min 0.) (max: max .4))
  (lambda (elapse)
    (let ((a bottom)
          (b (+ bottom slope))
          (c (+ bottom slope top))
          (d (+ bottom slope top slope)))
      (let ((elapse (real-modulo elapse d)))
        (cond ((< elapse a)
               min)
              ((< elapse b)
               (interpolate elapse a b min max))
              ((< elapse c)
               max)
              ((< elapse d)
               (interpolate elapse c d max min))
              (else
               min))))))


(definition public (sin-latency max)
  (lambda (elapse)
    (/ (* (+ (sin elapse) 1.) max) 2.)))


(definition public (simulate-audio location (name: name #f) (start: start #f) (end: end #f) (duration: duration #f) (latency: latency #f) (update-time: update-time #f) (visualize?: visualize? #t))
  (declare (proper-tail-calls))
  (let ((world (current-world)))
    (let ((origin 1)
          (server 0)
          (receiver 2))
      (let ((names (list->table (list (cons origin "Origin")
                                      (cons server "<server>")
                                      (cons receiver "Receiver")))))
        (let ((call (simulate-udp-call names)))
          (let ((origin-tier (require-tier call origin))
                (server-tier (require-tier call server))
                (receiver-tier (require-tier call receiver)))
            (let ((receiver-audio-channel (require-receive-channel receiver-tier origin udp-audio)))
              (let ((receiver-audio-ring (get-process-ring receiver-audio-channel))
                    (average (new Average .05 1.))
                    (origin-evolution (new Evolution 10000))
                    (server-evolution (new Evolution 10000))
                    (receiver-evolution (new Evolution 10000))
                    (chronology (new Chronology 10000))
                    (base-time #f)
                    (base-nanostamp #f)
                    (audio-header #f)
                    (time-base (new Time-Base))
                    (end (or end (and start duration (+ start duration)))))
                (define (determine-latency nanostamp)
                  (let ((elapse (- nanostamp base-nanostamp)))
                    (if latency
                        (latency elapse)
                      0.)))
                
                (define (latencer data)
                  (if (read-udp-media-header? data)
                      0.
                    (let ((elapse (- (read-udp-sent data) base-time)))
                      (/ (+ (sin (* elapse 8.)) 1.) 8.))))
                
                (define (writer data drop?)
                  (parameterize ((simulation-evolution receiver-evolution))
                    (receive-media receiver-tier udp-audio data)))
                
                (set-simulator origin-tier (new UDP-Simulator #f @w latencer #f #f writer))
                (let ((insert (new-thread
                                (lambda ()
                                  (parameterize ((simulation? #t)
                                                 (simulation-update-time update-time)
                                                 (simulation-evolution origin-evolution))
                                    (let ((file (new-file {Directory Settings} (list "streams" (add-extension location "streamaudio")))))
                                      (call-with-input-file (path-settings file)
                                        (lambda (port)
                                          (set! audio-header (read-audio-header audio-codec port))
                                          (when audio-header
                                            (send-media origin-tier udp-audio audio-header #t -1 GST_CLOCK_TIME_NONE))
                                          (let (loop (count 0))
                                            (let ((time (current-seconds)))
                                              (receive (buffer timestamp duration) (read-frame port)
                                                (when buffer
                                                  (let ((nanostamp (timestamp->flonum timestamp)))
                                                    (when (or (not base-nanostamp) (not end) (< (- nanostamp base-nanostamp) end))
                                                      (when (not base-time)
                                                        (set! base-time time)
                                                        (set! base-nanostamp nanostamp))
                                                      (when (or (not start) (>= (- nanostamp base-nanostamp) start))
                                                        (update-start time-base time nanostamp)
                                                        (let ((sendtime (+ (remote->local time-base nanostamp)
                                                                           (determine-latency nanostamp))))
                                                          (sleep (- sendtime time))
                                                          (send-media origin-tier udp-audio buffer #f timestamp duration)))
                                                      (loop (+ count 1))))))))))))
                                  ;; quicky give some time for process to finish
                                  (sleep 1.)
                                  (terminate receiver-audio-ring))
                                'insert))
                      (audio (new-thread
                               (lambda ()
                                 (parameterize ((simulation? #t)
                                                (simulation-evolution receiver-evolution)
                                                (simulation-audio (simulation-output (current-audio))))
                                   (let (looping (count 0))
                                     (let ((info (process-wait receiver-audio-ring average debug-process?)))
                                       (when (neq? info 'terminate)
                                         (present-frame receiver-audio-channel info)
                                         (looping (+ count 1)))))
                                   (sleep 1.)
                                   (release (simulation-audio))))
                               'audio)))
                  (display-message world "Simulating..." duration: +inf.0)
                  (thread-start! insert)
                  (thread-start! audio)
                  (thread-join! insert)
                  (thread-join! audio)
                  (when visualize?
                    (save/view-simulation name base-time names chronology origin server receiver origin-tier server-tier receiver-tier origin-evolution server-evolution receiver-evolution audio-header))
                  (clear-message world))))))))))


(definition (save/view-simulation name base-time names chronology origin server receiver origin-tier server-tier receiver-tier origin-evolution server-evolution receiver-evolution audio-header)
  (let ((directory (timestamped-directory {Directory Settings "work" "simulations"} (if name (string-append "replay_" name) "replay"))))
    (define (save-client no client evolution)
      (define (metadata name)
        (define (send-channels)
          (table-keys (get-send-channels client)))
        
        (define (receive-channels)
          (table-keys (get-receive-channels client)))
        
        (list no name (send-channels) (receive-channels)))
      
      (let ((name (table-ref names no)))
        (let ((metadata (metadata name)))
          (let ((file (new-file directory (add-extension name "replay")))
                (deflated (zlib-deflate (object->u8vector (list metadata chronology evolution) serialize))))
            (save-binary file deflated)))))
    
    (define (save-server no server evolution)
      (define (metadata name)
        (define (start-time)
          base-time)
        
        (define (server-channels)
          (table-keys (get-server-channels server)))
        
        (list no name (start-time) (server-channels)))
      
      (let ((name (table-ref names no)))
        (let ((metadata (metadata name)))
          (let ((file (new-file directory (add-extension name "replay")))
                (deflated (zlib-deflate (object->u8vector (list metadata chronology evolution) serialize))))
            (save-binary file deflated)))))
    
    (define (save-audio)
      (let ((kind udp-audio))
        (let ((channel (find-send-channel origin-tier kind)))
          (let ((ring (get-replay-ring channel))
                (header audio-header))
            (unless (= (get-count ring) 0)
              (let ((file (new-file directory "Origin.replayaudio"))
                    (content (object->u8vector (list ring header) serialize)))
                (save-binary file content)))))))
    
    (define (save-video)
      (let ((kind udp-video))
        (let ((channel (find-send-channel origin-tier kind)))
          (let ((ring (get-replay-ring channel))
                (header #f))
            (unless (= (get-count ring) 0)
              (let ((file (new-file directory "Origin.replayvideo"))
                    (content (object->u8vector (list ring header) serialize)))
                (save-binary file content)))))))
  
    (create-directories directory)
    (save-client origin origin-tier origin-evolution)
    (save-server server server-tier server-evolution)
    (save-client receiver receiver-tier receiver-evolution)
    (save-audio)
    (save-video)
    (view-replay-directory directory)))


;;;
;;;; Replay
;;;


(definition public (simulate-replay origin origin-audio origin-audio-header origin-video origin-evolution server receiver)
  (declare (proper-tail-calls))
  (let ((world (current-world)))
    (let ((names (list->table (list (cons origin "Origin")
                                    (cons server "<server>")
                                    (cons receiver "Receiver")))))
      (let ((call (simulate-udp-call names)))
        (let ((receiver-tier (require-tier call receiver)))
          (let ((receiver-audio-channel (require-receive-channel receiver-tier origin udp-audio))
                (receiver-video-channel (require-receive-channel receiver-tier origin udp-video)))
            (let ((receiver-audio-ring (get-process-ring receiver-audio-channel))
                  (receiver-video-ring (get-process-ring receiver-video-channel))
                  (average (new Average .05 1.))
                  (sender-evolution (new Evolution 10000))
                  (server-evolution (new Evolution 10000))
                  (receiver-evolution (new Evolution 10000))
                  (base-time #f)
                  (start-time #f))
              (define (need-data kind sequence)
                (let ((ring (if (= kind udp-audio) origin-audio origin-video)))
                  (let ((packet (locate-packet ring sequence)))
                    (and packet (get-data packet)))))
              
              ;; mega quicky to test
              (define (need-data2 kind origin sequence frame part total buffer timestamp header?)
                (let ((header-size (+ 8 4 4 4 4 4 4 8 8 4 (u8vector-length buffer))))
                  (let ((data (make-u8vector header-size)))
                    (write-udp-kind data kind)
                    (write-udp-origin data origin)
                    (write-udp-sequence data sequence)
                    (write-udp-frame data frame)
                    (write-udp-part data part)
                    (write-udp-total data total)
                    (write-udp-media-timestamp data timestamp)
                    (write-udp-media-payload data buffer)
                    (write-udp-media-header? data header?)
                    data)))
              
              (define (record-data data)
                (parameterize ((simulation-evolution sender-evolution))
                  (let ((origin (read-udp-origin data))
                        (kind (read-udp-kind data))
                        (sequence (read-udp-sequence data))
                        (frame (read-udp-frame data))
                        (part (read-udp-part data))
                        (total (read-udp-total data))
                        (header? (read-udp-media-header? data))
                        (timestamp (read-udp-media-timestamp data))
                        (duration (read-udp-media-duration data)))
                    (record-event udp-id-create-packet
                                  (fixnum->flonum origin)
                                  (fixnum->flonum kind)
                                  (fixnum->flonum sequence)
                                  (fixnum->flonum frame)
                                  (barbara-header-hack header?)
                                  (if (= timestamp -1)
                                      -1.
                                    (timestamp->flonum timestamp)))
                    (record-event udp-id-create-info
                                  (fixnum->flonum origin)
                                  (fixnum->flonum kind)
                                  (fixnum->flonum sequence)
                                  (fixnum->flonum part)
                                  (fixnum->flonum total)
                                  (if (= duration -1)
                                      -1.
                                    (timestamp->flonum duration)))
                    data)))
              
              (let ((insert (new-thread
                              (lambda ()
                                (parameterize ((simulation? #t)
                                               (simulation-evolution receiver-evolution))
                                  ;; header mega hack
                                  (let ((first-sequence (loop (for n from (first-position origin-evolution) to (last-position origin-evolution))
                                                              (when (= (flonum->fixnum (evolutionary-udp-id origin-evolution n)) udp-id-create-packet)
                                                                (return (evolutionary-udp-sequence origin-evolution n)))))
                                        (first-frame (loop (for n from (first-position origin-evolution) to (last-position origin-evolution))
                                                           (when (= (flonum->fixnum (evolutionary-udp-id origin-evolution n)) udp-id-create-packet)
                                                             (return (evolutionary-udp-frame origin-evolution n))))))
                                    (let ((kind udp-audio)
                                          (sequence-mega-hack (- first-sequence 1))
                                          (frame-mega-hack (- first-frame 1))
                                          (part 0)
                                          (total 1)
                                          (header? #t))
                                      (let ((data (need-data2 kind origin sequence-mega-hack frame-mega-hack part total origin-audio-header -1 header?)))
                                        (record-data data)
                                        (receive-media receiver-tier udp-audio data)
                                        (increase! sequence-mega-hack)
                                        (increase! part))))
                                  
                                  (let ()
                                    (define (simulate kind sequence seconds)
                                      (let ((now (current-seconds)))
                                        (when (not start-time)
                                          (set! base-time now)
                                          (set! start-time seconds))
                                        (let ((time (+ base-time (- seconds start-time))))
                                          (sleep (- time now))
                                          (let ((data (need-data kind sequence)))
                                            (if (not data)
                                                (terminal 'not-found kind sequence)
                                              (record-data data)
                                              (receive-media receiver-tier kind data))))))
                                    
                                    (loop (for n from (first-position origin-evolution) to (last-position origin-evolution))
                                          (let ((id (flonum->fixnum (evolutionary-udp-id origin-evolution n))))
                                            (when (= id udp-id-create-packet)
                                              (let ((time (evolutionary-udp-time origin-evolution n))
                                                    (kind (flonum->fixnum (evolutionary-udp-kind origin-evolution n)))
                                                    (sequence (evolutionary-udp-sequence origin-evolution n)))
                                                ;; quicky for test
                                                (when (= kind udp-audio)
                                                  (when #t @w (or (not start-time)
                                                                  (< (- time start-time) 30.))
                                                    (simulate kind sequence (* 10. time))))))))))
                                (set-$a receiver-audio-ring)
                                (set-$v receiver-video-ring)
                                ;; quicky give some time for process to finish
                                (sleep 1.)
                                (terminate receiver-audio-ring)
                                (terminate receiver-video-ring))
                              'insert))
                    (audio (new-thread
                             (lambda ()
                               (parameterize ((simulation? #t)
                                              (simulation-evolution receiver-evolution)
                                              (simulation-audio (simulation-output (current-audio))))
                                 (let (looping)
                                   (let ((info (process-wait receiver-audio-ring average debug-process?)))
                                     (when (neq? info 'terminate)
                                       (present-frame receiver-audio-channel info)
                                       (looping))))
                                 (release (simulation-audio))))
                             'audio))
                    @w
                    (video (new-thread
                             (lambda ()
                               (parameterize ((simulation? #t)
                                              (simulation-evolution receiver-evolution))
                                 (let (looping)
                                   (let ((info (process-wait receiver-video-ring average debug-process?)))
                                     (when (neq? info 'terminate)
                                       (present-frame receiver-video-channel info)
                                       (looping))))))
                             'video)))
                (display-message world "Simulating..." duration: +inf.0)
                (thread-start! insert)
                (thread-start! audio)
                @w
                (thread-start! video)
                (thread-join! insert)
                (thread-join! audio)
                @w
                (thread-join! video)
                @wait
                (compare-events)
                (clear-message world)
                @w
                (view-simulation origin server receiver names sender-evolution server-evolution receiver-evolution base-time)))))))))


(definition public (view-simulation origin server receiver names origin-evolution server-evolution receiver-evolution base-time)
  (let ((zone (current-zone)))
    (let ((metadatas (list->table (list (cons origin (list origin "Origin" (list udp-audio udp-video) (list)))
                                        (cons server (list server "<server>"))
                                        (cons receiver (list receiver "Receiver" (list) (list (cons origin udp-audio) (cons origin udp-video)))))))
          (chronologies (list->table (list (cons origin (new Chronology 10))
                                           (cons server (new Chronology 10))
                                           (cons receiver (new Chronology 10)))))
          (evolutions (list->table (list (cons origin origin-evolution)
                                         (cons server server-evolution)
                                         (cons receiver receiver-evolution))))
          (audios #f)
          (videos #f))
      (let ((replay (new Replay "simulate" #f receiver names metadatas chronologies evolutions audios videos base-time)))
        (view-replay zone replay)
        (let ((root (get-root zone)))
          (let ((panel (child root 'timeline)))
            (let ((start (timeline-start panel))
                  (end (timeline-end panel)))
              (set-bounds panel start end)
              (update-span panel)
              (set-now panel start)
              (now-update panel)))))))))
