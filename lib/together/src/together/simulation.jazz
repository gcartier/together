;;;============
;;;  Together
;;;============
;;;
;;;; Replay Simulation
;;;
;;;  The Initial Developer of the Original Code is Guillaume Cartier.
;;;  Portions created by the Initial Developer are Copyright (C) 2012-2018
;;;  the Initial Developer. All Rights Reserved.
;;;
;;;  Contributor(s):


(module together.simulation jazz


;;;
;;;; Test
;;;


(import (world.event)
        (world.udp))


(define (test-ring media-kind suite)
  (let ((origin 1))
    (let ((ring (new UDP-Ring origin media-kind udp-process-size max-size: udp-process-max-size time-base?: #t invalid-proc: (udp-ring-invalid origin media-kind) overflow-proc: (udp-ring-overflow 'process udp-ring-kind-process)))
          (datas (make-table test: eqv?))
          (now (current-seconds)))
      (define (need-data sequence frame part total timestamp header?)
        (or (table-ref datas sequence #f)
            (let ((header-size (+ 8 4 4 4 4 4 4 8 8 4)))
              (let ((data (make-u8vector header-size)))
                (write-udp-sequence data sequence)
                (write-udp-frame data frame)
                (write-udp-part data part)
                (write-udp-total data total)
                (write-udp-media-timestamp data timestamp)
                (write-udp-media-header? data header?)
                (table-set! datas sequence data)
                data))))
      
      (let ((insert (new-thread
                      (lambda ()
                        (for-each (lambda (info)
                                    (bind (seconds sequence frame part total timestamp header?) info
                                      (let ((time (+ now seconds))
                                            (data (need-data sequence frame part total timestamp header?)))
                                        (sleep (- time (current-seconds)))
                                        (insert ring time data)
                                        (parameterize ((simulation? #t))
                                          (let ((ring-size (get-count ring)))
                                            (record-event udp-id-insert-packet
                                                          (fixnum->flonum origin)
                                                          (fixnum->flonum media-kind)
                                                          (fixnum->flonum sequence)
                                                          (fixnum->flonum ring-size)
                                                          (if (not timestamp) -1. time)
                                                          (if (not timestamp) -1. timestamp)))))))
                                  suite))
                      'insert))
            (process (new-thread
                       (lambda ()
                         )
                       'process)))
        (thread-start! insert)
        (thread-start! process)
        (thread-join! insert)
        (thread-join! process)))))


(define video-suite
  '((1. 0 0 0 1 0 #f)))


(define audio-suite
  '())


(test-ring udp-video video-suite)


;;;
;;;; Simulate
;;;


@simulate (
(import (jazz.io)
        (jazz.stream)
        (together)
        (world.evolution)
        (world.ring)
        (world.udp))


(initialize-aliases)

(let ((dir {Directory Home ".together" "1.0.0" "work" "requests" "run"}))
  (let ((file (new-file dir "Guillaume_2018-09-10_17-04-30_dca92ab2.evolution")))
    (bind (metadata evolution chronology) (read-evolution file)
      (let ((channel (new UDP-Channel udp-video)))
        (let ((ring (new Time-Ring 256 max-size: 4096 key-proc: udp-ring-key))
              (datas (make-table test: eqv?)))
          (define (need-data seq timestamp)
            (or (table-ref datas seq #f)
                (let ((header-size (+ 8 4 4 4 4 4 4 8 8 4)))
                  (let ((data (make-u8vector header-size)))
                    (write-udp-sequence data seq)
                    (write-udp-media-timestamp data timestamp)
                    (table-set! datas seq data)
                    data))))
          
          ;; receive
          (thread-start!
            (new-thread
              (lambda ()
                (for-each (lambda (entry)
                            (let ((id (fixnum->flonum (get-id entry))))
                              (ecase id
                                ;; update-time
                                ((udp-id-update-time)
                                 (let ((seq (flonum->fixnum (get-data1 entry)))
                                       (timestamp (flonum->timestamp (get-data4 entry))))
                                   (let ((data (need-data seq timestamp)))
                                     (update-time channel seq data ring)
                                     (terminal 'update-time seq timestamp))))
                                ;; insert-media
                                ((udp-id-insert-packet)
                                 (let ((seq (flonum->fixnum (get-data1 entry)))
                                       (timestamp (flonum->timestamp (get-data4 entry)))
                                       (time-base (get-time-base channel)))
                                   (when time-base
                                     (let ((process-time (+ (get-time time-base) (- (timestamp->flonum timestamp) (get-timestamp time-base)) udp-process-window))
                                           (data (need-data seq timestamp)))
                                       (let ((problem (insert ring process-time data)))
                                         @w
                                         (if (not problem)
                                             (terminal 'insert-media seq process-time)
                                           (terminal 'insert-media seq process-time '******** problem))))))
                                 (thread-yield!))
                                ;; process-loop
                                @w
                                ((udp-id-retrieve-packet)
                                 (let ((seq (flonum->fixnum (get-data1 entry)))
                                       (timestamp (flonum->timestamp (get-data4 entry))))
                                   (terminal 'wait)
                                   (let ((all (wait-all ring)))
                                     (terminal 'wait-all (map read-udp-sequence all))))))))
                          entries))
              'receive))
          ;; process
          (thread-start!
            (new-thread
              (lambda ()
                (let ((all (wait-all ring)))
                  (terminal 'wait-all (map read-udp-sequence all))))
              'process))
          ;; sleep
          (sleep 200)))))))


@w
(thread-start!
  (new-thread
    (lambda ()
      (let ((ring (new Time-Ring 256 max-size: 4096 key-proc: identity))
            (now (current-seconds))
            (base (second (car error-list))))
        (define (dbg (data #f))
          (terminal data
                    (get-size ring)
                    (get-head ring)
                    (get-tail ring)
                    (get-count ring)
                    @w
                    (get-content ring)))
        
        (define (collect-times)
          (let ((queue (new-queue)))
            (iterate-content ring
              (lambda (time obj)
                (enqueue queue time)))
            (queue-list queue)))
        
        (define (collect-ring)
          (let ((queue (new-queue)))
            (iterate-content ring
              (lambda (time obj)
                (enqueue queue obj)))
            (queue-list queue)))
        
        (let ((n 1))
          (for-each (lambda (info)
                      (bind (what . rest) info
                        (case what
                          ((insert)
                           (bind (time sequence) rest
                             (let ((time (* n .01)))
                               (increase! n)
                               @w(terminal 'insert time sequence)
                               @w(when (= sequence 251)
                                 (terminal 'BEFORE (collect-ring)))
                               (let ((problem (insert ring (+ now time) sequence)))
                                 (when (= sequence 5)
                                   (terminal (collect-times))
                                   (terminal (collect-ring))
                                   (exit))
                                 @w(when (= sequence 251)
                                   (terminal 'AFTER (collect-ring))
                                   (exit))
                                 @w(when problem
                                   (terminal '******** problem))))))
                          ((wait-all)
                           @w
                           (let ((lst (wait-all ring)))
                             (terminal 'wait-all lst))))))
                    error-list))
        (let ((times (collect-times))
              (content (collect-ring)))
          (assert (equal? (sort < times) times))
          (assert (equal? (sort < content) content)))
        (terminal 'ring
                  (get-size ring)
                  (get-head ring)
                  (get-tail ring)
                  (get-count ring)
                  (collect-times)
                  (collect-ring))
        (terminal 'wait-all (wait-all ring))))))


@w
(sleep 200000)


@w
(thread-start!
  (new-thread
    (lambda ()
      (let ((ring (new Time-Ring 10 max-size: 4096 key-proc: identity))
            (now (current-seconds)))
        (define (dbg (data #f))
          (terminal data
                    (get-size ring)
                    (get-head ring)
                    (get-tail ring)
                    (get-count ring)
                    @w
                    (get-content ring)))
        
        (define (dbg-insert ring time obj)
          (let ((problem (insert ring time obj)))
            (when problem
              (terminal '******** problem))))
        
        (dbg)
        (insert-earliest ring 1)
        (wait ring)
        (dbg)
        (insert-earliest ring 1)
        (wait ring)
        (dbg)
        (loop (for n from 1 to 50)
              (let ()
                (if (= n 10)
                    (begin
                      (dbg-insert ring (+ now (/ n 100.)) n)
                      (dbg-insert ring (+ now (/ n 100.)) n)
                      (dbg-insert ring (+ now (/ n 100.)) n))
                  (if (= n 20)
                      (dbg-insert ring now n)
                    (dbg-insert ring (+ now (/ n 100.)) n))))
              (dbg))
        (sleep .195)
        (loop (repeat 50)
              (let ((data (wait-all ring)))
                (dbg data)))))))


@w
(sleep 2))
